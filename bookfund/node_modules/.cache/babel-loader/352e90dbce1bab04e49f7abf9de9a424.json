{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExecutionContext = exports.EVALUATION_SCRIPT_URL = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n\nexports.EVALUATION_SCRIPT_URL = '__puppeteer_evaluation_script__';\nconst SOURCE_URL_REGEX = /^[\\040\\t]*\\/\\/[@#] sourceURL=\\s*(\\S*?)\\s*$/m;\n/**\n * This class represents a context for JavaScript execution. A [Page] might have\n * many execution contexts:\n * - each\n *   {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe |\n *   frame } has \"default\" execution context that is always created after frame is\n *   attached to DOM. This context is returned by the\n *   {@link frame.executionContext()} method.\n * - {@link https://developer.chrome.com/extensions | Extension}'s content scripts\n *   create additional execution contexts.\n *\n * Besides pages, execution contexts can be found in\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n * workers }.\n *\n * @public\n */\n\nclass ExecutionContext {\n  /**\n   * @internal\n   */\n  constructor(client, contextPayload, world) {\n    this._client = client;\n    this._world = world;\n    this._contextId = contextPayload.id;\n    this._contextName = contextPayload.name;\n  }\n  /**\n   * @remarks\n   *\n   * Not every execution context is associated with a frame. For\n   * example, workers and extensions have execution contexts that are not\n   * associated with frames.\n   *\n   * @returns The frame associated with this execution context.\n   */\n\n\n  frame() {\n    return this._world ? this._world.frame() : null;\n  }\n  /**\n   * @remarks\n   * If the function passed to the `executionContext.evaluate` returns a\n   * Promise, then `executionContext.evaluate` would wait for the promise to\n   * resolve and return its value. If the function passed to the\n   * `executionContext.evaluate` returns a non-serializable value, then\n   * `executionContext.evaluate` resolves to `undefined`. DevTools Protocol also\n   * supports transferring some additional values that are not serializable by\n   * `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.\n   *\n   *\n   * @example\n   * ```js\n   * const executionContext = await page.mainFrame().executionContext();\n   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```js\n   * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the\n   * `executionContext.* evaluate`:\n   * ```js\n   * const oneHandle = await executionContext.evaluateHandle(() => 1);\n   * const twoHandle = await executionContext.evaluateHandle(() => 2);\n   * const result = await executionContext.evaluate(\n   *    (a, b) => a + b, oneHandle, * twoHandle\n   * );\n   * await oneHandle.dispose();\n   * await twoHandle.dispose();\n   * console.log(result); // prints '3'.\n   * ```\n   * @param pageFunction a function to be evaluated in the `executionContext`\n   * @param args argument to pass to the page function\n   *\n   * @returns A promise that resolves to the return value of the given function.\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    return await this._evaluateInternal(true, pageFunction, ...args);\n  }\n  /**\n   * @remarks\n   * The only difference between `executionContext.evaluate` and\n   * `executionContext.evaluateHandle` is that `executionContext.evaluateHandle`\n   * returns an in-page object (a {@link JSHandle}).\n   * If the function passed to the `executionContext.evaluateHandle` returns a\n   * Promise, then `executionContext.evaluateHandle` would wait for the\n   * promise to resolve and return its value.\n   *\n   * @example\n   * ```js\n   * const context = await page.mainFrame().executionContext();\n   * const aHandle = await context.evaluateHandle(() => Promise.resolve(self));\n   * aHandle; // Handle for the global object.\n   * ```\n   *\n   * @example\n   * A string can also be passed in instead of a function.\n   *\n   * ```js\n   * // Handle for the '3' * object.\n   * const aHandle = await context.evaluateHandle('1 + 2');\n   * ```\n   *\n   * @example\n   * JSHandle instances can be passed as arguments\n   * to the `executionContext.* evaluateHandle`:\n   *\n   * ```js\n   * const aHandle = await context.evaluateHandle(() => document.body);\n   * const resultHandle = await context.evaluateHandle(body => body.innerHTML, * aHandle);\n   * console.log(await resultHandle.jsonValue()); // prints body's innerHTML\n   * await aHandle.dispose();\n   * await resultHandle.dispose();\n   * ```\n   *\n   * @param pageFunction a function to be evaluated in the `executionContext`\n   * @param args argument to pass to the page function\n   *\n   * @returns A promise that resolves to the return value of the given function\n   * as an in-page object (a {@link JSHandle}).\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    return this._evaluateInternal(false, pageFunction, ...args);\n  }\n\n  async _evaluateInternal(returnByValue, pageFunction, ...args) {\n    const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;\n\n    if (helper_js_1.helper.isString(pageFunction)) {\n      const contextId = this._contextId;\n      const expression = pageFunction;\n      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + '\\n' + suffix;\n      const {\n        exceptionDetails,\n        result: remoteObject\n      } = await this._client.send('Runtime.evaluate', {\n        expression: expressionWithSourceUrl,\n        contextId,\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      }).catch(rewriteError);\n      if (exceptionDetails) throw new Error('Evaluation failed: ' + helper_js_1.helper.getExceptionMessage(exceptionDetails));\n      return returnByValue ? helper_js_1.helper.valueFromRemoteObject(remoteObject) : JSHandle_js_1.createJSHandle(this, remoteObject);\n    }\n\n    if (typeof pageFunction !== 'function') throw new Error(`Expected to get |string| or |function| as the first argument, but got \"${pageFunction}\" instead.`);\n    let functionText = pageFunction.toString();\n\n    try {\n      new Function('(' + functionText + ')');\n    } catch (error) {\n      // This means we might have a function shorthand. Try another\n      // time prefixing 'function '.\n      if (functionText.startsWith('async ')) functionText = 'async function ' + functionText.substring('async '.length);else functionText = 'function ' + functionText;\n\n      try {\n        new Function('(' + functionText + ')');\n      } catch (error) {\n        // We tried hard to serialize, but there's a weird beast here.\n        throw new Error('Passed function is not well-serializable!');\n      }\n    }\n\n    let callFunctionOnPromise;\n\n    try {\n      callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {\n        functionDeclaration: functionText + '\\n' + suffix + '\\n',\n        executionContextId: this._contextId,\n        arguments: args.map(convertArgument.bind(this)),\n        returnByValue,\n        awaitPromise: true,\n        userGesture: true\n      });\n    } catch (error) {\n      if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) error.message += ' Are you passing a nested JSHandle?';\n      throw error;\n    }\n\n    const {\n      exceptionDetails,\n      result: remoteObject\n    } = await callFunctionOnPromise.catch(rewriteError);\n    if (exceptionDetails) throw new Error('Evaluation failed: ' + helper_js_1.helper.getExceptionMessage(exceptionDetails));\n    return returnByValue ? helper_js_1.helper.valueFromRemoteObject(remoteObject) : JSHandle_js_1.createJSHandle(this, remoteObject);\n    /**\n     * @param {*} arg\n     * @returns {*}\n     * @this {ExecutionContext}\n     */\n\n    function convertArgument(arg) {\n      if (typeof arg === 'bigint') // eslint-disable-line valid-typeof\n        return {\n          unserializableValue: `${arg.toString()}n`\n        };\n      if (Object.is(arg, -0)) return {\n        unserializableValue: '-0'\n      };\n      if (Object.is(arg, Infinity)) return {\n        unserializableValue: 'Infinity'\n      };\n      if (Object.is(arg, -Infinity)) return {\n        unserializableValue: '-Infinity'\n      };\n      if (Object.is(arg, NaN)) return {\n        unserializableValue: 'NaN'\n      };\n      const objectHandle = arg && arg instanceof JSHandle_js_1.JSHandle ? arg : null;\n\n      if (objectHandle) {\n        if (objectHandle._context !== this) throw new Error('JSHandles can be evaluated only in the context they were created!');\n        if (objectHandle._disposed) throw new Error('JSHandle is disposed!');\n        if (objectHandle._remoteObject.unserializableValue) return {\n          unserializableValue: objectHandle._remoteObject.unserializableValue\n        };\n        if (!objectHandle._remoteObject.objectId) return {\n          value: objectHandle._remoteObject.value\n        };\n        return {\n          objectId: objectHandle._remoteObject.objectId\n        };\n      }\n\n      return {\n        value: arg\n      };\n    }\n\n    function rewriteError(error) {\n      if (error.message.includes('Object reference chain is too long')) return {\n        result: {\n          type: 'undefined'\n        }\n      };\n      if (error.message.includes(\"Object couldn't be returned by value\")) return {\n        result: {\n          type: 'undefined'\n        }\n      };\n      if (error.message.endsWith('Cannot find context with specified id') || error.message.endsWith('Inspected target navigated or closed')) throw new Error('Execution context was destroyed, most likely because of a navigation.');\n      throw error;\n    }\n  }\n  /**\n   * This method iterates the JavaScript heap and finds all the objects with the\n   * given prototype.\n   * @remarks\n   * @example\n   * ```js\n   * // Create a Map object\n   * await page.evaluate(() => window.map = new Map());\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   *\n   * @param prototypeHandle a handle to the object prototype\n   *\n   * @returns A handle to an array of objects with the given prototype.\n   */\n\n\n  async queryObjects(prototypeHandle) {\n    assert_js_1.assert(!prototypeHandle._disposed, 'Prototype JSHandle is disposed!');\n    assert_js_1.assert(prototypeHandle._remoteObject.objectId, 'Prototype JSHandle must not be referencing primitive value');\n    const response = await this._client.send('Runtime.queryObjects', {\n      prototypeObjectId: prototypeHandle._remoteObject.objectId\n    });\n    return JSHandle_js_1.createJSHandle(this, response.objects);\n  }\n  /**\n   * @internal\n   */\n\n\n  async _adoptBackendNodeId(backendNodeId) {\n    const {\n      object\n    } = await this._client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: this._contextId\n    });\n    return JSHandle_js_1.createJSHandle(this, object);\n  }\n  /**\n   * @internal\n   */\n\n\n  async _adoptElementHandle(elementHandle) {\n    assert_js_1.assert(elementHandle.executionContext() !== this, 'Cannot adopt handle that already belongs to this execution context');\n    assert_js_1.assert(this._world, 'Cannot adopt handle without DOMWorld');\n    const nodeInfo = await this._client.send('DOM.describeNode', {\n      objectId: elementHandle._remoteObject.objectId\n    });\n    return this._adoptBackendNodeId(nodeInfo.node.backendNodeId);\n  }\n\n}\n\nexports.ExecutionContext = ExecutionContext;","map":{"version":3,"sources":["../../../../src/common/ExecutionContext.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExecutionContext = exports.EVALUATION_SCRIPT_URL = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\nexports.EVALUATION_SCRIPT_URL = '__puppeteer_evaluation_script__';\nconst SOURCE_URL_REGEX = /^[\\040\\t]*\\/\\/[@#] sourceURL=\\s*(\\S*?)\\s*$/m;\n/**\n * This class represents a context for JavaScript execution. A [Page] might have\n * many execution contexts:\n * - each\n *   {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe |\n *   frame } has \"default\" execution context that is always created after frame is\n *   attached to DOM. This context is returned by the\n *   {@link frame.executionContext()} method.\n * - {@link https://developer.chrome.com/extensions | Extension}'s content scripts\n *   create additional execution contexts.\n *\n * Besides pages, execution contexts can be found in\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n * workers }.\n *\n * @public\n */\nclass ExecutionContext {\n    /**\n     * @internal\n     */\n    constructor(client, contextPayload, world) {\n        this._client = client;\n        this._world = world;\n        this._contextId = contextPayload.id;\n        this._contextName = contextPayload.name;\n    }\n    /**\n     * @remarks\n     *\n     * Not every execution context is associated with a frame. For\n     * example, workers and extensions have execution contexts that are not\n     * associated with frames.\n     *\n     * @returns The frame associated with this execution context.\n     */\n    frame() {\n        return this._world ? this._world.frame() : null;\n    }\n    /**\n     * @remarks\n     * If the function passed to the `executionContext.evaluate` returns a\n     * Promise, then `executionContext.evaluate` would wait for the promise to\n     * resolve and return its value. If the function passed to the\n     * `executionContext.evaluate` returns a non-serializable value, then\n     * `executionContext.evaluate` resolves to `undefined`. DevTools Protocol also\n     * supports transferring some additional values that are not serializable by\n     * `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.\n     *\n     *\n     * @example\n     * ```js\n     * const executionContext = await page.mainFrame().executionContext();\n     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;\n     * console.log(result); // prints \"56\"\n     * ```\n     *\n     * @example\n     * A string can also be passed in instead of a function.\n     *\n     * ```js\n     * console.log(await executionContext.evaluate('1 + 2')); // prints \"3\"\n     * ```\n     *\n     * @example\n     * {@link JSHandle} instances can be passed as arguments to the\n     * `executionContext.* evaluate`:\n     * ```js\n     * const oneHandle = await executionContext.evaluateHandle(() => 1);\n     * const twoHandle = await executionContext.evaluateHandle(() => 2);\n     * const result = await executionContext.evaluate(\n     *    (a, b) => a + b, oneHandle, * twoHandle\n     * );\n     * await oneHandle.dispose();\n     * await twoHandle.dispose();\n     * console.log(result); // prints '3'.\n     * ```\n     * @param pageFunction a function to be evaluated in the `executionContext`\n     * @param args argument to pass to the page function\n     *\n     * @returns A promise that resolves to the return value of the given function.\n     */\n    async evaluate(pageFunction, ...args) {\n        return await this._evaluateInternal(true, pageFunction, ...args);\n    }\n    /**\n     * @remarks\n     * The only difference between `executionContext.evaluate` and\n     * `executionContext.evaluateHandle` is that `executionContext.evaluateHandle`\n     * returns an in-page object (a {@link JSHandle}).\n     * If the function passed to the `executionContext.evaluateHandle` returns a\n     * Promise, then `executionContext.evaluateHandle` would wait for the\n     * promise to resolve and return its value.\n     *\n     * @example\n     * ```js\n     * const context = await page.mainFrame().executionContext();\n     * const aHandle = await context.evaluateHandle(() => Promise.resolve(self));\n     * aHandle; // Handle for the global object.\n     * ```\n     *\n     * @example\n     * A string can also be passed in instead of a function.\n     *\n     * ```js\n     * // Handle for the '3' * object.\n     * const aHandle = await context.evaluateHandle('1 + 2');\n     * ```\n     *\n     * @example\n     * JSHandle instances can be passed as arguments\n     * to the `executionContext.* evaluateHandle`:\n     *\n     * ```js\n     * const aHandle = await context.evaluateHandle(() => document.body);\n     * const resultHandle = await context.evaluateHandle(body => body.innerHTML, * aHandle);\n     * console.log(await resultHandle.jsonValue()); // prints body's innerHTML\n     * await aHandle.dispose();\n     * await resultHandle.dispose();\n     * ```\n     *\n     * @param pageFunction a function to be evaluated in the `executionContext`\n     * @param args argument to pass to the page function\n     *\n     * @returns A promise that resolves to the return value of the given function\n     * as an in-page object (a {@link JSHandle}).\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return this._evaluateInternal(false, pageFunction, ...args);\n    }\n    async _evaluateInternal(returnByValue, pageFunction, ...args) {\n        const suffix = `//# sourceURL=${exports.EVALUATION_SCRIPT_URL}`;\n        if (helper_js_1.helper.isString(pageFunction)) {\n            const contextId = this._contextId;\n            const expression = pageFunction;\n            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)\n                ? expression\n                : expression + '\\n' + suffix;\n            const { exceptionDetails, result: remoteObject } = await this._client\n                .send('Runtime.evaluate', {\n                expression: expressionWithSourceUrl,\n                contextId,\n                returnByValue,\n                awaitPromise: true,\n                userGesture: true,\n            })\n                .catch(rewriteError);\n            if (exceptionDetails)\n                throw new Error('Evaluation failed: ' + helper_js_1.helper.getExceptionMessage(exceptionDetails));\n            return returnByValue\n                ? helper_js_1.helper.valueFromRemoteObject(remoteObject)\n                : JSHandle_js_1.createJSHandle(this, remoteObject);\n        }\n        if (typeof pageFunction !== 'function')\n            throw new Error(`Expected to get |string| or |function| as the first argument, but got \"${pageFunction}\" instead.`);\n        let functionText = pageFunction.toString();\n        try {\n            new Function('(' + functionText + ')');\n        }\n        catch (error) {\n            // This means we might have a function shorthand. Try another\n            // time prefixing 'function '.\n            if (functionText.startsWith('async '))\n                functionText =\n                    'async function ' + functionText.substring('async '.length);\n            else\n                functionText = 'function ' + functionText;\n            try {\n                new Function('(' + functionText + ')');\n            }\n            catch (error) {\n                // We tried hard to serialize, but there's a weird beast here.\n                throw new Error('Passed function is not well-serializable!');\n            }\n        }\n        let callFunctionOnPromise;\n        try {\n            callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {\n                functionDeclaration: functionText + '\\n' + suffix + '\\n',\n                executionContextId: this._contextId,\n                arguments: args.map(convertArgument.bind(this)),\n                returnByValue,\n                awaitPromise: true,\n                userGesture: true,\n            });\n        }\n        catch (error) {\n            if (error instanceof TypeError &&\n                error.message.startsWith('Converting circular structure to JSON'))\n                error.message += ' Are you passing a nested JSHandle?';\n            throw error;\n        }\n        const { exceptionDetails, result: remoteObject, } = await callFunctionOnPromise.catch(rewriteError);\n        if (exceptionDetails)\n            throw new Error('Evaluation failed: ' + helper_js_1.helper.getExceptionMessage(exceptionDetails));\n        return returnByValue\n            ? helper_js_1.helper.valueFromRemoteObject(remoteObject)\n            : JSHandle_js_1.createJSHandle(this, remoteObject);\n        /**\n         * @param {*} arg\n         * @returns {*}\n         * @this {ExecutionContext}\n         */\n        function convertArgument(arg) {\n            if (typeof arg === 'bigint')\n                // eslint-disable-line valid-typeof\n                return { unserializableValue: `${arg.toString()}n` };\n            if (Object.is(arg, -0))\n                return { unserializableValue: '-0' };\n            if (Object.is(arg, Infinity))\n                return { unserializableValue: 'Infinity' };\n            if (Object.is(arg, -Infinity))\n                return { unserializableValue: '-Infinity' };\n            if (Object.is(arg, NaN))\n                return { unserializableValue: 'NaN' };\n            const objectHandle = arg && arg instanceof JSHandle_js_1.JSHandle ? arg : null;\n            if (objectHandle) {\n                if (objectHandle._context !== this)\n                    throw new Error('JSHandles can be evaluated only in the context they were created!');\n                if (objectHandle._disposed)\n                    throw new Error('JSHandle is disposed!');\n                if (objectHandle._remoteObject.unserializableValue)\n                    return {\n                        unserializableValue: objectHandle._remoteObject.unserializableValue,\n                    };\n                if (!objectHandle._remoteObject.objectId)\n                    return { value: objectHandle._remoteObject.value };\n                return { objectId: objectHandle._remoteObject.objectId };\n            }\n            return { value: arg };\n        }\n        function rewriteError(error) {\n            if (error.message.includes('Object reference chain is too long'))\n                return { result: { type: 'undefined' } };\n            if (error.message.includes(\"Object couldn't be returned by value\"))\n                return { result: { type: 'undefined' } };\n            if (error.message.endsWith('Cannot find context with specified id') ||\n                error.message.endsWith('Inspected target navigated or closed'))\n                throw new Error('Execution context was destroyed, most likely because of a navigation.');\n            throw error;\n        }\n    }\n    /**\n     * This method iterates the JavaScript heap and finds all the objects with the\n     * given prototype.\n     * @remarks\n     * @example\n     * ```js\n     * // Create a Map object\n     * await page.evaluate(() => window.map = new Map());\n     * // Get a handle to the Map object prototype\n     * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n     * // Query all map instances into an array\n     * const mapInstances = await page.queryObjects(mapPrototype);\n     * // Count amount of map objects in heap\n     * const count = await page.evaluate(maps => maps.length, mapInstances);\n     * await mapInstances.dispose();\n     * await mapPrototype.dispose();\n     * ```\n     *\n     * @param prototypeHandle a handle to the object prototype\n     *\n     * @returns A handle to an array of objects with the given prototype.\n     */\n    async queryObjects(prototypeHandle) {\n        assert_js_1.assert(!prototypeHandle._disposed, 'Prototype JSHandle is disposed!');\n        assert_js_1.assert(prototypeHandle._remoteObject.objectId, 'Prototype JSHandle must not be referencing primitive value');\n        const response = await this._client.send('Runtime.queryObjects', {\n            prototypeObjectId: prototypeHandle._remoteObject.objectId,\n        });\n        return JSHandle_js_1.createJSHandle(this, response.objects);\n    }\n    /**\n     * @internal\n     */\n    async _adoptBackendNodeId(backendNodeId) {\n        const { object } = await this._client.send('DOM.resolveNode', {\n            backendNodeId: backendNodeId,\n            executionContextId: this._contextId,\n        });\n        return JSHandle_js_1.createJSHandle(this, object);\n    }\n    /**\n     * @internal\n     */\n    async _adoptElementHandle(elementHandle) {\n        assert_js_1.assert(elementHandle.executionContext() !== this, 'Cannot adopt handle that already belongs to this execution context');\n        assert_js_1.assert(this._world, 'Cannot adopt handle without DOMWorld');\n        const nodeInfo = await this._client.send('DOM.describeNode', {\n            objectId: elementHandle._remoteObject.objectId,\n        });\n        return this._adoptBackendNodeId(nodeInfo.node.backendNodeId);\n    }\n}\nexports.ExecutionContext = ExecutionContext;\n//# sourceMappingURL=ExecutionContext.js.map"]},"metadata":{},"sourceType":"script"}