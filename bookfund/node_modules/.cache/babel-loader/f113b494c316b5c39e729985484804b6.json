{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\n\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\n\nexports.NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\n\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    this._requestIdToRequest = new Map();\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    this._extraHTTPHeaders = {};\n    this._credentials = null;\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    this._requestIdToInterceptionId = new Map();\n    this._emulatedNetworkConditions = {\n      offline: false,\n      upload: -1,\n      download: -1,\n      latency: 0\n    };\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  async initialize() {\n    await this._client.send('Network.enable');\n    if (this._ignoreHTTPSErrors) await this._client.send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    });\n  }\n\n  async authenticate(credentials) {\n    this._credentials = credentials;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async setExtraHTTPHeaders(extraHTTPHeaders) {\n    this._extraHTTPHeaders = {};\n\n    for (const key of Object.keys(extraHTTPHeaders)) {\n      const value = extraHTTPHeaders[key];\n      assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n      this._extraHTTPHeaders[key.toLowerCase()] = value;\n    }\n\n    await this._client.send('Network.setExtraHTTPHeaders', {\n      headers: this._extraHTTPHeaders\n    });\n  }\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  async setOfflineMode(value) {\n    this._emulatedNetworkConditions.offline = value;\n    await this._updateNetworkConditions();\n  }\n\n  async emulateNetworkConditions(networkConditions) {\n    this._emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;\n    this._emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;\n    this._emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;\n    await this._updateNetworkConditions();\n  }\n\n  async _updateNetworkConditions() {\n    await this._client.send('Network.emulateNetworkConditions', {\n      offline: this._emulatedNetworkConditions.offline,\n      latency: this._emulatedNetworkConditions.latency,\n      uploadThroughput: this._emulatedNetworkConditions.upload,\n      downloadThroughput: this._emulatedNetworkConditions.download\n    });\n  }\n\n  async setUserAgent(userAgent) {\n    await this._client.send('Network.setUserAgentOverride', {\n      userAgent\n    });\n  }\n\n  async setCacheEnabled(enabled) {\n    this._userCacheDisabled = !enabled;\n    await this._updateProtocolCacheDisabled();\n  }\n\n  async setRequestInterception(value) {\n    this._userRequestInterceptionEnabled = value;\n    await this._updateProtocolRequestInterception();\n  }\n\n  async _updateProtocolRequestInterception() {\n    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n    if (enabled === this._protocolRequestInterceptionEnabled) return;\n    this._protocolRequestInterceptionEnabled = enabled;\n\n    if (enabled) {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*'\n        }]\n      })]);\n    } else {\n      await Promise.all([this._updateProtocolCacheDisabled(), this._client.send('Fetch.disable')]);\n    }\n  }\n\n  async _updateProtocolCacheDisabled() {\n    await this._client.send('Network.setCacheDisabled', {\n      cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled\n    });\n  }\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n\n      const interceptionId = this._requestIdToInterceptionId.get(requestId);\n\n      if (interceptionId) {\n        this._onRequest(event, interceptionId);\n\n        this._requestIdToInterceptionId.delete(requestId);\n      } else {\n        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n\n  _onAuthRequired(event) {\n    let response = 'Default';\n\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n\n      this._attemptedAuthentications.add(event.requestId);\n    }\n\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(helper_js_1.debugError);\n  }\n\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(helper_js_1.debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n\n    if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {\n      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToInterceptionId.set(requestId, interceptionId);\n    }\n  }\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n  }\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n  }\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n    request._response = response;\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n  }\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._resolveBody(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._resolveBody(null);\n\n    this._requestIdToRequest.delete(request._requestId);\n\n    this._attemptedAuthentications.delete(request._interceptionId);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n\n}\n\nexports.NetworkManager = NetworkManager;","map":{"version":3,"sources":["../../../../src/common/NetworkManager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexports.NetworkManagerEmittedEvents = {\n    Request: Symbol('NetworkManager.Request'),\n    Response: Symbol('NetworkManager.Response'),\n    RequestFailed: Symbol('NetworkManager.RequestFailed'),\n    RequestFinished: Symbol('NetworkManager.RequestFinished'),\n};\n/**\n * @internal\n */\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n    constructor(client, ignoreHTTPSErrors, frameManager) {\n        super();\n        this._requestIdToRequest = new Map();\n        this._requestIdToRequestWillBeSentEvent = new Map();\n        this._extraHTTPHeaders = {};\n        this._credentials = null;\n        this._attemptedAuthentications = new Set();\n        this._userRequestInterceptionEnabled = false;\n        this._protocolRequestInterceptionEnabled = false;\n        this._userCacheDisabled = false;\n        this._requestIdToInterceptionId = new Map();\n        this._emulatedNetworkConditions = {\n            offline: false,\n            upload: -1,\n            download: -1,\n            latency: 0,\n        };\n        this._client = client;\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._frameManager = frameManager;\n        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n    }\n    async initialize() {\n        await this._client.send('Network.enable');\n        if (this._ignoreHTTPSErrors)\n            await this._client.send('Security.setIgnoreCertificateErrors', {\n                ignore: true,\n            });\n    }\n    async authenticate(credentials) {\n        this._credentials = credentials;\n        await this._updateProtocolRequestInterception();\n    }\n    async setExtraHTTPHeaders(extraHTTPHeaders) {\n        this._extraHTTPHeaders = {};\n        for (const key of Object.keys(extraHTTPHeaders)) {\n            const value = extraHTTPHeaders[key];\n            assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n            this._extraHTTPHeaders[key.toLowerCase()] = value;\n        }\n        await this._client.send('Network.setExtraHTTPHeaders', {\n            headers: this._extraHTTPHeaders,\n        });\n    }\n    extraHTTPHeaders() {\n        return Object.assign({}, this._extraHTTPHeaders);\n    }\n    async setOfflineMode(value) {\n        this._emulatedNetworkConditions.offline = value;\n        await this._updateNetworkConditions();\n    }\n    async emulateNetworkConditions(networkConditions) {\n        this._emulatedNetworkConditions.upload = networkConditions\n            ? networkConditions.upload\n            : -1;\n        this._emulatedNetworkConditions.download = networkConditions\n            ? networkConditions.download\n            : -1;\n        this._emulatedNetworkConditions.latency = networkConditions\n            ? networkConditions.latency\n            : 0;\n        await this._updateNetworkConditions();\n    }\n    async _updateNetworkConditions() {\n        await this._client.send('Network.emulateNetworkConditions', {\n            offline: this._emulatedNetworkConditions.offline,\n            latency: this._emulatedNetworkConditions.latency,\n            uploadThroughput: this._emulatedNetworkConditions.upload,\n            downloadThroughput: this._emulatedNetworkConditions.download,\n        });\n    }\n    async setUserAgent(userAgent) {\n        await this._client.send('Network.setUserAgentOverride', { userAgent });\n    }\n    async setCacheEnabled(enabled) {\n        this._userCacheDisabled = !enabled;\n        await this._updateProtocolCacheDisabled();\n    }\n    async setRequestInterception(value) {\n        this._userRequestInterceptionEnabled = value;\n        await this._updateProtocolRequestInterception();\n    }\n    async _updateProtocolRequestInterception() {\n        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n        if (enabled === this._protocolRequestInterceptionEnabled)\n            return;\n        this._protocolRequestInterceptionEnabled = enabled;\n        if (enabled) {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.enable', {\n                    handleAuthRequests: true,\n                    patterns: [{ urlPattern: '*' }],\n                }),\n            ]);\n        }\n        else {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.disable'),\n            ]);\n        }\n    }\n    async _updateProtocolCacheDisabled() {\n        await this._client.send('Network.setCacheDisabled', {\n            cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled,\n        });\n    }\n    _onRequestWillBeSent(event) {\n        // Request interception doesn't happen for data URLs with Network Service.\n        if (this._protocolRequestInterceptionEnabled &&\n            !event.request.url.startsWith('data:')) {\n            const requestId = event.requestId;\n            const interceptionId = this._requestIdToInterceptionId.get(requestId);\n            if (interceptionId) {\n                this._onRequest(event, interceptionId);\n                this._requestIdToInterceptionId.delete(requestId);\n            }\n            else {\n                this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);\n            }\n            return;\n        }\n        this._onRequest(event, null);\n    }\n    _onAuthRequired(event) {\n        let response = 'Default';\n        if (this._attemptedAuthentications.has(event.requestId)) {\n            response = 'CancelAuth';\n        }\n        else if (this._credentials) {\n            response = 'ProvideCredentials';\n            this._attemptedAuthentications.add(event.requestId);\n        }\n        const { username, password } = this._credentials || {\n            username: undefined,\n            password: undefined,\n        };\n        this._client\n            .send('Fetch.continueWithAuth', {\n            requestId: event.requestId,\n            authChallengeResponse: { response, username, password },\n        })\n            .catch(helper_js_1.debugError);\n    }\n    _onRequestPaused(event) {\n        if (!this._userRequestInterceptionEnabled &&\n            this._protocolRequestInterceptionEnabled) {\n            this._client\n                .send('Fetch.continueRequest', {\n                requestId: event.requestId,\n            })\n                .catch(helper_js_1.debugError);\n        }\n        const requestId = event.networkId;\n        const interceptionId = event.requestId;\n        if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {\n            const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n            this._onRequest(requestWillBeSentEvent, interceptionId);\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n        }\n        else {\n            this._requestIdToInterceptionId.set(requestId, interceptionId);\n        }\n    }\n    _onRequest(event, interceptionId) {\n        let redirectChain = [];\n        if (event.redirectResponse) {\n            const request = this._requestIdToRequest.get(event.requestId);\n            // If we connect late to the target, we could have missed the\n            // requestWillBeSent event.\n            if (request) {\n                this._handleRequestRedirect(request, event.redirectResponse);\n                redirectChain = request._redirectChain;\n            }\n        }\n        const frame = event.frameId\n            ? this._frameManager.frame(event.frameId)\n            : null;\n        const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n        this._requestIdToRequest.set(event.requestId, request);\n        this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n    }\n    _onRequestServedFromCache(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        if (request)\n            request._fromMemoryCache = true;\n    }\n    _handleRequestRedirect(request, responsePayload) {\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n        request._response = response;\n        request._redirectChain.push(request);\n        response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n        this._requestIdToRequest.delete(request._requestId);\n        this._attemptedAuthentications.delete(request._interceptionId);\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onResponseReceived(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // FileUpload sends a response without a matching request.\n        if (!request)\n            return;\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n        request._response = response;\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    }\n    _onLoadingFinished(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        // Under certain conditions we never get the Network.responseReceived\n        // event from protocol. @see https://crbug.com/883475\n        if (request.response())\n            request.response()._resolveBody(null);\n        this._requestIdToRequest.delete(request._requestId);\n        this._attemptedAuthentications.delete(request._interceptionId);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onLoadingFailed(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        request._failureText = event.errorText;\n        const response = request.response();\n        if (response)\n            response._resolveBody(null);\n        this._requestIdToRequest.delete(request._requestId);\n        this._attemptedAuthentications.delete(request._interceptionId);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n    }\n}\nexports.NetworkManager = NetworkManager;\n//# sourceMappingURL=NetworkManager.js.map"]},"metadata":{},"sourceType":"script"}