{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserFetcher = void 0;\n\nconst os = __importStar(require(\"os\"));\n\nconst fs = __importStar(require(\"fs\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst util = __importStar(require(\"util\"));\n\nconst childProcess = __importStar(require(\"child_process\"));\n\nconst https = __importStar(require(\"https\"));\n\nconst http = __importStar(require(\"http\"));\n\nconst extract_zip_1 = __importDefault(require(\"extract-zip\"));\n\nconst Debug_js_1 = require(\"../common/Debug.js\");\n\nconst util_1 = require(\"util\");\n\nconst rimraf_1 = __importDefault(require(\"rimraf\"));\n\nconst URL = __importStar(require(\"url\"));\n\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\n\nconst proxy_from_env_1 = require(\"proxy-from-env\");\n\nconst assert_js_1 = require(\"../common/assert.js\");\n\nconst debugFetcher = Debug_js_1.debug(`puppeteer:fetcher`);\nconst downloadURLs = {\n  chrome: {\n    linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',\n    mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',\n    win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',\n    win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip'\n  },\n  firefox: {\n    linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',\n    mac: '%s/firefox-%s.en-US.%s.dmg',\n    win32: '%s/firefox-%s.en-US.%s.zip',\n    win64: '%s/firefox-%s.en-US.%s.zip'\n  }\n};\nconst browserConfig = {\n  chrome: {\n    host: 'https://storage.googleapis.com',\n    destination: '.local-chromium'\n  },\n  firefox: {\n    host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',\n    destination: '.local-firefox'\n  }\n};\n\nfunction archiveName(product, platform, revision) {\n  if (product === 'chrome') {\n    if (platform === 'linux') return 'chrome-linux';\n    if (platform === 'mac') return 'chrome-mac';\n\n    if (platform === 'win32' || platform === 'win64') {\n      // Windows archive name changed at r591479.\n      return parseInt(revision, 10) > 591479 ? 'chrome-win' : 'chrome-win32';\n    }\n  } else if (product === 'firefox') {\n    return platform;\n  }\n}\n/**\n * @internal\n */\n\n\nfunction downloadURL(product, platform, host, revision) {\n  const url = util.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));\n  return url;\n}\n/**\n * @internal\n */\n\n\nfunction handleArm64() {\n  fs.stat('/usr/bin/chromium-browser', function (err, stats) {\n    if (stats === undefined) {\n      fs.stat('/usr/bin/chromium', function (err, stats) {\n        if (stats === undefined) {\n          console.error(`The chromium binary is not available for arm64.`);\n          console.error(`If you are on Ubuntu, you can install with: `);\n          console.error(`\\n sudo apt install chromium\\n`);\n          console.error(`\\n sudo apt install chromium-browser\\n`);\n          throw new Error();\n        }\n      });\n    }\n  });\n}\n\nconst readdirAsync = util_1.promisify(fs.readdir.bind(fs));\nconst mkdirAsync = util_1.promisify(fs.mkdir.bind(fs));\nconst unlinkAsync = util_1.promisify(fs.unlink.bind(fs));\nconst chmodAsync = util_1.promisify(fs.chmod.bind(fs));\n\nfunction existsAsync(filePath) {\n  return new Promise(resolve => {\n    fs.access(filePath, err => resolve(!err));\n  });\n}\n/**\n * BrowserFetcher can download and manage different versions of Chromium and Firefox.\n *\n * @remarks\n * BrowserFetcher operates on revision strings that specify a precise version of Chromium, e.g. `\"533271\"`. Revision strings can be obtained from {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}.\n * In the Firefox case, BrowserFetcher downloads Firefox Nightly and\n * operates on version numbers such as `\"75\"`.\n *\n * @example\n * An example of using BrowserFetcher to download a specific version of Chromium\n * and running Puppeteer against it:\n *\n * ```js\n * const browserFetcher = puppeteer.createBrowserFetcher();\n * const revisionInfo = await browserFetcher.download('533271');\n * const browser = await puppeteer.launch({executablePath: revisionInfo.executablePath})\n * ```\n *\n * **NOTE** BrowserFetcher is not designed to work concurrently with other\n * instances of BrowserFetcher that share the same downloads directory.\n *\n * @public\n */\n\n\nclass BrowserFetcher {\n  /**\n   * @internal\n   */\n  constructor(projectRoot, options = {}) {\n    this._product = (options.product || 'chrome').toLowerCase();\n    assert_js_1.assert(this._product === 'chrome' || this._product === 'firefox', `Unknown product: \"${options.product}\"`);\n    this._downloadsFolder = options.path || path.join(projectRoot, browserConfig[this._product].destination);\n    this._downloadHost = options.host || browserConfig[this._product].host;\n    this.setPlatform(options.platform);\n    assert_js_1.assert(downloadURLs[this._product][this._platform], 'Unsupported platform: ' + this._platform);\n  }\n\n  setPlatform(platformFromOptions) {\n    if (platformFromOptions) {\n      this._platform = platformFromOptions;\n      return;\n    }\n\n    const platform = os.platform();\n    if (platform === 'darwin') this._platform = 'mac';else if (platform === 'linux') this._platform = 'linux';else if (platform === 'win32') this._platform = os.arch() === 'x64' ? 'win64' : 'win32';else assert_js_1.assert(this._platform, 'Unsupported platform: ' + os.platform());\n  }\n  /**\n   * @returns Returns the current `Platform`.\n   */\n\n\n  platform() {\n    return this._platform;\n  }\n  /**\n   * @returns Returns the current `Product`.\n   */\n\n\n  product() {\n    return this._product;\n  }\n  /**\n   * @returns The download host being used.\n   */\n\n\n  host() {\n    return this._downloadHost;\n  }\n  /**\n   * Initiates a HEAD request to check if the revision is available.\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - The revision to check availability for.\n   * @returns A promise that resolves to `true` if the revision could be downloaded\n   * from the host.\n   */\n\n\n  canDownload(revision) {\n    const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n    return new Promise(resolve => {\n      const request = httpRequest(url, 'HEAD', response => {\n        resolve(response.statusCode === 200);\n      });\n      request.on('error', error => {\n        console.error(error);\n        resolve(false);\n      });\n    });\n  }\n  /**\n   * Initiates a GET request to download the revision from the host.\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - The revision to download.\n   * @param progressCallback - A function that will be called with two arguments:\n   * How many bytes have been downloaded and the total number of bytes of the download.\n   * @returns A promise with revision information when the revision is downloaded\n   * and extracted.\n   */\n\n\n  async download(revision, progressCallback = () => {}) {\n    const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n    const fileName = url.split('/').pop();\n    const archivePath = path.join(this._downloadsFolder, fileName);\n\n    const outputPath = this._getFolderPath(revision);\n\n    if (await existsAsync(outputPath)) return this.revisionInfo(revision);\n    if (!(await existsAsync(this._downloadsFolder))) await mkdirAsync(this._downloadsFolder);\n\n    if (os.arch() === 'arm64') {\n      handleArm64();\n      return;\n    }\n\n    try {\n      await downloadFile(url, archivePath, progressCallback);\n      await install(archivePath, outputPath);\n    } finally {\n      if (await existsAsync(archivePath)) await unlinkAsync(archivePath);\n    }\n\n    const revisionInfo = this.revisionInfo(revision);\n    if (revisionInfo) await chmodAsync(revisionInfo.executablePath, 0o755);\n    return revisionInfo;\n  }\n  /**\n   * @remarks\n   * This method is affected by the current `product`.\n   * @returns A promise with a list of all revision strings (for the current `product`)\n   * available locally on disk.\n   */\n\n\n  async localRevisions() {\n    if (!(await existsAsync(this._downloadsFolder))) return [];\n    const fileNames = await readdirAsync(this._downloadsFolder);\n    return fileNames.map(fileName => parseFolderPath(this._product, fileName)).filter(entry => entry && entry.platform === this._platform).map(entry => entry.revision);\n  }\n  /**\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - A revision to remove for the current `product`.\n   * @returns A promise that resolves when the revision has been removes or\n   * throws if the revision has not been downloaded.\n   */\n\n\n  async remove(revision) {\n    const folderPath = this._getFolderPath(revision);\n\n    assert_js_1.assert(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);\n    await new Promise(fulfill => rimraf_1.default(folderPath, fulfill));\n  }\n  /**\n   * @param revision - The revision to get info for.\n   * @returns The revision info for the given revision.\n   */\n\n\n  revisionInfo(revision) {\n    const folderPath = this._getFolderPath(revision);\n\n    let executablePath = '';\n\n    if (this._product === 'chrome') {\n      if (this._platform === 'mac') executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');else if (this._platform === 'linux') executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome');else if (this._platform === 'win32' || this._platform === 'win64') executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome.exe');else throw new Error('Unsupported platform: ' + this._platform);\n    } else if (this._product === 'firefox') {\n      if (this._platform === 'mac') executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');else if (this._platform === 'linux') executablePath = path.join(folderPath, 'firefox', 'firefox');else if (this._platform === 'win32' || this._platform === 'win64') executablePath = path.join(folderPath, 'firefox', 'firefox.exe');else throw new Error('Unsupported platform: ' + this._platform);\n    } else {\n      throw new Error('Unsupported product: ' + this._product);\n    }\n\n    const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n    const local = fs.existsSync(folderPath);\n    debugFetcher({\n      revision,\n      executablePath,\n      folderPath,\n      local,\n      url,\n      product: this._product\n    });\n    return {\n      revision,\n      executablePath,\n      folderPath,\n      local,\n      url,\n      product: this._product\n    };\n  }\n  /**\n   * @internal\n   */\n\n\n  _getFolderPath(revision) {\n    return path.join(this._downloadsFolder, this._platform + '-' + revision);\n  }\n\n}\n\nexports.BrowserFetcher = BrowserFetcher;\n\nfunction parseFolderPath(product, folderPath) {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) return null;\n  const [platform, revision] = splits;\n  if (!downloadURLs[product][platform]) return null;\n  return {\n    product,\n    platform,\n    revision\n  };\n}\n/**\n * @internal\n */\n\n\nfunction downloadFile(url, destinationPath, progressCallback) {\n  debugFetcher(`Downloading binary from ${url}`);\n  let fulfill, reject;\n  let downloadedBytes = 0;\n  let totalBytes = 0;\n  const promise = new Promise((x, y) => {\n    fulfill = x;\n    reject = y;\n  });\n  const request = httpRequest(url, 'GET', response => {\n    if (response.statusCode !== 200) {\n      const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`); // consume response data to free up memory\n\n      response.resume();\n      reject(error);\n      return;\n    }\n\n    const file = fs.createWriteStream(destinationPath);\n    file.on('finish', () => fulfill());\n    file.on('error', error => reject(error));\n    response.pipe(file);\n    totalBytes = parseInt(\n    /** @type {string} */\n    response.headers['content-length'], 10);\n    if (progressCallback) response.on('data', onData);\n  });\n  request.on('error', error => reject(error));\n  return promise;\n\n  function onData(chunk) {\n    downloadedBytes += chunk.length;\n    progressCallback(downloadedBytes, totalBytes);\n  }\n}\n\nfunction install(archivePath, folderPath) {\n  debugFetcher(`Installing ${archivePath} to ${folderPath}`);\n  if (archivePath.endsWith('.zip')) return extract_zip_1.default(archivePath, {\n    dir: folderPath\n  });else if (archivePath.endsWith('.tar.bz2')) return extractTar(archivePath, folderPath);else if (archivePath.endsWith('.dmg')) return mkdirAsync(folderPath).then(() => installDMG(archivePath, folderPath));else throw new Error(`Unsupported archive format: ${archivePath}`);\n}\n/**\n * @internal\n */\n\n\nfunction extractTar(tarPath, folderPath) {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  const tar = require('tar-fs'); // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\n  const bzip = require('unbzip2-stream');\n\n  return new Promise((fulfill, reject) => {\n    const tarStream = tar.extract(folderPath);\n    tarStream.on('error', reject);\n    tarStream.on('finish', fulfill);\n    const readStream = fs.createReadStream(tarPath);\n    readStream.pipe(bzip()).pipe(tarStream);\n  });\n}\n/**\n * @internal\n */\n\n\nfunction installDMG(dmgPath, folderPath) {\n  let mountPath;\n\n  function mountAndCopy(fulfill, reject) {\n    const mountCommand = `hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`;\n    childProcess.exec(mountCommand, (err, stdout) => {\n      if (err) return reject(err);\n      const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n      if (!volumes) return reject(new Error(`Could not find volume path in ${stdout}`));\n      mountPath = volumes[0];\n      readdirAsync(mountPath).then(fileNames => {\n        const appName = fileNames.filter(item => typeof item === 'string' && item.endsWith('.app'))[0];\n        if (!appName) return reject(new Error(`Cannot find app in ${mountPath}`));\n        const copyPath = path.join(mountPath, appName);\n        debugFetcher(`Copying ${copyPath} to ${folderPath}`);\n        childProcess.exec(`cp -R \"${copyPath}\" \"${folderPath}\"`, err => {\n          if (err) reject(err);else fulfill();\n        });\n      }).catch(reject);\n    });\n  }\n\n  function unmount() {\n    if (!mountPath) return;\n    const unmountCommand = `hdiutil detach \"${mountPath}\" -quiet`;\n    debugFetcher(`Unmounting ${mountPath}`);\n    childProcess.exec(unmountCommand, err => {\n      if (err) console.error(`Error unmounting dmg: ${err}`);\n    });\n  }\n\n  return new Promise(mountAndCopy).catch(error => {\n    console.error(error);\n  }).finally(unmount);\n}\n\nfunction httpRequest(url, method, response) {\n  const urlParsed = URL.parse(url);\n  let options = { ...urlParsed,\n    method\n  };\n  const proxyURL = proxy_from_env_1.getProxyForUrl(url);\n\n  if (proxyURL) {\n    if (url.startsWith('http:')) {\n      const proxy = URL.parse(proxyURL);\n      options = {\n        path: options.href,\n        host: proxy.hostname,\n        port: proxy.port\n      };\n    } else {\n      const parsedProxyURL = URL.parse(proxyURL);\n      const proxyOptions = { ...parsedProxyURL,\n        secureProxy: parsedProxyURL.protocol === 'https:'\n      };\n      options.agent = https_proxy_agent_1.default(proxyOptions);\n      options.rejectUnauthorized = false;\n    }\n  }\n\n  const requestCallback = res => {\n    if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) httpRequest(res.headers.location, method, response);else response(res);\n  };\n\n  const request = options.protocol === 'https:' ? https.request(options, requestCallback) : http.request(options, requestCallback);\n  request.end();\n  return request;\n}","map":{"version":3,"sources":["../../../../src/node/BrowserFetcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BrowserFetcher = void 0;\nconst os = __importStar(require(\"os\"));\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\nconst util = __importStar(require(\"util\"));\nconst childProcess = __importStar(require(\"child_process\"));\nconst https = __importStar(require(\"https\"));\nconst http = __importStar(require(\"http\"));\nconst extract_zip_1 = __importDefault(require(\"extract-zip\"));\nconst Debug_js_1 = require(\"../common/Debug.js\");\nconst util_1 = require(\"util\");\nconst rimraf_1 = __importDefault(require(\"rimraf\"));\nconst URL = __importStar(require(\"url\"));\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\nconst proxy_from_env_1 = require(\"proxy-from-env\");\nconst assert_js_1 = require(\"../common/assert.js\");\nconst debugFetcher = Debug_js_1.debug(`puppeteer:fetcher`);\nconst downloadURLs = {\n    chrome: {\n        linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',\n        mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',\n        win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',\n        win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip',\n    },\n    firefox: {\n        linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',\n        mac: '%s/firefox-%s.en-US.%s.dmg',\n        win32: '%s/firefox-%s.en-US.%s.zip',\n        win64: '%s/firefox-%s.en-US.%s.zip',\n    },\n};\nconst browserConfig = {\n    chrome: {\n        host: 'https://storage.googleapis.com',\n        destination: '.local-chromium',\n    },\n    firefox: {\n        host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',\n        destination: '.local-firefox',\n    },\n};\nfunction archiveName(product, platform, revision) {\n    if (product === 'chrome') {\n        if (platform === 'linux')\n            return 'chrome-linux';\n        if (platform === 'mac')\n            return 'chrome-mac';\n        if (platform === 'win32' || platform === 'win64') {\n            // Windows archive name changed at r591479.\n            return parseInt(revision, 10) > 591479 ? 'chrome-win' : 'chrome-win32';\n        }\n    }\n    else if (product === 'firefox') {\n        return platform;\n    }\n}\n/**\n * @internal\n */\nfunction downloadURL(product, platform, host, revision) {\n    const url = util.format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));\n    return url;\n}\n/**\n * @internal\n */\nfunction handleArm64() {\n    fs.stat('/usr/bin/chromium-browser', function (err, stats) {\n        if (stats === undefined) {\n            fs.stat('/usr/bin/chromium', function (err, stats) {\n                if (stats === undefined) {\n                    console.error(`The chromium binary is not available for arm64.`);\n                    console.error(`If you are on Ubuntu, you can install with: `);\n                    console.error(`\\n sudo apt install chromium\\n`);\n                    console.error(`\\n sudo apt install chromium-browser\\n`);\n                    throw new Error();\n                }\n            });\n        }\n    });\n}\nconst readdirAsync = util_1.promisify(fs.readdir.bind(fs));\nconst mkdirAsync = util_1.promisify(fs.mkdir.bind(fs));\nconst unlinkAsync = util_1.promisify(fs.unlink.bind(fs));\nconst chmodAsync = util_1.promisify(fs.chmod.bind(fs));\nfunction existsAsync(filePath) {\n    return new Promise((resolve) => {\n        fs.access(filePath, (err) => resolve(!err));\n    });\n}\n/**\n * BrowserFetcher can download and manage different versions of Chromium and Firefox.\n *\n * @remarks\n * BrowserFetcher operates on revision strings that specify a precise version of Chromium, e.g. `\"533271\"`. Revision strings can be obtained from {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}.\n * In the Firefox case, BrowserFetcher downloads Firefox Nightly and\n * operates on version numbers such as `\"75\"`.\n *\n * @example\n * An example of using BrowserFetcher to download a specific version of Chromium\n * and running Puppeteer against it:\n *\n * ```js\n * const browserFetcher = puppeteer.createBrowserFetcher();\n * const revisionInfo = await browserFetcher.download('533271');\n * const browser = await puppeteer.launch({executablePath: revisionInfo.executablePath})\n * ```\n *\n * **NOTE** BrowserFetcher is not designed to work concurrently with other\n * instances of BrowserFetcher that share the same downloads directory.\n *\n * @public\n */\nclass BrowserFetcher {\n    /**\n     * @internal\n     */\n    constructor(projectRoot, options = {}) {\n        this._product = (options.product || 'chrome').toLowerCase();\n        assert_js_1.assert(this._product === 'chrome' || this._product === 'firefox', `Unknown product: \"${options.product}\"`);\n        this._downloadsFolder =\n            options.path ||\n                path.join(projectRoot, browserConfig[this._product].destination);\n        this._downloadHost = options.host || browserConfig[this._product].host;\n        this.setPlatform(options.platform);\n        assert_js_1.assert(downloadURLs[this._product][this._platform], 'Unsupported platform: ' + this._platform);\n    }\n    setPlatform(platformFromOptions) {\n        if (platformFromOptions) {\n            this._platform = platformFromOptions;\n            return;\n        }\n        const platform = os.platform();\n        if (platform === 'darwin')\n            this._platform = 'mac';\n        else if (platform === 'linux')\n            this._platform = 'linux';\n        else if (platform === 'win32')\n            this._platform = os.arch() === 'x64' ? 'win64' : 'win32';\n        else\n            assert_js_1.assert(this._platform, 'Unsupported platform: ' + os.platform());\n    }\n    /**\n     * @returns Returns the current `Platform`.\n     */\n    platform() {\n        return this._platform;\n    }\n    /**\n     * @returns Returns the current `Product`.\n     */\n    product() {\n        return this._product;\n    }\n    /**\n     * @returns The download host being used.\n     */\n    host() {\n        return this._downloadHost;\n    }\n    /**\n     * Initiates a HEAD request to check if the revision is available.\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - The revision to check availability for.\n     * @returns A promise that resolves to `true` if the revision could be downloaded\n     * from the host.\n     */\n    canDownload(revision) {\n        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n        return new Promise((resolve) => {\n            const request = httpRequest(url, 'HEAD', (response) => {\n                resolve(response.statusCode === 200);\n            });\n            request.on('error', (error) => {\n                console.error(error);\n                resolve(false);\n            });\n        });\n    }\n    /**\n     * Initiates a GET request to download the revision from the host.\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - The revision to download.\n     * @param progressCallback - A function that will be called with two arguments:\n     * How many bytes have been downloaded and the total number of bytes of the download.\n     * @returns A promise with revision information when the revision is downloaded\n     * and extracted.\n     */\n    async download(revision, progressCallback = () => { }) {\n        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n        const fileName = url.split('/').pop();\n        const archivePath = path.join(this._downloadsFolder, fileName);\n        const outputPath = this._getFolderPath(revision);\n        if (await existsAsync(outputPath))\n            return this.revisionInfo(revision);\n        if (!(await existsAsync(this._downloadsFolder)))\n            await mkdirAsync(this._downloadsFolder);\n        if (os.arch() === 'arm64') {\n            handleArm64();\n            return;\n        }\n        try {\n            await downloadFile(url, archivePath, progressCallback);\n            await install(archivePath, outputPath);\n        }\n        finally {\n            if (await existsAsync(archivePath))\n                await unlinkAsync(archivePath);\n        }\n        const revisionInfo = this.revisionInfo(revision);\n        if (revisionInfo)\n            await chmodAsync(revisionInfo.executablePath, 0o755);\n        return revisionInfo;\n    }\n    /**\n     * @remarks\n     * This method is affected by the current `product`.\n     * @returns A promise with a list of all revision strings (for the current `product`)\n     * available locally on disk.\n     */\n    async localRevisions() {\n        if (!(await existsAsync(this._downloadsFolder)))\n            return [];\n        const fileNames = await readdirAsync(this._downloadsFolder);\n        return fileNames\n            .map((fileName) => parseFolderPath(this._product, fileName))\n            .filter((entry) => entry && entry.platform === this._platform)\n            .map((entry) => entry.revision);\n    }\n    /**\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - A revision to remove for the current `product`.\n     * @returns A promise that resolves when the revision has been removes or\n     * throws if the revision has not been downloaded.\n     */\n    async remove(revision) {\n        const folderPath = this._getFolderPath(revision);\n        assert_js_1.assert(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);\n        await new Promise((fulfill) => rimraf_1.default(folderPath, fulfill));\n    }\n    /**\n     * @param revision - The revision to get info for.\n     * @returns The revision info for the given revision.\n     */\n    revisionInfo(revision) {\n        const folderPath = this._getFolderPath(revision);\n        let executablePath = '';\n        if (this._product === 'chrome') {\n            if (this._platform === 'mac')\n                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');\n            else if (this._platform === 'linux')\n                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome');\n            else if (this._platform === 'win32' || this._platform === 'win64')\n                executablePath = path.join(folderPath, archiveName(this._product, this._platform, revision), 'chrome.exe');\n            else\n                throw new Error('Unsupported platform: ' + this._platform);\n        }\n        else if (this._product === 'firefox') {\n            if (this._platform === 'mac')\n                executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');\n            else if (this._platform === 'linux')\n                executablePath = path.join(folderPath, 'firefox', 'firefox');\n            else if (this._platform === 'win32' || this._platform === 'win64')\n                executablePath = path.join(folderPath, 'firefox', 'firefox.exe');\n            else\n                throw new Error('Unsupported platform: ' + this._platform);\n        }\n        else {\n            throw new Error('Unsupported product: ' + this._product);\n        }\n        const url = downloadURL(this._product, this._platform, this._downloadHost, revision);\n        const local = fs.existsSync(folderPath);\n        debugFetcher({\n            revision,\n            executablePath,\n            folderPath,\n            local,\n            url,\n            product: this._product,\n        });\n        return {\n            revision,\n            executablePath,\n            folderPath,\n            local,\n            url,\n            product: this._product,\n        };\n    }\n    /**\n     * @internal\n     */\n    _getFolderPath(revision) {\n        return path.join(this._downloadsFolder, this._platform + '-' + revision);\n    }\n}\nexports.BrowserFetcher = BrowserFetcher;\nfunction parseFolderPath(product, folderPath) {\n    const name = path.basename(folderPath);\n    const splits = name.split('-');\n    if (splits.length !== 2)\n        return null;\n    const [platform, revision] = splits;\n    if (!downloadURLs[product][platform])\n        return null;\n    return { product, platform, revision };\n}\n/**\n * @internal\n */\nfunction downloadFile(url, destinationPath, progressCallback) {\n    debugFetcher(`Downloading binary from ${url}`);\n    let fulfill, reject;\n    let downloadedBytes = 0;\n    let totalBytes = 0;\n    const promise = new Promise((x, y) => {\n        fulfill = x;\n        reject = y;\n    });\n    const request = httpRequest(url, 'GET', (response) => {\n        if (response.statusCode !== 200) {\n            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n            // consume response data to free up memory\n            response.resume();\n            reject(error);\n            return;\n        }\n        const file = fs.createWriteStream(destinationPath);\n        file.on('finish', () => fulfill());\n        file.on('error', (error) => reject(error));\n        response.pipe(file);\n        totalBytes = parseInt(\n        /** @type {string} */ response.headers['content-length'], 10);\n        if (progressCallback)\n            response.on('data', onData);\n    });\n    request.on('error', (error) => reject(error));\n    return promise;\n    function onData(chunk) {\n        downloadedBytes += chunk.length;\n        progressCallback(downloadedBytes, totalBytes);\n    }\n}\nfunction install(archivePath, folderPath) {\n    debugFetcher(`Installing ${archivePath} to ${folderPath}`);\n    if (archivePath.endsWith('.zip'))\n        return extract_zip_1.default(archivePath, { dir: folderPath });\n    else if (archivePath.endsWith('.tar.bz2'))\n        return extractTar(archivePath, folderPath);\n    else if (archivePath.endsWith('.dmg'))\n        return mkdirAsync(folderPath).then(() => installDMG(archivePath, folderPath));\n    else\n        throw new Error(`Unsupported archive format: ${archivePath}`);\n}\n/**\n * @internal\n */\nfunction extractTar(tarPath, folderPath) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const tar = require('tar-fs');\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const bzip = require('unbzip2-stream');\n    return new Promise((fulfill, reject) => {\n        const tarStream = tar.extract(folderPath);\n        tarStream.on('error', reject);\n        tarStream.on('finish', fulfill);\n        const readStream = fs.createReadStream(tarPath);\n        readStream.pipe(bzip()).pipe(tarStream);\n    });\n}\n/**\n * @internal\n */\nfunction installDMG(dmgPath, folderPath) {\n    let mountPath;\n    function mountAndCopy(fulfill, reject) {\n        const mountCommand = `hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`;\n        childProcess.exec(mountCommand, (err, stdout) => {\n            if (err)\n                return reject(err);\n            const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n            if (!volumes)\n                return reject(new Error(`Could not find volume path in ${stdout}`));\n            mountPath = volumes[0];\n            readdirAsync(mountPath)\n                .then((fileNames) => {\n                const appName = fileNames.filter((item) => typeof item === 'string' && item.endsWith('.app'))[0];\n                if (!appName)\n                    return reject(new Error(`Cannot find app in ${mountPath}`));\n                const copyPath = path.join(mountPath, appName);\n                debugFetcher(`Copying ${copyPath} to ${folderPath}`);\n                childProcess.exec(`cp -R \"${copyPath}\" \"${folderPath}\"`, (err) => {\n                    if (err)\n                        reject(err);\n                    else\n                        fulfill();\n                });\n            })\n                .catch(reject);\n        });\n    }\n    function unmount() {\n        if (!mountPath)\n            return;\n        const unmountCommand = `hdiutil detach \"${mountPath}\" -quiet`;\n        debugFetcher(`Unmounting ${mountPath}`);\n        childProcess.exec(unmountCommand, (err) => {\n            if (err)\n                console.error(`Error unmounting dmg: ${err}`);\n        });\n    }\n    return new Promise(mountAndCopy)\n        .catch((error) => {\n        console.error(error);\n    })\n        .finally(unmount);\n}\nfunction httpRequest(url, method, response) {\n    const urlParsed = URL.parse(url);\n    let options = {\n        ...urlParsed,\n        method,\n    };\n    const proxyURL = proxy_from_env_1.getProxyForUrl(url);\n    if (proxyURL) {\n        if (url.startsWith('http:')) {\n            const proxy = URL.parse(proxyURL);\n            options = {\n                path: options.href,\n                host: proxy.hostname,\n                port: proxy.port,\n            };\n        }\n        else {\n            const parsedProxyURL = URL.parse(proxyURL);\n            const proxyOptions = {\n                ...parsedProxyURL,\n                secureProxy: parsedProxyURL.protocol === 'https:',\n            };\n            options.agent = https_proxy_agent_1.default(proxyOptions);\n            options.rejectUnauthorized = false;\n        }\n    }\n    const requestCallback = (res) => {\n        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)\n            httpRequest(res.headers.location, method, response);\n        else\n            response(res);\n    };\n    const request = options.protocol === 'https:'\n        ? https.request(options, requestCallback)\n        : http.request(options, requestCallback);\n    request.end();\n    return request;\n}\n//# sourceMappingURL=BrowserFetcher.js.map"]},"metadata":{},"sourceType":"script"}