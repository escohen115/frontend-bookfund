{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\n\nfunction mitt(all) {\n  all = all || new Map();\n  return {\n    /**\n     * A Map of event names to registered handler functions.\n     */\n    all,\n\n    /**\n     * Register an event handler for the given type.\n     * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n     * @param {Function} handler Function to call in response to given event\n     * @memberOf mitt\n     */\n    on(type, handler) {\n      const handlers = all.get(type);\n      const added = handlers && handlers.push(handler);\n\n      if (!added) {\n        all.set(type, [handler]);\n      }\n    },\n\n    /**\n     * Remove an event handler for the given type.\n     * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n     * @param {Function} handler Handler function to remove\n     * @memberOf mitt\n     */\n    off(type, handler) {\n      const handlers = all.get(type);\n\n      if (handlers) {\n        handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n      }\n    },\n\n    /**\n     * Invoke all handlers for the given type.\n     * If present, `\"*\"` handlers are invoked after type-matched handlers.\n     *\n     * Note: Manually firing \"*\" handlers is not supported.\n     *\n     * @param {string|symbol} type The event type to invoke\n     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n     * @memberOf mitt\n     */\n    emit(type, evt) {\n      (all.get(type) || []).slice().map(handler => {\n        handler(evt);\n      });\n      (all.get('*') || []).slice().map(handler => {\n        handler(type, evt);\n      });\n    }\n\n  };\n}\n\nexports.default = mitt;","map":{"version":3,"sources":["../../../../../vendor/mitt/src/index.ts"],"names":[],"mappings":";;;;;AA2BA;;;;AAIG;;AACH,SAAwB,IAAxB,CAA6B,GAA7B,EAAkD;AACjD,EAAA,GAAG,GAAG,GAAG,IAAI,IAAI,GAAJ,EAAb;AAEA,SAAO;AAEN;;AAEG;AACH,IAAA,GALM;;AAON;;;;;AAKG;AACH,IAAA,EAAE,CAAU,IAAV,EAA2B,OAA3B,EAA8C;AAC/C,YAAM,QAAQ,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAAR,CAAjB;AACA,YAAM,KAAK,GAAG,QAAQ,IAAI,QAAQ,CAAC,IAAT,CAAc,OAAd,CAA1B;;AACA,UAAI,CAAC,KAAL,EAAY;AACX,QAAA,GAAG,CAAC,GAAJ,CAAQ,IAAR,EAAc,CAAC,OAAD,CAAd;AACA;AACD,KAnBK;;AAqBN;;;;;AAKG;AACH,IAAA,GAAG,CAAU,IAAV,EAA2B,OAA3B,EAA8C;AAChD,YAAM,QAAQ,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAAR,CAAjB;;AACA,UAAI,QAAJ,EAAc;AACb,QAAA,QAAQ,CAAC,MAAT,CAAgB,QAAQ,CAAC,OAAT,CAAiB,OAAjB,MAA8B,CAA9C,EAAiD,CAAjD;AACA;AACD,KAhCK;;AAkCN;;;;;;;;;AASG;AACH,IAAA,IAAI,CAAU,IAAV,EAA2B,GAA3B,EAAiC;AACnC,OAAC,GAAG,CAAC,GAAJ,CAAQ,IAAR,KAAiB,EAAlB,EAA2C,KAA3C,GAAmD,GAAnD,CAAwD,OAAD,IAAY;AAAG,QAAA,OAAO,CAAC,GAAD,CAAP;AAAe,OAArF;AACA,OAAC,GAAG,CAAC,GAAJ,CAAQ,GAAR,KAAgB,EAAjB,EAAkD,KAAlD,GAA0D,GAA1D,CAA+D,OAAD,IAAY;AAAG,QAAA,OAAO,CAAC,IAAD,EAAO,GAAP,CAAP;AAAqB,OAAlG;AACD;;AA/CK,GAAP;AAiDA;;AApDD,OAAA,CAAA,OAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nfunction mitt(all) {\n    all = all || new Map();\n    return {\n        /**\n         * A Map of event names to registered handler functions.\n         */\n        all,\n        /**\n         * Register an event handler for the given type.\n         * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n         * @param {Function} handler Function to call in response to given event\n         * @memberOf mitt\n         */\n        on(type, handler) {\n            const handlers = all.get(type);\n            const added = handlers && handlers.push(handler);\n            if (!added) {\n                all.set(type, [handler]);\n            }\n        },\n        /**\n         * Remove an event handler for the given type.\n         * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n         * @param {Function} handler Handler function to remove\n         * @memberOf mitt\n         */\n        off(type, handler) {\n            const handlers = all.get(type);\n            if (handlers) {\n                handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n            }\n        },\n        /**\n         * Invoke all handlers for the given type.\n         * If present, `\"*\"` handlers are invoked after type-matched handlers.\n         *\n         * Note: Manually firing \"*\" handlers is not supported.\n         *\n         * @param {string|symbol} type The event type to invoke\n         * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n         * @memberOf mitt\n         */\n        emit(type, evt) {\n            (all.get(type) || []).slice().map((handler) => { handler(evt); });\n            (all.get('*') || []).slice().map((handler) => { handler(type, evt); });\n        }\n    };\n}\nexports.default = mitt;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}