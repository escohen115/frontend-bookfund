{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTTPRequest = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n/**\n *\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`:  emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\n\n\nclass HTTPRequest {\n  /**\n   * @internal\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    /**\n     * @internal\n     */\n    this._failureText = null;\n    /**\n     * @internal\n     */\n\n    this._response = null;\n    /**\n     * @internal\n     */\n\n    this._fromMemoryCache = false;\n    this._interceptionHandled = false;\n    this._headers = {};\n    this._client = client;\n    this._requestId = event.requestId;\n    this._isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._url = event.request.url;\n    this._resourceType = event.type.toLowerCase();\n    this._method = event.request.method;\n    this._postData = event.request.postData;\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n\n    for (const key of Object.keys(event.request.headers)) this._headers[key.toLowerCase()] = event.request.headers[key];\n  }\n  /**\n   * @returns the URL of the request\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * Contains the request's resource type as it was perceived by the rendering\n   * engine.\n   * @remarks\n   * @returns one of the following: `document`, `stylesheet`, `image`, `media`,\n   * `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`,\n   * `manifest`, `other`.\n   */\n\n\n  resourceType() {\n    // TODO (@jackfranklin): protocol.d.ts has a type for this, but all the\n    // string values are uppercase. The Puppeteer docs explicitly say the\n    // potential values are all lower case, and the constructor takes the event\n    // type and calls toLowerCase() on it, so we can't reuse the type from the\n    // protocol.d.ts. Why do we lower case?\n    return this._resourceType;\n  }\n  /**\n   * @returns the method used (`GET`, `POST`, etc.)\n   */\n\n\n  method() {\n    return this._method;\n  }\n  /**\n   * @returns the request's post body, if any.\n   */\n\n\n  postData() {\n    return this._postData;\n  }\n  /**\n   * @returns an object with HTTP headers associated with the request. All\n   * header names are lower-case.\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @returns the response for this request, if a response has been received.\n   */\n\n\n  response() {\n    return this._response;\n  }\n  /**\n   * @returns the frame that initiated the request.\n   */\n\n\n  frame() {\n    return this._frame;\n  }\n  /**\n   * @returns true if the request is the driver of the current frame's navigation.\n   */\n\n\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n  /**\n   * @remarks\n   *\n   * `redirectChain` is shared between all the requests of the same chain.\n   *\n   * For example, if the website `http://example.com` has a single redirect to\n   * `https://example.com`, then the chain will contain one request:\n   *\n   * ```js\n   * const response = await page.goto('http://example.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 1\n   * console.log(chain[0].url()); // 'http://example.com'\n   * ```\n   *\n   * If the website `https://google.com` has no redirects, then the chain will be empty:\n   *\n   * ```js\n   * const response = await page.goto('https://google.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 0\n   * ```\n   *\n   * @returns the chain of requests - if a server responds with at least a\n   * single redirect, this chain will contain all requests that were redirected.\n   */\n\n\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  /**\n   * Access information about the request's failure.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * Example of logging all failed requests:\n   *\n   * ```js\n   * page.on('requestfailed', request => {\n   *   console.log(request.url() + ' ' + request.failure().errorText);\n   * });\n   * ```\n   *\n   * @returns `null` unless the request failed. If the request fails this can\n   * return an object with `errorText` containing a human-readable error\n   * message, e.g. `net::ERR_FAILED`. It is not guaranteeded that there will be\n   * failure text if the request fails.\n   */\n\n\n  failure() {\n    if (!this._failureText) return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n  /**\n   * Continues request with optional request overrides.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   *\n   * @example\n   * ```js\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   // Override headers\n   *   const headers = Object.assign({}, request.headers(), {\n   *     foo: 'bar', // set \"foo\" header\n   *     origin: undefined, // remove \"origin\" header\n   *   });\n   *   request.continue({headers});\n   * });\n   * ```\n   *\n   * @param overrides - optional overrides to apply to the request.\n   */\n\n\n  async continue(overrides = {}) {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:')) return;\n    assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this._interceptionHandled = true;\n    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n    await this._client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData: postDataBinaryBase64,\n      headers: headers ? headersArray(headers) : undefined\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was\n      // already canceled or the page was closed. We should tolerate these\n      // errors.\n      helper_js_1.debugError(error);\n    });\n  }\n  /**\n   * Fulfills a request with the given response.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   *\n   * @example\n   * An example of fulfilling all requests with 404 responses:\n   * ```js\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   request.respond({\n   *     status: 404,\n   *     contentType: 'text/plain',\n   *     body: 'Not Found!'\n   *   });\n   * });\n   * ```\n   *\n   * NOTE: Mocking responses for dataURL requests is not supported.\n   * Calling `request.respond` for a dataURL request is a noop.\n   *\n   * @param response - the response to fulfill the request with.\n   */\n\n\n  async respond(response) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this._url.startsWith('data:')) return;\n    assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    const responseBody = response.body && helper_js_1.helper.isString(response.body) ? Buffer.from(response.body) : response.body || null;\n    const responseHeaders = {};\n\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) responseHeaders[header.toLowerCase()] = response.headers[header];\n    }\n\n    if (response.contentType) responseHeaders['content-type'] = response.contentType;\n    if (responseBody && !('content-length' in responseHeaders)) responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n    await this._client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: response.status || 200,\n      responsePhrase: STATUS_TEXTS[response.status || 200],\n      responseHeaders: headersArray(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was\n      // already canceled or the page was closed. We should tolerate these\n      // errors.\n      helper_js_1.debugError(error);\n    });\n  }\n  /**\n   * Aborts a request.\n   *\n   * @remarks\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}. If it is not enabled, this method will\n   * throw an exception immediately.\n   *\n   * @param errorCode - optional error code to provide.\n   */\n\n\n  async abort(errorCode = 'failed') {\n    // Request interception is not supported for data: urls.\n    if (this._url.startsWith('data:')) return;\n    const errorReason = errorReasons[errorCode];\n    assert_js_1.assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n    assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n    this._interceptionHandled = true;\n    await this._client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason\n    }).catch(error => {\n      // In certain cases, protocol will return error if the request was\n      // already canceled or the page was closed. We should tolerate these\n      // errors.\n      helper_js_1.debugError(error);\n    });\n  }\n\n}\n\nexports.HTTPRequest = HTTPRequest;\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\n\nfunction headersArray(headers) {\n  const result = [];\n\n  for (const name in headers) {\n    if (!Object.is(headers[name], undefined)) result.push({\n      name,\n      value: headers[name] + ''\n    });\n  }\n\n  return result;\n} // List taken from\n// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n// with extra 306 and 418 codes.\n\n\nconst STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': \"I'm a teapot\",\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};","map":{"version":3,"sources":["../../../../src/common/HTTPRequest.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTTPRequest = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\n/**\n *\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`:  emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\nclass HTTPRequest {\n    /**\n     * @internal\n     */\n    constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n        /**\n         * @internal\n         */\n        this._failureText = null;\n        /**\n         * @internal\n         */\n        this._response = null;\n        /**\n         * @internal\n         */\n        this._fromMemoryCache = false;\n        this._interceptionHandled = false;\n        this._headers = {};\n        this._client = client;\n        this._requestId = event.requestId;\n        this._isNavigationRequest =\n            event.requestId === event.loaderId && event.type === 'Document';\n        this._interceptionId = interceptionId;\n        this._allowInterception = allowInterception;\n        this._url = event.request.url;\n        this._resourceType = event.type.toLowerCase();\n        this._method = event.request.method;\n        this._postData = event.request.postData;\n        this._frame = frame;\n        this._redirectChain = redirectChain;\n        for (const key of Object.keys(event.request.headers))\n            this._headers[key.toLowerCase()] = event.request.headers[key];\n    }\n    /**\n     * @returns the URL of the request\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * Contains the request's resource type as it was perceived by the rendering\n     * engine.\n     * @remarks\n     * @returns one of the following: `document`, `stylesheet`, `image`, `media`,\n     * `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`,\n     * `manifest`, `other`.\n     */\n    resourceType() {\n        // TODO (@jackfranklin): protocol.d.ts has a type for this, but all the\n        // string values are uppercase. The Puppeteer docs explicitly say the\n        // potential values are all lower case, and the constructor takes the event\n        // type and calls toLowerCase() on it, so we can't reuse the type from the\n        // protocol.d.ts. Why do we lower case?\n        return this._resourceType;\n    }\n    /**\n     * @returns the method used (`GET`, `POST`, etc.)\n     */\n    method() {\n        return this._method;\n    }\n    /**\n     * @returns the request's post body, if any.\n     */\n    postData() {\n        return this._postData;\n    }\n    /**\n     * @returns an object with HTTP headers associated with the request. All\n     * header names are lower-case.\n     */\n    headers() {\n        return this._headers;\n    }\n    /**\n     * @returns the response for this request, if a response has been received.\n     */\n    response() {\n        return this._response;\n    }\n    /**\n     * @returns the frame that initiated the request.\n     */\n    frame() {\n        return this._frame;\n    }\n    /**\n     * @returns true if the request is the driver of the current frame's navigation.\n     */\n    isNavigationRequest() {\n        return this._isNavigationRequest;\n    }\n    /**\n     * @remarks\n     *\n     * `redirectChain` is shared between all the requests of the same chain.\n     *\n     * For example, if the website `http://example.com` has a single redirect to\n     * `https://example.com`, then the chain will contain one request:\n     *\n     * ```js\n     * const response = await page.goto('http://example.com');\n     * const chain = response.request().redirectChain();\n     * console.log(chain.length); // 1\n     * console.log(chain[0].url()); // 'http://example.com'\n     * ```\n     *\n     * If the website `https://google.com` has no redirects, then the chain will be empty:\n     *\n     * ```js\n     * const response = await page.goto('https://google.com');\n     * const chain = response.request().redirectChain();\n     * console.log(chain.length); // 0\n     * ```\n     *\n     * @returns the chain of requests - if a server responds with at least a\n     * single redirect, this chain will contain all requests that were redirected.\n     */\n    redirectChain() {\n        return this._redirectChain.slice();\n    }\n    /**\n     * Access information about the request's failure.\n     *\n     * @remarks\n     *\n     * @example\n     *\n     * Example of logging all failed requests:\n     *\n     * ```js\n     * page.on('requestfailed', request => {\n     *   console.log(request.url() + ' ' + request.failure().errorText);\n     * });\n     * ```\n     *\n     * @returns `null` unless the request failed. If the request fails this can\n     * return an object with `errorText` containing a human-readable error\n     * message, e.g. `net::ERR_FAILED`. It is not guaranteeded that there will be\n     * failure text if the request fails.\n     */\n    failure() {\n        if (!this._failureText)\n            return null;\n        return {\n            errorText: this._failureText,\n        };\n    }\n    /**\n     * Continues request with optional request overrides.\n     *\n     * @remarks\n     *\n     * To use this, request\n     * interception should be enabled with {@link Page.setRequestInterception}.\n     *\n     * Exception is immediately thrown if the request interception is not enabled.\n     *\n     * @example\n     * ```js\n     * await page.setRequestInterception(true);\n     * page.on('request', request => {\n     *   // Override headers\n     *   const headers = Object.assign({}, request.headers(), {\n     *     foo: 'bar', // set \"foo\" header\n     *     origin: undefined, // remove \"origin\" header\n     *   });\n     *   request.continue({headers});\n     * });\n     * ```\n     *\n     * @param overrides - optional overrides to apply to the request.\n     */\n    async continue(overrides = {}) {\n        // Request interception is not supported for data: urls.\n        if (this._url.startsWith('data:'))\n            return;\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n        const { url, method, postData, headers } = overrides;\n        this._interceptionHandled = true;\n        const postDataBinaryBase64 = postData\n            ? Buffer.from(postData).toString('base64')\n            : undefined;\n        await this._client\n            .send('Fetch.continueRequest', {\n            requestId: this._interceptionId,\n            url,\n            method,\n            postData: postDataBinaryBase64,\n            headers: headers ? headersArray(headers) : undefined,\n        })\n            .catch((error) => {\n            // In certain cases, protocol will return error if the request was\n            // already canceled or the page was closed. We should tolerate these\n            // errors.\n            helper_js_1.debugError(error);\n        });\n    }\n    /**\n     * Fulfills a request with the given response.\n     *\n     * @remarks\n     *\n     * To use this, request\n     * interception should be enabled with {@link Page.setRequestInterception}.\n     *\n     * Exception is immediately thrown if the request interception is not enabled.\n     *\n     * @example\n     * An example of fulfilling all requests with 404 responses:\n     * ```js\n     * await page.setRequestInterception(true);\n     * page.on('request', request => {\n     *   request.respond({\n     *     status: 404,\n     *     contentType: 'text/plain',\n     *     body: 'Not Found!'\n     *   });\n     * });\n     * ```\n     *\n     * NOTE: Mocking responses for dataURL requests is not supported.\n     * Calling `request.respond` for a dataURL request is a noop.\n     *\n     * @param response - the response to fulfill the request with.\n     */\n    async respond(response) {\n        // Mocking responses for dataURL requests is not currently supported.\n        if (this._url.startsWith('data:'))\n            return;\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n        this._interceptionHandled = true;\n        const responseBody = response.body && helper_js_1.helper.isString(response.body)\n            ? Buffer.from(response.body)\n            : response.body || null;\n        const responseHeaders = {};\n        if (response.headers) {\n            for (const header of Object.keys(response.headers))\n                responseHeaders[header.toLowerCase()] = response.headers[header];\n        }\n        if (response.contentType)\n            responseHeaders['content-type'] = response.contentType;\n        if (responseBody && !('content-length' in responseHeaders))\n            responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n        await this._client\n            .send('Fetch.fulfillRequest', {\n            requestId: this._interceptionId,\n            responseCode: response.status || 200,\n            responsePhrase: STATUS_TEXTS[response.status || 200],\n            responseHeaders: headersArray(responseHeaders),\n            body: responseBody ? responseBody.toString('base64') : undefined,\n        })\n            .catch((error) => {\n            // In certain cases, protocol will return error if the request was\n            // already canceled or the page was closed. We should tolerate these\n            // errors.\n            helper_js_1.debugError(error);\n        });\n    }\n    /**\n     * Aborts a request.\n     *\n     * @remarks\n     * To use this, request interception should be enabled with\n     * {@link Page.setRequestInterception}. If it is not enabled, this method will\n     * throw an exception immediately.\n     *\n     * @param errorCode - optional error code to provide.\n     */\n    async abort(errorCode = 'failed') {\n        // Request interception is not supported for data: urls.\n        if (this._url.startsWith('data:'))\n            return;\n        const errorReason = errorReasons[errorCode];\n        assert_js_1.assert(errorReason, 'Unknown error code: ' + errorCode);\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n        this._interceptionHandled = true;\n        await this._client\n            .send('Fetch.failRequest', {\n            requestId: this._interceptionId,\n            errorReason,\n        })\n            .catch((error) => {\n            // In certain cases, protocol will return error if the request was\n            // already canceled or the page was closed. We should tolerate these\n            // errors.\n            helper_js_1.debugError(error);\n        });\n    }\n}\nexports.HTTPRequest = HTTPRequest;\nconst errorReasons = {\n    aborted: 'Aborted',\n    accessdenied: 'AccessDenied',\n    addressunreachable: 'AddressUnreachable',\n    blockedbyclient: 'BlockedByClient',\n    blockedbyresponse: 'BlockedByResponse',\n    connectionaborted: 'ConnectionAborted',\n    connectionclosed: 'ConnectionClosed',\n    connectionfailed: 'ConnectionFailed',\n    connectionrefused: 'ConnectionRefused',\n    connectionreset: 'ConnectionReset',\n    internetdisconnected: 'InternetDisconnected',\n    namenotresolved: 'NameNotResolved',\n    timedout: 'TimedOut',\n    failed: 'Failed',\n};\nfunction headersArray(headers) {\n    const result = [];\n    for (const name in headers) {\n        if (!Object.is(headers[name], undefined))\n            result.push({ name, value: headers[name] + '' });\n    }\n    return result;\n}\n// List taken from\n// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n// with extra 306 and 418 codes.\nconst STATUS_TEXTS = {\n    '100': 'Continue',\n    '101': 'Switching Protocols',\n    '102': 'Processing',\n    '103': 'Early Hints',\n    '200': 'OK',\n    '201': 'Created',\n    '202': 'Accepted',\n    '203': 'Non-Authoritative Information',\n    '204': 'No Content',\n    '205': 'Reset Content',\n    '206': 'Partial Content',\n    '207': 'Multi-Status',\n    '208': 'Already Reported',\n    '226': 'IM Used',\n    '300': 'Multiple Choices',\n    '301': 'Moved Permanently',\n    '302': 'Found',\n    '303': 'See Other',\n    '304': 'Not Modified',\n    '305': 'Use Proxy',\n    '306': 'Switch Proxy',\n    '307': 'Temporary Redirect',\n    '308': 'Permanent Redirect',\n    '400': 'Bad Request',\n    '401': 'Unauthorized',\n    '402': 'Payment Required',\n    '403': 'Forbidden',\n    '404': 'Not Found',\n    '405': 'Method Not Allowed',\n    '406': 'Not Acceptable',\n    '407': 'Proxy Authentication Required',\n    '408': 'Request Timeout',\n    '409': 'Conflict',\n    '410': 'Gone',\n    '411': 'Length Required',\n    '412': 'Precondition Failed',\n    '413': 'Payload Too Large',\n    '414': 'URI Too Long',\n    '415': 'Unsupported Media Type',\n    '416': 'Range Not Satisfiable',\n    '417': 'Expectation Failed',\n    '418': \"I'm a teapot\",\n    '421': 'Misdirected Request',\n    '422': 'Unprocessable Entity',\n    '423': 'Locked',\n    '424': 'Failed Dependency',\n    '425': 'Too Early',\n    '426': 'Upgrade Required',\n    '428': 'Precondition Required',\n    '429': 'Too Many Requests',\n    '431': 'Request Header Fields Too Large',\n    '451': 'Unavailable For Legal Reasons',\n    '500': 'Internal Server Error',\n    '501': 'Not Implemented',\n    '502': 'Bad Gateway',\n    '503': 'Service Unavailable',\n    '504': 'Gateway Timeout',\n    '505': 'HTTP Version Not Supported',\n    '506': 'Variant Also Negotiates',\n    '507': 'Insufficient Storage',\n    '508': 'Loop Detected',\n    '510': 'Not Extended',\n    '511': 'Network Authentication Required',\n};\n//# sourceMappingURL=HTTPRequest.js.map"]},"metadata":{},"sourceType":"script"}