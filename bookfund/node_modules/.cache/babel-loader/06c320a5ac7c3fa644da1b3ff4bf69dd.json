{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Coverage = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n/**\n * The Coverage class provides methods to gathers information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n * ```js\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage()\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges)\n *     usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);\n * ```\n * @public\n */\n\n\nclass Coverage {\n  constructor(client) {\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n  /**\n   * @param options - defaults to\n   * `{ resetOnNavigation : true, reportAnonymousScripts : false }`\n   * @returns Promise that resolves when coverage is started.\n   *\n   * @remarks\n   * Anonymous scripts are ones that don't have an associated url. These are\n   * scripts that are dynamically created on the page using `eval` or\n   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n   * scripts will have `__puppeteer_evaluation_script__` as their URL.\n   */\n\n\n  async startJSCoverage(options = {}) {\n    return await this._jsCoverage.start(options);\n  }\n  /**\n   * @returns Promise that resolves to the array of coverage reports for\n   * all scripts.\n   *\n   * @remarks\n   * JavaScript Coverage doesn't include anonymous scripts by default.\n   * However, scripts with sourceURLs are reported.\n   */\n\n\n  async stopJSCoverage() {\n    return await this._jsCoverage.stop();\n  }\n  /**\n   * @param options - defaults to `{ resetOnNavigation : true }`\n   * @returns Promise that resolves when coverage is started.\n   */\n\n\n  async startCSSCoverage(options = {}) {\n    return await this._cssCoverage.start(options);\n  }\n  /**\n   * @returns Promise that resolves to the array of coverage reports\n   * for all stylesheets.\n   * @remarks\n   * CSS Coverage doesn't include dynamically injected style tags\n   * without sourceURLs.\n   */\n\n\n  async stopCSSCoverage() {\n    return await this._cssCoverage.stop();\n  }\n\n}\n\nexports.Coverage = Coverage;\n\nclass JSCoverage {\n  constructor(client) {\n    this._enabled = false;\n    this._scriptURLs = new Map();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n    this._reportAnonymousScripts = false;\n    this._client = client;\n  }\n\n  async start(options = {}) {\n    assert_js_1.assert(!this._enabled, 'JSCoverage is already enabled');\n    const {\n      resetOnNavigation = true,\n      reportAnonymousScripts = false\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._reportAnonymousScripts = reportAnonymousScripts;\n    this._enabled = true;\n\n    this._scriptURLs.clear();\n\n    this._scriptSources.clear();\n\n    this._eventListeners = [helper_js_1.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)), helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this))];\n    await Promise.all([this._client.send('Profiler.enable'), this._client.send('Profiler.startPreciseCoverage', {\n      callCount: false,\n      detailed: true\n    }), this._client.send('Debugger.enable'), this._client.send('Debugger.setSkipAllPauses', {\n      skip: true\n    })]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n\n    this._scriptURLs.clear();\n\n    this._scriptSources.clear();\n  }\n\n  async _onScriptParsed(event) {\n    // Ignore puppeteer-injected scripts\n    if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL) return; // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n\n    if (!event.url && !this._reportAnonymousScripts) return;\n\n    try {\n      const response = await this._client.send('Debugger.getScriptSource', {\n        scriptId: event.scriptId\n      });\n\n      this._scriptURLs.set(event.scriptId, event.url);\n\n      this._scriptSources.set(event.scriptId, response.scriptSource);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      helper_js_1.debugError(error);\n    }\n  }\n\n  async stop() {\n    assert_js_1.assert(this._enabled, 'JSCoverage is not enabled');\n    this._enabled = false;\n    const result = await Promise.all([this._client.send('Profiler.takePreciseCoverage'), this._client.send('Profiler.stopPreciseCoverage'), this._client.send('Profiler.disable'), this._client.send('Debugger.disable')]);\n    helper_js_1.helper.removeEventListeners(this._eventListeners);\n    const coverage = [];\n    const profileResponse = result[0];\n\n    for (const entry of profileResponse.result) {\n      let url = this._scriptURLs.get(entry.scriptId);\n\n      if (!url && this._reportAnonymousScripts) url = 'debugger://VM' + entry.scriptId;\n\n      const text = this._scriptSources.get(entry.scriptId);\n\n      if (text === undefined || url === undefined) continue;\n      const flattenRanges = [];\n\n      for (const func of entry.functions) flattenRanges.push(...func.ranges);\n\n      const ranges = convertToDisjointRanges(flattenRanges);\n      coverage.push({\n        url,\n        ranges,\n        text\n      });\n    }\n\n    return coverage;\n  }\n\n}\n\nclass CSSCoverage {\n  constructor(client) {\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n    this._reportAnonymousScripts = false;\n    this._client = client;\n  }\n\n  async start(options = {}) {\n    assert_js_1.assert(!this._enabled, 'CSSCoverage is already enabled');\n    const {\n      resetOnNavigation = true\n    } = options;\n    this._resetOnNavigation = resetOnNavigation;\n    this._enabled = true;\n\n    this._stylesheetURLs.clear();\n\n    this._stylesheetSources.clear();\n\n    this._eventListeners = [helper_js_1.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)), helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this))];\n    await Promise.all([this._client.send('DOM.enable'), this._client.send('CSS.enable'), this._client.send('CSS.startRuleUsageTracking')]);\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n\n    this._stylesheetURLs.clear();\n\n    this._stylesheetSources.clear();\n  }\n\n  async _onStyleSheet(event) {\n    const header = event.header; // Ignore anonymous scripts\n\n    if (!header.sourceURL) return;\n\n    try {\n      const response = await this._client.send('CSS.getStyleSheetText', {\n        styleSheetId: header.styleSheetId\n      });\n\n      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n\n      this._stylesheetSources.set(header.styleSheetId, response.text);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      helper_js_1.debugError(error);\n    }\n  }\n\n  async stop() {\n    assert_js_1.assert(this._enabled, 'CSSCoverage is not enabled');\n    this._enabled = false;\n    const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n    await Promise.all([this._client.send('CSS.disable'), this._client.send('DOM.disable')]);\n    helper_js_1.helper.removeEventListeners(this._eventListeners); // aggregate by styleSheetId\n\n    const styleSheetIdToCoverage = new Map();\n\n    for (const entry of ruleTrackingResponse.ruleUsage) {\n      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n\n      if (!ranges) {\n        ranges = [];\n        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n      }\n\n      ranges.push({\n        startOffset: entry.startOffset,\n        endOffset: entry.endOffset,\n        count: entry.used ? 1 : 0\n      });\n    }\n\n    const coverage = [];\n\n    for (const styleSheetId of this._stylesheetURLs.keys()) {\n      const url = this._stylesheetURLs.get(styleSheetId);\n\n      const text = this._stylesheetSources.get(styleSheetId);\n\n      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n      coverage.push({\n        url,\n        ranges,\n        text\n      });\n    }\n\n    return coverage;\n  }\n\n}\n\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n\n  for (const range of nestedRanges) {\n    points.push({\n      offset: range.startOffset,\n      type: 0,\n      range\n    });\n    points.push({\n      offset: range.endOffset,\n      type: 1,\n      range\n    });\n  } // Sort points to form a valid parenthesis sequence.\n\n\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) return a.offset - b.offset; // All \"end\" points should go before \"start\" points.\n\n    if (a.type !== b.type) return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset; // For two \"start\" points, the one with longer range goes first.\n\n    if (a.type === 0) return bLength - aLength; // For two \"end\" points, the one with shorter range goes first.\n\n    return aLength - bLength;\n  });\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0; // Run scanning line to intersect all ranges.\n\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset) lastResult.end = point.offset;else results.push({\n        start: lastOffset,\n        end: point.offset\n      });\n    }\n\n    lastOffset = point.offset;\n    if (point.type === 0) hitCountStack.push(point.range.count);else hitCountStack.pop();\n  } // Filter out empty ranges.\n\n\n  return results.filter(range => range.end - range.start > 1);\n}","map":{"version":3,"sources":["../../../../src/common/Coverage.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Coverage = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n/**\n * The Coverage class provides methods to gathers information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n * ```js\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage()\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges)\n *     usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);\n * ```\n * @public\n */\nclass Coverage {\n    constructor(client) {\n        this._jsCoverage = new JSCoverage(client);\n        this._cssCoverage = new CSSCoverage(client);\n    }\n    /**\n     * @param options - defaults to\n     * `{ resetOnNavigation : true, reportAnonymousScripts : false }`\n     * @returns Promise that resolves when coverage is started.\n     *\n     * @remarks\n     * Anonymous scripts are ones that don't have an associated url. These are\n     * scripts that are dynamically created on the page using `eval` or\n     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n     * scripts will have `__puppeteer_evaluation_script__` as their URL.\n     */\n    async startJSCoverage(options = {}) {\n        return await this._jsCoverage.start(options);\n    }\n    /**\n     * @returns Promise that resolves to the array of coverage reports for\n     * all scripts.\n     *\n     * @remarks\n     * JavaScript Coverage doesn't include anonymous scripts by default.\n     * However, scripts with sourceURLs are reported.\n     */\n    async stopJSCoverage() {\n        return await this._jsCoverage.stop();\n    }\n    /**\n     * @param options - defaults to `{ resetOnNavigation : true }`\n     * @returns Promise that resolves when coverage is started.\n     */\n    async startCSSCoverage(options = {}) {\n        return await this._cssCoverage.start(options);\n    }\n    /**\n     * @returns Promise that resolves to the array of coverage reports\n     * for all stylesheets.\n     * @remarks\n     * CSS Coverage doesn't include dynamically injected style tags\n     * without sourceURLs.\n     */\n    async stopCSSCoverage() {\n        return await this._cssCoverage.stop();\n    }\n}\nexports.Coverage = Coverage;\nclass JSCoverage {\n    constructor(client) {\n        this._enabled = false;\n        this._scriptURLs = new Map();\n        this._scriptSources = new Map();\n        this._eventListeners = [];\n        this._resetOnNavigation = false;\n        this._reportAnonymousScripts = false;\n        this._client = client;\n    }\n    async start(options = {}) {\n        assert_js_1.assert(!this._enabled, 'JSCoverage is already enabled');\n        const { resetOnNavigation = true, reportAnonymousScripts = false, } = options;\n        this._resetOnNavigation = resetOnNavigation;\n        this._reportAnonymousScripts = reportAnonymousScripts;\n        this._enabled = true;\n        this._scriptURLs.clear();\n        this._scriptSources.clear();\n        this._eventListeners = [\n            helper_js_1.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),\n            helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n        ];\n        await Promise.all([\n            this._client.send('Profiler.enable'),\n            this._client.send('Profiler.startPreciseCoverage', {\n                callCount: false,\n                detailed: true,\n            }),\n            this._client.send('Debugger.enable'),\n            this._client.send('Debugger.setSkipAllPauses', { skip: true }),\n        ]);\n    }\n    _onExecutionContextsCleared() {\n        if (!this._resetOnNavigation)\n            return;\n        this._scriptURLs.clear();\n        this._scriptSources.clear();\n    }\n    async _onScriptParsed(event) {\n        // Ignore puppeteer-injected scripts\n        if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL)\n            return;\n        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n        if (!event.url && !this._reportAnonymousScripts)\n            return;\n        try {\n            const response = await this._client.send('Debugger.getScriptSource', {\n                scriptId: event.scriptId,\n            });\n            this._scriptURLs.set(event.scriptId, event.url);\n            this._scriptSources.set(event.scriptId, response.scriptSource);\n        }\n        catch (error) {\n            // This might happen if the page has already navigated away.\n            helper_js_1.debugError(error);\n        }\n    }\n    async stop() {\n        assert_js_1.assert(this._enabled, 'JSCoverage is not enabled');\n        this._enabled = false;\n        const result = await Promise.all([\n            this._client.send('Profiler.takePreciseCoverage'),\n            this._client.send('Profiler.stopPreciseCoverage'),\n            this._client.send('Profiler.disable'),\n            this._client.send('Debugger.disable'),\n        ]);\n        helper_js_1.helper.removeEventListeners(this._eventListeners);\n        const coverage = [];\n        const profileResponse = result[0];\n        for (const entry of profileResponse.result) {\n            let url = this._scriptURLs.get(entry.scriptId);\n            if (!url && this._reportAnonymousScripts)\n                url = 'debugger://VM' + entry.scriptId;\n            const text = this._scriptSources.get(entry.scriptId);\n            if (text === undefined || url === undefined)\n                continue;\n            const flattenRanges = [];\n            for (const func of entry.functions)\n                flattenRanges.push(...func.ranges);\n            const ranges = convertToDisjointRanges(flattenRanges);\n            coverage.push({ url, ranges, text });\n        }\n        return coverage;\n    }\n}\nclass CSSCoverage {\n    constructor(client) {\n        this._enabled = false;\n        this._stylesheetURLs = new Map();\n        this._stylesheetSources = new Map();\n        this._eventListeners = [];\n        this._resetOnNavigation = false;\n        this._reportAnonymousScripts = false;\n        this._client = client;\n    }\n    async start(options = {}) {\n        assert_js_1.assert(!this._enabled, 'CSSCoverage is already enabled');\n        const { resetOnNavigation = true } = options;\n        this._resetOnNavigation = resetOnNavigation;\n        this._enabled = true;\n        this._stylesheetURLs.clear();\n        this._stylesheetSources.clear();\n        this._eventListeners = [\n            helper_js_1.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),\n            helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n        ];\n        await Promise.all([\n            this._client.send('DOM.enable'),\n            this._client.send('CSS.enable'),\n            this._client.send('CSS.startRuleUsageTracking'),\n        ]);\n    }\n    _onExecutionContextsCleared() {\n        if (!this._resetOnNavigation)\n            return;\n        this._stylesheetURLs.clear();\n        this._stylesheetSources.clear();\n    }\n    async _onStyleSheet(event) {\n        const header = event.header;\n        // Ignore anonymous scripts\n        if (!header.sourceURL)\n            return;\n        try {\n            const response = await this._client.send('CSS.getStyleSheetText', {\n                styleSheetId: header.styleSheetId,\n            });\n            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n            this._stylesheetSources.set(header.styleSheetId, response.text);\n        }\n        catch (error) {\n            // This might happen if the page has already navigated away.\n            helper_js_1.debugError(error);\n        }\n    }\n    async stop() {\n        assert_js_1.assert(this._enabled, 'CSSCoverage is not enabled');\n        this._enabled = false;\n        const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n        await Promise.all([\n            this._client.send('CSS.disable'),\n            this._client.send('DOM.disable'),\n        ]);\n        helper_js_1.helper.removeEventListeners(this._eventListeners);\n        // aggregate by styleSheetId\n        const styleSheetIdToCoverage = new Map();\n        for (const entry of ruleTrackingResponse.ruleUsage) {\n            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n            if (!ranges) {\n                ranges = [];\n                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n            }\n            ranges.push({\n                startOffset: entry.startOffset,\n                endOffset: entry.endOffset,\n                count: entry.used ? 1 : 0,\n            });\n        }\n        const coverage = [];\n        for (const styleSheetId of this._stylesheetURLs.keys()) {\n            const url = this._stylesheetURLs.get(styleSheetId);\n            const text = this._stylesheetSources.get(styleSheetId);\n            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n            coverage.push({ url, ranges, text });\n        }\n        return coverage;\n    }\n}\nfunction convertToDisjointRanges(nestedRanges) {\n    const points = [];\n    for (const range of nestedRanges) {\n        points.push({ offset: range.startOffset, type: 0, range });\n        points.push({ offset: range.endOffset, type: 1, range });\n    }\n    // Sort points to form a valid parenthesis sequence.\n    points.sort((a, b) => {\n        // Sort with increasing offsets.\n        if (a.offset !== b.offset)\n            return a.offset - b.offset;\n        // All \"end\" points should go before \"start\" points.\n        if (a.type !== b.type)\n            return b.type - a.type;\n        const aLength = a.range.endOffset - a.range.startOffset;\n        const bLength = b.range.endOffset - b.range.startOffset;\n        // For two \"start\" points, the one with longer range goes first.\n        if (a.type === 0)\n            return bLength - aLength;\n        // For two \"end\" points, the one with shorter range goes first.\n        return aLength - bLength;\n    });\n    const hitCountStack = [];\n    const results = [];\n    let lastOffset = 0;\n    // Run scanning line to intersect all ranges.\n    for (const point of points) {\n        if (hitCountStack.length &&\n            lastOffset < point.offset &&\n            hitCountStack[hitCountStack.length - 1] > 0) {\n            const lastResult = results.length ? results[results.length - 1] : null;\n            if (lastResult && lastResult.end === lastOffset)\n                lastResult.end = point.offset;\n            else\n                results.push({ start: lastOffset, end: point.offset });\n        }\n        lastOffset = point.offset;\n        if (point.type === 0)\n            hitCountStack.push(point.range.count);\n        else\n            hitCountStack.pop();\n    }\n    // Filter out empty ranges.\n    return results.filter((range) => range.end - range.start > 1);\n}\n//# sourceMappingURL=Coverage.js.map"]},"metadata":{},"sourceType":"script"}