{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebWorker = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n/**\n * The WebWorker class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n * ```js\n * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));\n * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\n\n\nclass WebWorker extends EventEmitter_js_1.EventEmitter {\n  /**\n   *\n   * @internal\n   */\n  constructor(client, url, consoleAPICalled, exceptionThrown) {\n    super();\n    this._client = client;\n    this._url = url;\n    this._executionContextPromise = new Promise(x => this._executionContextCallback = x);\n    let jsHandleFactory;\n\n    this._client.once('Runtime.executionContextCreated', async event => {\n      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n      jsHandleFactory = remoteObject => new JSHandle_js_1.JSHandle(executionContext, client, remoteObject);\n\n      const executionContext = new ExecutionContext_js_1.ExecutionContext(client, event.context, null);\n\n      this._executionContextCallback(executionContext);\n    }); // This might fail if the target is closed before we recieve all execution contexts.\n\n\n    this._client.send('Runtime.enable').catch(helper_js_1.debugError);\n\n    this._client.on('Runtime.consoleAPICalled', event => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));\n\n    this._client.on('Runtime.exceptionThrown', exception => exceptionThrown(exception.exceptionDetails));\n  }\n  /**\n   * @returns The URL of this web worker.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * Returns the ExecutionContext the WebWorker runs in\n   * @returns The ExecutionContext the web worker runs in.\n   */\n\n\n  async executionContext() {\n    return this._executionContextPromise;\n  }\n  /**\n   * If the function passed to the `worker.evaluate` returns a Promise, then\n   * `worker.evaluate` would wait for the promise to resolve and return its\n   * value. If the function passed to the `worker.evaluate` returns a\n   * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n   * DevTools Protocol also supports transferring some additional values that\n   * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n   * bigint literals.\n   * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n   *\n   * @param pageFunction - Function to be evaluated in the worker context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    return (await this._executionContextPromise).evaluate(pageFunction, ...args);\n  }\n  /**\n   * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n   * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n   * function passed to the `worker.evaluateHandle` returns a [Promise], then\n   * `worker.evaluateHandle` would wait for the promise to resolve and return\n   * its value. Shortcut for\n   * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n   *\n   * @param pageFunction - Function to be evaluated in the page context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);\n  }\n\n}\n\nexports.WebWorker = WebWorker;","map":{"version":3,"sources":["../../../../src/common/WebWorker.ts"],"names":[],"mappings":";;;;;;AAAA;;;;;;;;;;;;;;AAcG;;AACH,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAsBA;;;;;;;;;;;;;;;;;;;;AAoBG;;;AACH,MAAa,SAAb,SAA+B,iBAAA,CAAA,YAA/B,CAA2C;AAMzC;;;AAGG;AACH,EAAA,WAAA,CACE,MADF,EAEE,GAFF,EAGE,gBAHF,EAIE,eAJF,EAI0C;AAExC;AACA,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,IAAL,GAAY,GAAZ;AACA,SAAK,wBAAL,GAAgC,IAAI,OAAJ,CAC7B,CAAD,IAAQ,KAAK,yBAAL,GAAiC,CADX,CAAhC;AAIA,QAAI,eAAJ;;AACA,SAAK,OAAL,CAAa,IAAb,CAAkB,iCAAlB,EAAqD,MAAO,KAAP,IAAgB;AACnE;AACA,MAAA,eAAe,GAAI,YAAD,IAChB,IAAI,aAAA,CAAA,QAAJ,CAAa,gBAAb,EAA+B,MAA/B,EAAuC,YAAvC,CADF;;AAEA,YAAM,gBAAgB,GAAG,IAAI,qBAAA,CAAA,gBAAJ,CACvB,MADuB,EAEvB,KAAK,CAAC,OAFiB,EAGvB,IAHuB,CAAzB;;AAKA,WAAK,yBAAL,CAA+B,gBAA/B;AACD,KAVD,EAVwC,CAsBxC;;;AACA,SAAK,OAAL,CAAa,IAAb,CAAkB,gBAAlB,EAAoC,KAApC,CAA0C,WAAA,CAAA,UAA1C;;AACA,SAAK,OAAL,CAAa,EAAb,CAAgB,0BAAhB,EAA6C,KAAD,IAC1C,gBAAgB,CACd,KAAK,CAAC,IADQ,EAEd,KAAK,CAAC,IAAN,CAAW,GAAX,CAAe,eAAf,CAFc,EAGd,KAAK,CAAC,UAHQ,CADlB;;AAOA,SAAK,OAAL,CAAa,EAAb,CAAgB,yBAAhB,EAA4C,SAAD,IACzC,eAAe,CAAC,SAAS,CAAC,gBAAX,CADjB;AAGD;AAED;;AAEG;;;AACH,EAAA,GAAG,GAAA;AACD,WAAO,KAAK,IAAZ;AACD;AAED;;;AAGG;;;AACmB,QAAhB,gBAAgB,GAAA;AACpB,WAAO,KAAK,wBAAZ;AACD;AAED;;;;;;;;;;;;;AAaG;;;AACW,QAAR,QAAQ,CACZ,YADY,EAEZ,GAAG,IAFS,EAEE;AAEd,WAAO,CAAC,MAAM,KAAK,wBAAZ,EAAsC,QAAtC,CACL,YADK,EAEL,GAAG,IAFE,CAAP;AAID;AAED;;;;;;;;;;;AAWG;;;AACiB,QAAd,cAAc,CAClB,YADkB,EAElB,GAAG,IAFe,EAEe;AAEjC,WAAO,CAAC,MAAM,KAAK,wBAAZ,EAAsC,cAAtC,CACL,YADK,EAEL,GAAG,IAFE,CAAP;AAID;;AA7GwC;;AAA3C,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebWorker = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n/**\n * The WebWorker class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n * ```js\n * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));\n * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nclass WebWorker extends EventEmitter_js_1.EventEmitter {\n    /**\n     *\n     * @internal\n     */\n    constructor(client, url, consoleAPICalled, exceptionThrown) {\n        super();\n        this._client = client;\n        this._url = url;\n        this._executionContextPromise = new Promise((x) => (this._executionContextCallback = x));\n        let jsHandleFactory;\n        this._client.once('Runtime.executionContextCreated', async (event) => {\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            jsHandleFactory = (remoteObject) => new JSHandle_js_1.JSHandle(executionContext, client, remoteObject);\n            const executionContext = new ExecutionContext_js_1.ExecutionContext(client, event.context, null);\n            this._executionContextCallback(executionContext);\n        });\n        // This might fail if the target is closed before we recieve all execution contexts.\n        this._client.send('Runtime.enable').catch(helper_js_1.debugError);\n        this._client.on('Runtime.consoleAPICalled', (event) => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));\n        this._client.on('Runtime.exceptionThrown', (exception) => exceptionThrown(exception.exceptionDetails));\n    }\n    /**\n     * @returns The URL of this web worker.\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * Returns the ExecutionContext the WebWorker runs in\n     * @returns The ExecutionContext the web worker runs in.\n     */\n    async executionContext() {\n        return this._executionContextPromise;\n    }\n    /**\n     * If the function passed to the `worker.evaluate` returns a Promise, then\n     * `worker.evaluate` would wait for the promise to resolve and return its\n     * value. If the function passed to the `worker.evaluate` returns a\n     * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n     * DevTools Protocol also supports transferring some additional values that\n     * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n     * bigint literals.\n     * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n     *\n     * @param pageFunction - Function to be evaluated in the worker context.\n     * @param args - Arguments to pass to `pageFunction`.\n     * @returns Promise which resolves to the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction, ...args) {\n        return (await this._executionContextPromise).evaluate(pageFunction, ...args);\n    }\n    /**\n     * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n     * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n     * function passed to the `worker.evaluateHandle` returns a [Promise], then\n     * `worker.evaluateHandle` would wait for the promise to resolve and return\n     * its value. Shortcut for\n     * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n     *\n     * @param pageFunction - Function to be evaluated in the page context.\n     * @param args - Arguments to pass to `pageFunction`.\n     * @returns Promise which resolves to the return value of `pageFunction`.\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);\n    }\n}\nexports.WebWorker = WebWorker;\n//# sourceMappingURL=WebWorker.js.map"]},"metadata":{},"sourceType":"script"}