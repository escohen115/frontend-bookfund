{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BrowserContext = exports.Browser = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst Target_js_1 = require(\"./Target.js\");\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst Connection_js_1 = require(\"./Connection.js\");\n/**\n * A Browser is created when Puppeteer connects to a Chromium instance, either through\n * {@link PuppeteerNode.launch} or {@link Puppeteer.connect}.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link BrowserEmittedEvents} enum.\n *\n * @example\n *\n * An example of using a {@link Browser} to create a {@link Page}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await browser.close();\n * })();\n * ```\n *\n * @example\n *\n * An example of disconnecting from and reconnecting to a {@link Browser}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   // Store the endpoint to be able to reconnect to Chromium\n *   const browserWSEndpoint = browser.wsEndpoint();\n *   // Disconnect puppeteer from Chromium\n *   browser.disconnect();\n *\n *   // Use the endpoint to reestablish a connection\n *   const browser2 = await puppeteer.connect({browserWSEndpoint});\n *   // Close Chromium\n *   await browser2.close();\n * })();\n * ```\n *\n * @public\n */\n\n\nclass Browser extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n    super();\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._defaultViewport = defaultViewport;\n    this._process = process;\n    this._connection = connection;\n\n    this._closeCallback = closeCallback || function () {};\n\n    this._defaultContext = new BrowserContext(this._connection, this, null);\n    this._contexts = new Map();\n\n    for (const contextId of contextIds) this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));\n\n    this._targets = new Map();\n\n    this._connection.on(Connection_js_1.ConnectionEmittedEvents.Disconnected, () => this.emit(\"disconnected\"\n    /* Disconnected */\n    ));\n\n    this._connection.on('Target.targetCreated', this._targetCreated.bind(this));\n\n    this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));\n\n    this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));\n  }\n  /**\n   * @internal\n   */\n\n\n  static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n    const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);\n    await connection.send('Target.setDiscoverTargets', {\n      discover: true\n    });\n    return browser;\n  }\n  /**\n   * The spawned browser process. Returns `null` if the browser instance was created with\n   * {@link Puppeteer.connect}.\n   */\n\n\n  process() {\n    return this._process;\n  }\n  /**\n   * Creates a new incognito browser context. This won't share cookies/cache with other\n   * browser contexts.\n   *\n   * @example\n   * ```js\n   * (async () => {\n   *  const browser = await puppeteer.launch();\n   *   // Create a new incognito browser context.\n   *   const context = await browser.createIncognitoBrowserContext();\n   *   // Create a new page in a pristine context.\n   *   const page = await context.newPage();\n   *   // Do stuff\n   *   await page.goto('https://example.com');\n   * })();\n   * ```\n   */\n\n\n  async createIncognitoBrowserContext() {\n    const {\n      browserContextId\n    } = await this._connection.send('Target.createBrowserContext');\n    const context = new BrowserContext(this._connection, this, browserContextId);\n\n    this._contexts.set(browserContextId, context);\n\n    return context;\n  }\n  /**\n   * Returns an array of all open browser contexts. In a newly created browser, this will\n   * return a single instance of {@link BrowserContext}.\n   */\n\n\n  browserContexts() {\n    return [this._defaultContext, ...Array.from(this._contexts.values())];\n  }\n  /**\n   * Returns the default browser context. The default browser context cannot be closed.\n   */\n\n\n  defaultBrowserContext() {\n    return this._defaultContext;\n  }\n  /**\n   * @internal\n   * Used by BrowserContext directly so cannot be marked private.\n   */\n\n\n  async _disposeContext(contextId) {\n    await this._connection.send('Target.disposeBrowserContext', {\n      browserContextId: contextId || undefined\n    });\n\n    this._contexts.delete(contextId);\n  }\n\n  async _targetCreated(event) {\n    const targetInfo = event.targetInfo;\n    const {\n      browserContextId\n    } = targetInfo;\n    const context = browserContextId && this._contexts.has(browserContextId) ? this._contexts.get(browserContextId) : this._defaultContext;\n    const target = new Target_js_1.Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport);\n    assert_js_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');\n\n    this._targets.set(event.targetInfo.targetId, target);\n\n    if (await target._initializedPromise) {\n      this.emit(\"targetcreated\"\n      /* TargetCreated */\n      , target);\n      context.emit(\"targetcreated\"\n      /* TargetCreated */\n      , target);\n    }\n  }\n\n  async _targetDestroyed(event) {\n    const target = this._targets.get(event.targetId);\n\n    target._initializedCallback(false);\n\n    this._targets.delete(event.targetId);\n\n    target._closedCallback();\n\n    if (await target._initializedPromise) {\n      this.emit(\"targetdestroyed\"\n      /* TargetDestroyed */\n      , target);\n      target.browserContext().emit(\"targetdestroyed\"\n      /* TargetDestroyed */\n      , target);\n    }\n  }\n\n  _targetInfoChanged(event) {\n    const target = this._targets.get(event.targetInfo.targetId);\n\n    assert_js_1.assert(target, 'target should exist before targetInfoChanged');\n    const previousURL = target.url();\n    const wasInitialized = target._isInitialized;\n\n    target._targetInfoChanged(event.targetInfo);\n\n    if (wasInitialized && previousURL !== target.url()) {\n      this.emit(\"targetchanged\"\n      /* TargetChanged */\n      , target);\n      target.browserContext().emit(\"targetchanged\"\n      /* TargetChanged */\n      , target);\n    }\n  }\n  /**\n   * The browser websocket endpoint which can be used as an argument to\n   * {@link Puppeteer.connect}.\n   *\n   * @returns The Browser websocket url.\n   *\n   * @remarks\n   *\n   * The format is `ws://${host}:${port}/devtools/browser/<id>`.\n   *\n   * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.\n   * Learn more about the\n   * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and\n   * the {@link\n   * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n   * | browser endpoint}.\n   */\n\n\n  wsEndpoint() {\n    return this._connection.url();\n  }\n  /**\n   * Creates a {@link Page} in the default browser context.\n   */\n\n\n  async newPage() {\n    return this._defaultContext.newPage();\n  }\n  /**\n   * @internal\n   * Used by BrowserContext directly so cannot be marked private.\n   */\n\n\n  async _createPageInContext(contextId) {\n    const {\n      targetId\n    } = await this._connection.send('Target.createTarget', {\n      url: 'about:blank',\n      browserContextId: contextId || undefined\n    });\n    const target = await this._targets.get(targetId);\n    assert_js_1.assert(await target._initializedPromise, 'Failed to create target for page');\n    const page = await target.page();\n    return page;\n  }\n  /**\n   * All active targets inside the Browser. In case of multiple browser contexts, returns\n   * an array with all the targets in all browser contexts.\n   */\n\n\n  targets() {\n    return Array.from(this._targets.values()).filter(target => target._isInitialized);\n  }\n  /**\n   * The target associated with the browser.\n   */\n\n\n  target() {\n    return this.targets().find(target => target.type() === 'browser');\n  }\n  /**\n   * Searches for a target in all browser contexts.\n   *\n   * @param predicate - A function to be run for every target.\n   * @returns The first target found that matches the `predicate` function.\n   *\n   * @example\n   *\n   * An example of finding a target for a page opened via `window.open`:\n   * ```js\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');\n   * ```\n   */\n\n\n  async waitForTarget(predicate, options = {}) {\n    const {\n      timeout = 30000\n    } = options;\n    const existingTarget = this.targets().find(predicate);\n    if (existingTarget) return existingTarget;\n    let resolve;\n    const targetPromise = new Promise(x => resolve = x);\n    this.on(\"targetcreated\"\n    /* TargetCreated */\n    , check);\n    this.on(\"targetchanged\"\n    /* TargetChanged */\n    , check);\n\n    try {\n      if (!timeout) return await targetPromise;\n      return await helper_js_1.helper.waitWithTimeout(targetPromise, 'target', timeout);\n    } finally {\n      this.removeListener(\"targetcreated\"\n      /* TargetCreated */\n      , check);\n      this.removeListener(\"targetchanged\"\n      /* TargetChanged */\n      , check);\n    }\n\n    function check(target) {\n      if (predicate(target)) resolve(target);\n    }\n  }\n  /**\n   * An array of all open pages inside the Browser.\n   *\n   * @remarks\n   *\n   * In case of multiple browser contexts, returns an array with all the pages in all\n   * browser contexts. Non-visible pages, such as `\"background_page\"`, will not be listed\n   * here. You can find them using {@link Target.page}.\n   */\n\n\n  async pages() {\n    const contextPages = await Promise.all(this.browserContexts().map(context => context.pages())); // Flatten array.\n\n    return contextPages.reduce((acc, x) => acc.concat(x), []);\n  }\n  /**\n   * A string representing the browser name and version.\n   *\n   * @remarks\n   *\n   * For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For\n   * non-headless, this is similar to `Chrome/61.0.3153.0`.\n   *\n   * The format of browser.version() might change with future releases of Chromium.\n   */\n\n\n  async version() {\n    const version = await this._getVersion();\n    return version.product;\n  }\n  /**\n   * The browser's original user agent. Pages can override the browser user agent with\n   * {@link Page.setUserAgent}.\n   */\n\n\n  async userAgent() {\n    const version = await this._getVersion();\n    return version.userAgent;\n  }\n  /**\n   * Closes Chromium and all of its pages (if any were opened). The {@link Browser} object\n   * itself is considered to be disposed and cannot be used anymore.\n   */\n\n\n  async close() {\n    await this._closeCallback.call(null);\n    this.disconnect();\n  }\n  /**\n   * Disconnects Puppeteer from the browser, but leaves the Chromium process running.\n   * After calling `disconnect`, the {@link Browser} object is considered disposed and\n   * cannot be used anymore.\n   */\n\n\n  disconnect() {\n    this._connection.dispose();\n  }\n  /**\n   * Indicates that the browser is connected.\n   */\n\n\n  isConnected() {\n    return !this._connection._closed;\n  }\n\n  _getVersion() {\n    return this._connection.send('Browser.getVersion');\n  }\n\n}\n\nexports.Browser = Browser;\n/**\n * BrowserContexts provide a way to operate multiple independent browser\n * sessions. When a browser is launched, it has a single BrowserContext used by\n * default. The method {@link Browser.newPage | Browser.newPage} creates a page\n * in the default browser context.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and\n * will emit various events which are documented in the\n * {@link BrowserContextEmittedEvents} enum.\n *\n * If a page opens another page, e.g. with a `window.open` call, the popup will\n * belong to the parent page's browser context.\n *\n * Puppeteer allows creation of \"incognito\" browser contexts with\n * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}\n * method. \"Incognito\" browser contexts don't write any browsing data to disk.\n *\n * @example\n * ```js\n * // Create a new incognito browser context\n * const context = await browser.createIncognitoBrowserContext();\n * // Create a new page inside context.\n * const page = await context.newPage();\n * // ... do stuff with page ...\n * await page.goto('https://example.com');\n * // Dispose context once it's no longer needed.\n * await context.close();\n * ```\n */\n\nclass BrowserContext extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor(connection, browser, contextId) {\n    super();\n    this._connection = connection;\n    this._browser = browser;\n    this._id = contextId;\n  }\n  /**\n   * An array of all active targets inside the browser context.\n   */\n\n\n  targets() {\n    return this._browser.targets().filter(target => target.browserContext() === this);\n  }\n  /**\n   * This searches for a target in this specific browser context.\n   *\n   * @example\n   * An example of finding a target for a page opened via `window.open`:\n   * ```js\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');\n   * ```\n   *\n   * @param predicate - A function to be run for every target\n   * @param options - An object of options. Accepts a timout,\n   * which is the maximum wait time in milliseconds.\n   * Pass `0` to disable the timeout. Defaults to 30 seconds.\n   * @returns Promise which resolves to the first target found\n   * that matches the `predicate` function.\n   */\n\n\n  waitForTarget(predicate, options = {}) {\n    return this._browser.waitForTarget(target => target.browserContext() === this && predicate(target), options);\n  }\n  /**\n   * An array of all pages inside the browser context.\n   *\n   * @returns Promise which resolves to an array of all open pages.\n   * Non visible pages, such as `\"background_page\"`, will not be listed here.\n   * You can find them using {@link Target.page | the target page}.\n   */\n\n\n  async pages() {\n    const pages = await Promise.all(this.targets().filter(target => target.type() === 'page').map(target => target.page()));\n    return pages.filter(page => !!page);\n  }\n  /**\n   * Returns whether BrowserContext is incognito.\n   * The default browser context is the only non-incognito browser context.\n   *\n   * @remarks\n   * The default browser context cannot be closed.\n   */\n\n\n  isIncognito() {\n    return !!this._id;\n  }\n  /**\n   * @example\n   * ```js\n   * const context = browser.defaultBrowserContext();\n   * await context.overridePermissions('https://html5demos.com', ['geolocation']);\n   * ```\n   *\n   * @param origin - The origin to grant permissions to, e.g. \"https://example.com\".\n   * @param permissions - An array of permissions to grant.\n   * All permissions that are not listed here will be automatically denied.\n   */\n\n\n  async overridePermissions(origin, permissions) {\n    const webPermissionToProtocol = new Map([['geolocation', 'geolocation'], ['midi', 'midi'], ['notifications', 'notifications'], // TODO: push isn't a valid type?\n    // ['push', 'push'],\n    ['camera', 'videoCapture'], ['microphone', 'audioCapture'], ['background-sync', 'backgroundSync'], ['ambient-light-sensor', 'sensors'], ['accelerometer', 'sensors'], ['gyroscope', 'sensors'], ['magnetometer', 'sensors'], ['accessibility-events', 'accessibilityEvents'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-write', 'clipboardReadWrite'], ['payment-handler', 'paymentHandler'], ['idle-detection', 'idleDetection'], // chrome-specific permissions we have.\n    ['midi-sysex', 'midiSysex']]);\n    const protocolPermissions = permissions.map(permission => {\n      const protocolPermission = webPermissionToProtocol.get(permission);\n      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);\n      return protocolPermission;\n    });\n    await this._connection.send('Browser.grantPermissions', {\n      origin,\n      browserContextId: this._id || undefined,\n      permissions: protocolPermissions\n    });\n  }\n  /**\n   * Clears all permission overrides for the browser context.\n   *\n   * @example\n   * ```js\n   * const context = browser.defaultBrowserContext();\n   * context.overridePermissions('https://example.com', ['clipboard-read']);\n   * // do stuff ..\n   * context.clearPermissionOverrides();\n   * ```\n   */\n\n\n  async clearPermissionOverrides() {\n    await this._connection.send('Browser.resetPermissions', {\n      browserContextId: this._id || undefined\n    });\n  }\n  /**\n   * Creates a new page in the browser context.\n   */\n\n\n  newPage() {\n    return this._browser._createPageInContext(this._id);\n  }\n  /**\n   * The browser this browser context belongs to.\n   */\n\n\n  browser() {\n    return this._browser;\n  }\n  /**\n   * Closes the browser context. All the targets that belong to the browser context\n   * will be closed.\n   *\n   * @remarks\n   * Only incognito browser contexts can be closed.\n   */\n\n\n  async close() {\n    assert_js_1.assert(this._id, 'Non-incognito profiles cannot be closed!');\n    await this._browser._disposeContext(this._id);\n  }\n\n}\n\nexports.BrowserContext = BrowserContext;","map":{"version":3,"sources":["../../../../src/common/Browser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BrowserContext = exports.Browser = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst Target_js_1 = require(\"./Target.js\");\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst Connection_js_1 = require(\"./Connection.js\");\n/**\n * A Browser is created when Puppeteer connects to a Chromium instance, either through\n * {@link PuppeteerNode.launch} or {@link Puppeteer.connect}.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link BrowserEmittedEvents} enum.\n *\n * @example\n *\n * An example of using a {@link Browser} to create a {@link Page}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await browser.close();\n * })();\n * ```\n *\n * @example\n *\n * An example of disconnecting from and reconnecting to a {@link Browser}:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   // Store the endpoint to be able to reconnect to Chromium\n *   const browserWSEndpoint = browser.wsEndpoint();\n *   // Disconnect puppeteer from Chromium\n *   browser.disconnect();\n *\n *   // Use the endpoint to reestablish a connection\n *   const browser2 = await puppeteer.connect({browserWSEndpoint});\n *   // Close Chromium\n *   await browser2.close();\n * })();\n * ```\n *\n * @public\n */\nclass Browser extends EventEmitter_js_1.EventEmitter {\n    /**\n     * @internal\n     */\n    constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n        super();\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._defaultViewport = defaultViewport;\n        this._process = process;\n        this._connection = connection;\n        this._closeCallback = closeCallback || function () { };\n        this._defaultContext = new BrowserContext(this._connection, this, null);\n        this._contexts = new Map();\n        for (const contextId of contextIds)\n            this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));\n        this._targets = new Map();\n        this._connection.on(Connection_js_1.ConnectionEmittedEvents.Disconnected, () => this.emit(\"disconnected\" /* Disconnected */));\n        this._connection.on('Target.targetCreated', this._targetCreated.bind(this));\n        this._connection.on('Target.targetDestroyed', this._targetDestroyed.bind(this));\n        this._connection.on('Target.targetInfoChanged', this._targetInfoChanged.bind(this));\n    }\n    /**\n     * @internal\n     */\n    static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback) {\n        const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback);\n        await connection.send('Target.setDiscoverTargets', { discover: true });\n        return browser;\n    }\n    /**\n     * The spawned browser process. Returns `null` if the browser instance was created with\n     * {@link Puppeteer.connect}.\n     */\n    process() {\n        return this._process;\n    }\n    /**\n     * Creates a new incognito browser context. This won't share cookies/cache with other\n     * browser contexts.\n     *\n     * @example\n     * ```js\n     * (async () => {\n     *  const browser = await puppeteer.launch();\n     *   // Create a new incognito browser context.\n     *   const context = await browser.createIncognitoBrowserContext();\n     *   // Create a new page in a pristine context.\n     *   const page = await context.newPage();\n     *   // Do stuff\n     *   await page.goto('https://example.com');\n     * })();\n     * ```\n     */\n    async createIncognitoBrowserContext() {\n        const { browserContextId } = await this._connection.send('Target.createBrowserContext');\n        const context = new BrowserContext(this._connection, this, browserContextId);\n        this._contexts.set(browserContextId, context);\n        return context;\n    }\n    /**\n     * Returns an array of all open browser contexts. In a newly created browser, this will\n     * return a single instance of {@link BrowserContext}.\n     */\n    browserContexts() {\n        return [this._defaultContext, ...Array.from(this._contexts.values())];\n    }\n    /**\n     * Returns the default browser context. The default browser context cannot be closed.\n     */\n    defaultBrowserContext() {\n        return this._defaultContext;\n    }\n    /**\n     * @internal\n     * Used by BrowserContext directly so cannot be marked private.\n     */\n    async _disposeContext(contextId) {\n        await this._connection.send('Target.disposeBrowserContext', {\n            browserContextId: contextId || undefined,\n        });\n        this._contexts.delete(contextId);\n    }\n    async _targetCreated(event) {\n        const targetInfo = event.targetInfo;\n        const { browserContextId } = targetInfo;\n        const context = browserContextId && this._contexts.has(browserContextId)\n            ? this._contexts.get(browserContextId)\n            : this._defaultContext;\n        const target = new Target_js_1.Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport);\n        assert_js_1.assert(!this._targets.has(event.targetInfo.targetId), 'Target should not exist before targetCreated');\n        this._targets.set(event.targetInfo.targetId, target);\n        if (await target._initializedPromise) {\n            this.emit(\"targetcreated\" /* TargetCreated */, target);\n            context.emit(\"targetcreated\" /* TargetCreated */, target);\n        }\n    }\n    async _targetDestroyed(event) {\n        const target = this._targets.get(event.targetId);\n        target._initializedCallback(false);\n        this._targets.delete(event.targetId);\n        target._closedCallback();\n        if (await target._initializedPromise) {\n            this.emit(\"targetdestroyed\" /* TargetDestroyed */, target);\n            target\n                .browserContext()\n                .emit(\"targetdestroyed\" /* TargetDestroyed */, target);\n        }\n    }\n    _targetInfoChanged(event) {\n        const target = this._targets.get(event.targetInfo.targetId);\n        assert_js_1.assert(target, 'target should exist before targetInfoChanged');\n        const previousURL = target.url();\n        const wasInitialized = target._isInitialized;\n        target._targetInfoChanged(event.targetInfo);\n        if (wasInitialized && previousURL !== target.url()) {\n            this.emit(\"targetchanged\" /* TargetChanged */, target);\n            target\n                .browserContext()\n                .emit(\"targetchanged\" /* TargetChanged */, target);\n        }\n    }\n    /**\n     * The browser websocket endpoint which can be used as an argument to\n     * {@link Puppeteer.connect}.\n     *\n     * @returns The Browser websocket url.\n     *\n     * @remarks\n     *\n     * The format is `ws://${host}:${port}/devtools/browser/<id>`.\n     *\n     * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.\n     * Learn more about the\n     * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and\n     * the {@link\n     * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n     * | browser endpoint}.\n     */\n    wsEndpoint() {\n        return this._connection.url();\n    }\n    /**\n     * Creates a {@link Page} in the default browser context.\n     */\n    async newPage() {\n        return this._defaultContext.newPage();\n    }\n    /**\n     * @internal\n     * Used by BrowserContext directly so cannot be marked private.\n     */\n    async _createPageInContext(contextId) {\n        const { targetId } = await this._connection.send('Target.createTarget', {\n            url: 'about:blank',\n            browserContextId: contextId || undefined,\n        });\n        const target = await this._targets.get(targetId);\n        assert_js_1.assert(await target._initializedPromise, 'Failed to create target for page');\n        const page = await target.page();\n        return page;\n    }\n    /**\n     * All active targets inside the Browser. In case of multiple browser contexts, returns\n     * an array with all the targets in all browser contexts.\n     */\n    targets() {\n        return Array.from(this._targets.values()).filter((target) => target._isInitialized);\n    }\n    /**\n     * The target associated with the browser.\n     */\n    target() {\n        return this.targets().find((target) => target.type() === 'browser');\n    }\n    /**\n     * Searches for a target in all browser contexts.\n     *\n     * @param predicate - A function to be run for every target.\n     * @returns The first target found that matches the `predicate` function.\n     *\n     * @example\n     *\n     * An example of finding a target for a page opened via `window.open`:\n     * ```js\n     * await page.evaluate(() => window.open('https://www.example.com/'));\n     * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');\n     * ```\n     */\n    async waitForTarget(predicate, options = {}) {\n        const { timeout = 30000 } = options;\n        const existingTarget = this.targets().find(predicate);\n        if (existingTarget)\n            return existingTarget;\n        let resolve;\n        const targetPromise = new Promise((x) => (resolve = x));\n        this.on(\"targetcreated\" /* TargetCreated */, check);\n        this.on(\"targetchanged\" /* TargetChanged */, check);\n        try {\n            if (!timeout)\n                return await targetPromise;\n            return await helper_js_1.helper.waitWithTimeout(targetPromise, 'target', timeout);\n        }\n        finally {\n            this.removeListener(\"targetcreated\" /* TargetCreated */, check);\n            this.removeListener(\"targetchanged\" /* TargetChanged */, check);\n        }\n        function check(target) {\n            if (predicate(target))\n                resolve(target);\n        }\n    }\n    /**\n     * An array of all open pages inside the Browser.\n     *\n     * @remarks\n     *\n     * In case of multiple browser contexts, returns an array with all the pages in all\n     * browser contexts. Non-visible pages, such as `\"background_page\"`, will not be listed\n     * here. You can find them using {@link Target.page}.\n     */\n    async pages() {\n        const contextPages = await Promise.all(this.browserContexts().map((context) => context.pages()));\n        // Flatten array.\n        return contextPages.reduce((acc, x) => acc.concat(x), []);\n    }\n    /**\n     * A string representing the browser name and version.\n     *\n     * @remarks\n     *\n     * For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For\n     * non-headless, this is similar to `Chrome/61.0.3153.0`.\n     *\n     * The format of browser.version() might change with future releases of Chromium.\n     */\n    async version() {\n        const version = await this._getVersion();\n        return version.product;\n    }\n    /**\n     * The browser's original user agent. Pages can override the browser user agent with\n     * {@link Page.setUserAgent}.\n     */\n    async userAgent() {\n        const version = await this._getVersion();\n        return version.userAgent;\n    }\n    /**\n     * Closes Chromium and all of its pages (if any were opened). The {@link Browser} object\n     * itself is considered to be disposed and cannot be used anymore.\n     */\n    async close() {\n        await this._closeCallback.call(null);\n        this.disconnect();\n    }\n    /**\n     * Disconnects Puppeteer from the browser, but leaves the Chromium process running.\n     * After calling `disconnect`, the {@link Browser} object is considered disposed and\n     * cannot be used anymore.\n     */\n    disconnect() {\n        this._connection.dispose();\n    }\n    /**\n     * Indicates that the browser is connected.\n     */\n    isConnected() {\n        return !this._connection._closed;\n    }\n    _getVersion() {\n        return this._connection.send('Browser.getVersion');\n    }\n}\nexports.Browser = Browser;\n/**\n * BrowserContexts provide a way to operate multiple independent browser\n * sessions. When a browser is launched, it has a single BrowserContext used by\n * default. The method {@link Browser.newPage | Browser.newPage} creates a page\n * in the default browser context.\n *\n * @remarks\n *\n * The Browser class extends from Puppeteer's {@link EventEmitter} class and\n * will emit various events which are documented in the\n * {@link BrowserContextEmittedEvents} enum.\n *\n * If a page opens another page, e.g. with a `window.open` call, the popup will\n * belong to the parent page's browser context.\n *\n * Puppeteer allows creation of \"incognito\" browser contexts with\n * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}\n * method. \"Incognito\" browser contexts don't write any browsing data to disk.\n *\n * @example\n * ```js\n * // Create a new incognito browser context\n * const context = await browser.createIncognitoBrowserContext();\n * // Create a new page inside context.\n * const page = await context.newPage();\n * // ... do stuff with page ...\n * await page.goto('https://example.com');\n * // Dispose context once it's no longer needed.\n * await context.close();\n * ```\n */\nclass BrowserContext extends EventEmitter_js_1.EventEmitter {\n    /**\n     * @internal\n     */\n    constructor(connection, browser, contextId) {\n        super();\n        this._connection = connection;\n        this._browser = browser;\n        this._id = contextId;\n    }\n    /**\n     * An array of all active targets inside the browser context.\n     */\n    targets() {\n        return this._browser\n            .targets()\n            .filter((target) => target.browserContext() === this);\n    }\n    /**\n     * This searches for a target in this specific browser context.\n     *\n     * @example\n     * An example of finding a target for a page opened via `window.open`:\n     * ```js\n     * await page.evaluate(() => window.open('https://www.example.com/'));\n     * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');\n     * ```\n     *\n     * @param predicate - A function to be run for every target\n     * @param options - An object of options. Accepts a timout,\n     * which is the maximum wait time in milliseconds.\n     * Pass `0` to disable the timeout. Defaults to 30 seconds.\n     * @returns Promise which resolves to the first target found\n     * that matches the `predicate` function.\n     */\n    waitForTarget(predicate, options = {}) {\n        return this._browser.waitForTarget((target) => target.browserContext() === this && predicate(target), options);\n    }\n    /**\n     * An array of all pages inside the browser context.\n     *\n     * @returns Promise which resolves to an array of all open pages.\n     * Non visible pages, such as `\"background_page\"`, will not be listed here.\n     * You can find them using {@link Target.page | the target page}.\n     */\n    async pages() {\n        const pages = await Promise.all(this.targets()\n            .filter((target) => target.type() === 'page')\n            .map((target) => target.page()));\n        return pages.filter((page) => !!page);\n    }\n    /**\n     * Returns whether BrowserContext is incognito.\n     * The default browser context is the only non-incognito browser context.\n     *\n     * @remarks\n     * The default browser context cannot be closed.\n     */\n    isIncognito() {\n        return !!this._id;\n    }\n    /**\n     * @example\n     * ```js\n     * const context = browser.defaultBrowserContext();\n     * await context.overridePermissions('https://html5demos.com', ['geolocation']);\n     * ```\n     *\n     * @param origin - The origin to grant permissions to, e.g. \"https://example.com\".\n     * @param permissions - An array of permissions to grant.\n     * All permissions that are not listed here will be automatically denied.\n     */\n    async overridePermissions(origin, permissions) {\n        const webPermissionToProtocol = new Map([\n            ['geolocation', 'geolocation'],\n            ['midi', 'midi'],\n            ['notifications', 'notifications'],\n            // TODO: push isn't a valid type?\n            // ['push', 'push'],\n            ['camera', 'videoCapture'],\n            ['microphone', 'audioCapture'],\n            ['background-sync', 'backgroundSync'],\n            ['ambient-light-sensor', 'sensors'],\n            ['accelerometer', 'sensors'],\n            ['gyroscope', 'sensors'],\n            ['magnetometer', 'sensors'],\n            ['accessibility-events', 'accessibilityEvents'],\n            ['clipboard-read', 'clipboardReadWrite'],\n            ['clipboard-write', 'clipboardReadWrite'],\n            ['payment-handler', 'paymentHandler'],\n            ['idle-detection', 'idleDetection'],\n            // chrome-specific permissions we have.\n            ['midi-sysex', 'midiSysex'],\n        ]);\n        const protocolPermissions = permissions.map((permission) => {\n            const protocolPermission = webPermissionToProtocol.get(permission);\n            if (!protocolPermission)\n                throw new Error('Unknown permission: ' + permission);\n            return protocolPermission;\n        });\n        await this._connection.send('Browser.grantPermissions', {\n            origin,\n            browserContextId: this._id || undefined,\n            permissions: protocolPermissions,\n        });\n    }\n    /**\n     * Clears all permission overrides for the browser context.\n     *\n     * @example\n     * ```js\n     * const context = browser.defaultBrowserContext();\n     * context.overridePermissions('https://example.com', ['clipboard-read']);\n     * // do stuff ..\n     * context.clearPermissionOverrides();\n     * ```\n     */\n    async clearPermissionOverrides() {\n        await this._connection.send('Browser.resetPermissions', {\n            browserContextId: this._id || undefined,\n        });\n    }\n    /**\n     * Creates a new page in the browser context.\n     */\n    newPage() {\n        return this._browser._createPageInContext(this._id);\n    }\n    /**\n     * The browser this browser context belongs to.\n     */\n    browser() {\n        return this._browser;\n    }\n    /**\n     * Closes the browser context. All the targets that belong to the browser context\n     * will be closed.\n     *\n     * @remarks\n     * Only incognito browser contexts can be closed.\n     */\n    async close() {\n        assert_js_1.assert(this._id, 'Non-incognito profiles cannot be closed!');\n        await this._browser._disposeContext(this._id);\n    }\n}\nexports.BrowserContext = BrowserContext;\n//# sourceMappingURL=Browser.js.map"]},"metadata":{},"sourceType":"script"}