{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventEmitter = void 0;\n\nconst index_js_1 = __importDefault(require(\"../../vendor/mitt/src/index.js\"));\n/**\n * The EventEmitter class that many Puppeteer classes extend.\n *\n * @remarks\n *\n * This allows you to listen to events that Puppeteer classes fire and act\n * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and\n * {@link EventEmitter.off | off} to bind\n * and unbind to event listeners.\n *\n * @public\n */\n\n\nclass EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    this.eventsMap = new Map();\n    this.emitter = index_js_1.default(this.eventsMap);\n  }\n  /**\n   * Bind an event listener to fire when an event occurs.\n   * @param event - the event type you'd like to listen to. Can be a string or symbol.\n   * @param handler  - the function to be called when the event occurs.\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  on(event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  }\n  /**\n   * Remove an event listener from firing.\n   * @param event - the event type you'd like to stop listening to.\n   * @param handler  - the function that should be removed.\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  off(event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  }\n  /**\n   * Remove an event listener.\n   * @deprecated please use `off` instead.\n   */\n\n\n  removeListener(event, handler) {\n    this.off(event, handler);\n    return this;\n  }\n  /**\n   * Add an event listener.\n   * @deprecated please use `on` instead.\n   */\n\n\n  addListener(event, handler) {\n    this.on(event, handler);\n    return this;\n  }\n  /**\n   * Emit an event and call any associated listeners.\n   *\n   * @param event - the event you'd like to emit\n   * @param eventData - any data you'd like to emit with the event\n   * @returns `true` if there are any listeners, `false` if there are not.\n   */\n\n\n  emit(event, eventData) {\n    this.emitter.emit(event, eventData);\n    return this.eventListenersCount(event) > 0;\n  }\n  /**\n   * Like `on` but the listener will only be fired once and then it will be removed.\n   * @param event - the event you'd like to listen to\n   * @param handler - the handler function to run when the event occurs\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  once(event, handler) {\n    const onceHandler = eventData => {\n      handler(eventData);\n      this.off(event, onceHandler);\n    };\n\n    return this.on(event, onceHandler);\n  }\n  /**\n   * Gets the number of listeners for a given event.\n   *\n   * @param event - the event to get the listener count for\n   * @returns the number of listeners bound to the given event\n   */\n\n\n  listenerCount(event) {\n    return this.eventListenersCount(event);\n  }\n  /**\n   * Removes all listeners. If given an event argument, it will remove only\n   * listeners for that event.\n   * @param event - the event to remove listeners for.\n   * @returns `this` to enable you to chain calls.\n   */\n\n\n  removeAllListeners(event) {\n    if (event) {\n      this.eventsMap.delete(event);\n    } else {\n      this.eventsMap.clear();\n    }\n\n    return this;\n  }\n\n  eventListenersCount(event) {\n    return this.eventsMap.has(event) ? this.eventsMap.get(event).length : 0;\n  }\n\n}\n\nexports.EventEmitter = EventEmitter;","map":{"version":3,"sources":["../../../../src/common/EventEmitter.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,eAAA,CAAA,OAAA,CAAA,gCAAA,CAAA,CAAA;AAyBA;;;;;;;;;;;AAWG;;;AACH,MAAa,YAAb,CAAyB;AAIvB;;AAEG;AACH,EAAA,WAAA,GAAA;AALQ,SAAA,SAAA,GAAY,IAAI,GAAJ,EAAZ;AAMN,SAAK,OAAL,GAAe,UAAA,CAAA,OAAA,CAAK,KAAK,SAAV,CAAf;AACD;AAED;;;;;AAKG;;;AACH,EAAA,EAAE,CAAC,KAAD,EAAmB,OAAnB,EAAmC;AACnC,SAAK,OAAL,CAAa,EAAb,CAAgB,KAAhB,EAAuB,OAAvB;AACA,WAAO,IAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,GAAG,CAAC,KAAD,EAAmB,OAAnB,EAAmC;AACpC,SAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,EAAwB,OAAxB;AACA,WAAO,IAAP;AACD;AAED;;;AAGG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAmB,OAAnB,EAAmC;AAC/C,SAAK,GAAL,CAAS,KAAT,EAAgB,OAAhB;AACA,WAAO,IAAP;AACD;AAED;;;AAGG;;;AACH,EAAA,WAAW,CAAC,KAAD,EAAmB,OAAnB,EAAmC;AAC5C,SAAK,EAAL,CAAQ,KAAR,EAAe,OAAf;AACA,WAAO,IAAP;AACD;AAED;;;;;;AAMG;;;AACH,EAAA,IAAI,CAAC,KAAD,EAAmB,SAAnB,EAAkC;AACpC,SAAK,OAAL,CAAa,IAAb,CAAkB,KAAlB,EAAyB,SAAzB;AACA,WAAO,KAAK,mBAAL,CAAyB,KAAzB,IAAkC,CAAzC;AACD;AAED;;;;;AAKG;;;AACH,EAAA,IAAI,CAAC,KAAD,EAAmB,OAAnB,EAAmC;AACrC,UAAM,WAAW,GAAa,SAAD,IAAc;AACzC,MAAA,OAAO,CAAC,SAAD,CAAP;AACA,WAAK,GAAL,CAAS,KAAT,EAAgB,WAAhB;AACD,KAHD;;AAKA,WAAO,KAAK,EAAL,CAAQ,KAAR,EAAe,WAAf,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAiB;AAC5B,WAAO,KAAK,mBAAL,CAAyB,KAAzB,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,kBAAkB,CAAC,KAAD,EAAkB;AAClC,QAAI,KAAJ,EAAW;AACT,WAAK,SAAL,CAAe,MAAf,CAAsB,KAAtB;AACD,KAFD,MAEO;AACL,WAAK,SAAL,CAAe,KAAf;AACD;;AACD,WAAO,IAAP;AACD;;AAEO,EAAA,mBAAmB,CAAC,KAAD,EAAiB;AAC1C,WAAO,KAAK,SAAL,CAAe,GAAf,CAAmB,KAAnB,IAA4B,KAAK,SAAL,CAAe,GAAf,CAAmB,KAAnB,EAA0B,MAAtD,GAA+D,CAAtE;AACD;;AAzGsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventEmitter = void 0;\nconst index_js_1 = __importDefault(require(\"../../vendor/mitt/src/index.js\"));\n/**\n * The EventEmitter class that many Puppeteer classes extend.\n *\n * @remarks\n *\n * This allows you to listen to events that Puppeteer classes fire and act\n * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and\n * {@link EventEmitter.off | off} to bind\n * and unbind to event listeners.\n *\n * @public\n */\nclass EventEmitter {\n    /**\n     * @internal\n     */\n    constructor() {\n        this.eventsMap = new Map();\n        this.emitter = index_js_1.default(this.eventsMap);\n    }\n    /**\n     * Bind an event listener to fire when an event occurs.\n     * @param event - the event type you'd like to listen to. Can be a string or symbol.\n     * @param handler  - the function to be called when the event occurs.\n     * @returns `this` to enable you to chain calls.\n     */\n    on(event, handler) {\n        this.emitter.on(event, handler);\n        return this;\n    }\n    /**\n     * Remove an event listener from firing.\n     * @param event - the event type you'd like to stop listening to.\n     * @param handler  - the function that should be removed.\n     * @returns `this` to enable you to chain calls.\n     */\n    off(event, handler) {\n        this.emitter.off(event, handler);\n        return this;\n    }\n    /**\n     * Remove an event listener.\n     * @deprecated please use `off` instead.\n     */\n    removeListener(event, handler) {\n        this.off(event, handler);\n        return this;\n    }\n    /**\n     * Add an event listener.\n     * @deprecated please use `on` instead.\n     */\n    addListener(event, handler) {\n        this.on(event, handler);\n        return this;\n    }\n    /**\n     * Emit an event and call any associated listeners.\n     *\n     * @param event - the event you'd like to emit\n     * @param eventData - any data you'd like to emit with the event\n     * @returns `true` if there are any listeners, `false` if there are not.\n     */\n    emit(event, eventData) {\n        this.emitter.emit(event, eventData);\n        return this.eventListenersCount(event) > 0;\n    }\n    /**\n     * Like `on` but the listener will only be fired once and then it will be removed.\n     * @param event - the event you'd like to listen to\n     * @param handler - the handler function to run when the event occurs\n     * @returns `this` to enable you to chain calls.\n     */\n    once(event, handler) {\n        const onceHandler = (eventData) => {\n            handler(eventData);\n            this.off(event, onceHandler);\n        };\n        return this.on(event, onceHandler);\n    }\n    /**\n     * Gets the number of listeners for a given event.\n     *\n     * @param event - the event to get the listener count for\n     * @returns the number of listeners bound to the given event\n     */\n    listenerCount(event) {\n        return this.eventListenersCount(event);\n    }\n    /**\n     * Removes all listeners. If given an event argument, it will remove only\n     * listeners for that event.\n     * @param event - the event to remove listeners for.\n     * @returns `this` to enable you to chain calls.\n     */\n    removeAllListeners(event) {\n        if (event) {\n            this.eventsMap.delete(event);\n        }\n        else {\n            this.eventsMap.clear();\n        }\n        return this;\n    }\n    eventListenersCount(event) {\n        return this.eventsMap.has(event) ? this.eventsMap.get(event).length : 0;\n    }\n}\nexports.EventEmitter = EventEmitter;\n//# sourceMappingURL=EventEmitter.js.map"]},"metadata":{},"sourceType":"script"}