{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Page = void 0;\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst Connection_js_1 = require(\"./Connection.js\");\n\nconst Dialog_js_1 = require(\"./Dialog.js\");\n\nconst EmulationManager_js_1 = require(\"./EmulationManager.js\");\n\nconst FrameManager_js_1 = require(\"./FrameManager.js\");\n\nconst Input_js_1 = require(\"./Input.js\");\n\nconst Tracing_js_1 = require(\"./Tracing.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst Coverage_js_1 = require(\"./Coverage.js\");\n\nconst WebWorker_js_1 = require(\"./WebWorker.js\");\n\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\n\nconst Accessibility_js_1 = require(\"./Accessibility.js\");\n\nconst TimeoutSettings_js_1 = require(\"./TimeoutSettings.js\");\n\nconst FileChooser_js_1 = require(\"./FileChooser.js\");\n\nconst ConsoleMessage_js_1 = require(\"./ConsoleMessage.js\");\n\nconst PDFOptions_js_1 = require(\"./PDFOptions.js\");\n\nconst environment_js_1 = require(\"../environment.js\");\n\nclass ScreenshotTaskQueue {\n  constructor() {\n    this._chain = Promise.resolve(undefined);\n  }\n\n  postTask(task) {\n    const result = this._chain.then(task);\n\n    this._chain = result.catch(() => {});\n    return result;\n  }\n\n}\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page} in Chromium.\n *\n * @remarks\n *\n * One Browser instance might have multiple Page instances.\n *\n * @example\n * This example creates a page, navigates it to a URL, and then * saves a screenshot:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEmittedEvents} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n * ```js\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the `off` method:\n *\n * ```js\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n * @public\n */\n\n\nclass Page extends EventEmitter_js_1.EventEmitter {\n  /**\n   * @internal\n   */\n  constructor(client, target, ignoreHTTPSErrors) {\n    super();\n    this._closed = false;\n    this._timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();\n    this._pageBindings = new Map();\n    this._javascriptEnabled = true;\n    this._workers = new Map(); // TODO: improve this typedef - it's a function that takes a file chooser or\n    // something?\n\n    this._fileChooserInterceptors = new Set();\n    this._client = client;\n    this._target = target;\n    this._keyboard = new Input_js_1.Keyboard(client);\n    this._mouse = new Input_js_1.Mouse(client, this._keyboard);\n    this._touchscreen = new Input_js_1.Touchscreen(client, this._keyboard);\n    this._accessibility = new Accessibility_js_1.Accessibility(client);\n    this._frameManager = new FrameManager_js_1.FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);\n    this._emulationManager = new EmulationManager_js_1.EmulationManager(client);\n    this._tracing = new Tracing_js_1.Tracing(client);\n    this._coverage = new Coverage_js_1.Coverage(client);\n    this._screenshotTaskQueue = new ScreenshotTaskQueue();\n    this._viewport = null;\n    client.on('Target.attachedToTarget', event => {\n      if (event.targetInfo.type !== 'worker') {\n        // If we don't detach from service workers, they will never die.\n        client.send('Target.detachFromTarget', {\n          sessionId: event.sessionId\n        }).catch(helper_js_1.debugError);\n        return;\n      }\n\n      const session = Connection_js_1.Connection.fromSession(client).session(event.sessionId);\n      const worker = new WebWorker_js_1.WebWorker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));\n\n      this._workers.set(event.sessionId, worker);\n\n      this.emit(\"workercreated\"\n      /* WorkerCreated */\n      , worker);\n    });\n    client.on('Target.detachedFromTarget', event => {\n      const worker = this._workers.get(event.sessionId);\n\n      if (!worker) return;\n      this.emit(\"workerdestroyed\"\n      /* WorkerDestroyed */\n      , worker);\n\n      this._workers.delete(event.sessionId);\n    });\n\n    this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, event => this.emit(\"frameattached\"\n    /* FrameAttached */\n    , event));\n\n    this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, event => this.emit(\"framedetached\"\n    /* FrameDetached */\n    , event));\n\n    this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, event => this.emit(\"framenavigated\"\n    /* FrameNavigated */\n    , event));\n\n    const networkManager = this._frameManager.networkManager();\n\n    networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Request, event => this.emit(\"request\"\n    /* Request */\n    , event));\n    networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Response, event => this.emit(\"response\"\n    /* Response */\n    , event));\n    networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, event => this.emit(\"requestfailed\"\n    /* RequestFailed */\n    , event));\n    networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished, event => this.emit(\"requestfinished\"\n    /* RequestFinished */\n    , event));\n    this._fileChooserInterceptors = new Set();\n    client.on('Page.domContentEventFired', () => this.emit(\"domcontentloaded\"\n    /* DOMContentLoaded */\n    ));\n    client.on('Page.loadEventFired', () => this.emit(\"load\"\n    /* Load */\n    ));\n    client.on('Runtime.consoleAPICalled', event => this._onConsoleAPI(event));\n    client.on('Runtime.bindingCalled', event => this._onBindingCalled(event));\n    client.on('Page.javascriptDialogOpening', event => this._onDialog(event));\n    client.on('Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails));\n    client.on('Inspector.targetCrashed', () => this._onTargetCrashed());\n    client.on('Performance.metrics', event => this._emitMetrics(event));\n    client.on('Log.entryAdded', event => this._onLogEntryAdded(event));\n    client.on('Page.fileChooserOpened', event => this._onFileChooser(event));\n\n    this._target._isClosedPromise.then(() => {\n      this.emit(\"close\"\n      /* Close */\n      );\n      this._closed = true;\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  static async create(client, target, ignoreHTTPSErrors, defaultViewport) {\n    const page = new Page(client, target, ignoreHTTPSErrors);\n    await page._initialize();\n    if (defaultViewport) await page.setViewport(defaultViewport);\n    return page;\n  }\n\n  async _initialize() {\n    await Promise.all([this._frameManager.initialize(), this._client.send('Target.setAutoAttach', {\n      autoAttach: true,\n      waitForDebuggerOnStart: false,\n      flatten: true\n    }), this._client.send('Performance.enable'), this._client.send('Log.enable')]);\n  }\n\n  async _onFileChooser(event) {\n    if (!this._fileChooserInterceptors.size) return;\n\n    const frame = this._frameManager.frame(event.frameId);\n\n    const context = await frame.executionContext();\n    const element = await context._adoptBackendNodeId(event.backendNodeId);\n    const interceptors = Array.from(this._fileChooserInterceptors);\n\n    this._fileChooserInterceptors.clear();\n\n    const fileChooser = new FileChooser_js_1.FileChooser(element, event);\n\n    for (const interceptor of interceptors) interceptor.call(null, fileChooser);\n  }\n  /**\n   * @returns `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n\n\n  isJavaScriptEnabled() {\n    return this._javascriptEnabled;\n  }\n  /**\n   * @param options - Optional waiting parameters\n   * @returns Resolves after a page requests a file picker.\n   */\n\n\n  async waitForFileChooser(options = {}) {\n    if (!this._fileChooserInterceptors.size) await this._client.send('Page.setInterceptFileChooserDialog', {\n      enabled: true\n    });\n    const {\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    let callback;\n    const promise = new Promise(x => callback = x);\n\n    this._fileChooserInterceptors.add(callback);\n\n    return helper_js_1.helper.waitWithTimeout(promise, 'waiting for file chooser', timeout).catch(error => {\n      this._fileChooserInterceptors.delete(callback);\n\n      throw error;\n    });\n  }\n  /**\n   * Sets the page's geolocation.\n   *\n   * @remarks\n   * Consider using {@link BrowserContext.overridePermissions} to grant\n   * permissions for the page to read its geolocation.\n   *\n   * @example\n   * ```js\n   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n   * ```\n   */\n\n\n  async setGeolocation(options) {\n    const {\n      longitude,\n      latitude,\n      accuracy = 0\n    } = options;\n    if (longitude < -180 || longitude > 180) throw new Error(`Invalid longitude \"${longitude}\": precondition -180 <= LONGITUDE <= 180 failed.`);\n    if (latitude < -90 || latitude > 90) throw new Error(`Invalid latitude \"${latitude}\": precondition -90 <= LATITUDE <= 90 failed.`);\n    if (accuracy < 0) throw new Error(`Invalid accuracy \"${accuracy}\": precondition 0 <= ACCURACY failed.`);\n    await this._client.send('Emulation.setGeolocationOverride', {\n      longitude,\n      latitude,\n      accuracy\n    });\n  }\n  /**\n   * @returns A target this page was created from.\n   */\n\n\n  target() {\n    return this._target;\n  }\n  /**\n   * @returns The browser this page belongs to.\n   */\n\n\n  browser() {\n    return this._target.browser();\n  }\n  /**\n   * @returns The browser context that the page belongs to\n   */\n\n\n  browserContext() {\n    return this._target.browserContext();\n  }\n\n  _onTargetCrashed() {\n    this.emit('error', new Error('Page crashed!'));\n  }\n\n  _onLogEntryAdded(event) {\n    const {\n      level,\n      text,\n      args,\n      source,\n      url,\n      lineNumber\n    } = event.entry;\n    if (args) args.map(arg => helper_js_1.helper.releaseObject(this._client, arg));\n    if (source !== 'worker') this.emit(\"console\"\n    /* Console */\n    , new ConsoleMessage_js_1.ConsoleMessage(level, text, [], [{\n      url,\n      lineNumber\n    }]));\n  }\n  /**\n   * @returns The page's main frame.\n   */\n\n\n  mainFrame() {\n    return this._frameManager.mainFrame();\n  }\n\n  get keyboard() {\n    return this._keyboard;\n  }\n\n  get touchscreen() {\n    return this._touchscreen;\n  }\n\n  get coverage() {\n    return this._coverage;\n  }\n\n  get tracing() {\n    return this._tracing;\n  }\n\n  get accessibility() {\n    return this._accessibility;\n  }\n  /**\n   * @returns An array of all frames attached to the page.\n   */\n\n\n  frames() {\n    return this._frameManager.frames();\n  }\n  /**\n   * @returns all of the dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorkers}\n   * associated with the page.\n   */\n\n\n  workers() {\n    return Array.from(this._workers.values());\n  }\n  /**\n   * @param value - Whether to enable request interception.\n   *\n   * @remarks\n   * Activating request interception enables {@link HTTPRequest.abort},\n   * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods.  This\n   * provides the capability to modify network requests that are made by a page.\n   *\n   * Once request interception is enabled, every request will stall unless it's\n   * continued, responded or aborted.\n   *\n   * **NOTE** Enabling request interception disables page caching.\n   *\n   * @example\n   * An example of a naïve request interceptor that aborts all image requests:\n   * ```js\n   * const puppeteer = require('puppeteer');\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.setRequestInterception(true);\n   *   page.on('request', interceptedRequest => {\n   *     if (interceptedRequest.url().endsWith('.png') ||\n   *         interceptedRequest.url().endsWith('.jpg'))\n   *       interceptedRequest.abort();\n   *     else\n   *       interceptedRequest.continue();\n   *     });\n   *   await page.goto('https://example.com');\n   *   await browser.close();\n   * })();\n   * ```\n   */\n\n\n  async setRequestInterception(value) {\n    return this._frameManager.networkManager().setRequestInterception(value);\n  }\n  /**\n   * @param enabled - When `true`, enables offline mode for the page.\n   */\n\n\n  setOfflineMode(enabled) {\n    return this._frameManager.networkManager().setOfflineMode(enabled);\n  }\n\n  emulateNetworkConditions(networkConditions) {\n    return this._frameManager.networkManager().emulateNetworkConditions(networkConditions);\n  }\n  /**\n   * @param timeout - Maximum navigation time in milliseconds.\n   */\n\n\n  setDefaultNavigationTimeout(timeout) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n  /**\n   * @param timeout - Maximum time in milliseconds.\n   */\n\n\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n  /**\n   * Runs `document.querySelector` within the page. If no element matches the\n   * selector, the return value resolves to `null`.\n   *\n   * @remarks\n   * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query page for.\n   */\n\n\n  async $(selector) {\n    return this.mainFrame().$(selector);\n  }\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Page.evaluate | page.evaluate} and\n   * `page.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * If the function passed to `page.evaluteHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   * ```\n   * const aHandle = await page.evaluateHandle('document')\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n   * ```\n   * const aHandle = await page.evaluateHandle(() => document.body);\n   * const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);\n   * console.log(await resultHandle.jsonValue());\n   * await resultHandle.dispose();\n   * ```\n   *\n   * Most of the time this function returns a {@link JSHandle},\n   * but if `pageFunction` returns a reference to an element,\n   * you instead get an {@link ElementHandle} back:\n   *\n   * @example\n   * ```\n   * const button = await page.evaluateHandle(() => document.querySelector('button'));\n   * // can call `click` because `button` is an `ElementHandle`\n   * await button.click();\n   * ```\n   *\n   * The TypeScript definitions assume that `evaluateHandle` returns\n   *  a `JSHandle`, but if you know it's going to return an\n   * `ElementHandle`, pass it as the generic argument:\n   *\n   * ```\n   * const button = await page.evaluateHandle<ElementHandle>(...);\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    const context = await this.mainFrame().executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n  /**\n   * This method iterates the JavaScript heap and finds all objects with the\n   * given prototype.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * ```js\n   * // Create a Map object\n   * await page.evaluate(() => window.map = new Map());\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   * @param prototypeHandle - a handle to the object prototype.\n   */\n\n\n  async queryObjects(prototypeHandle) {\n    const context = await this.mainFrame().executionContext();\n    return context.queryObjects(prototypeHandle);\n  }\n  /**\n   * This method runs `document.querySelector` within the page and passes the\n   * result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval('#search', (el: HTMLInputElement) => el.value);\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *  '#search', (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of `document.querySelector(selector)` as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n\n\n  async $eval(selector, pageFunction, ...args) {\n    return this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n  /**\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the page and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent)\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const allInputValues = await page.$$eval<string[]>(\n   *  'input', (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction the function to be evaluated in the page context. Will\n   * be passed the result of `Array.from(document.querySelectorAll(selector))`\n   * as its first argument.\n   * @param args any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n\n\n  async $$eval(selector, pageFunction, ...args) {\n    return this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  async $$(selector) {\n    return this.mainFrame().$$(selector);\n  }\n\n  async $x(expression) {\n    return this.mainFrame().$x(expression);\n  }\n  /**\n   * If no URLs are specified, this method returns cookies for the current page\n   * URL. If URLs are specified, only cookies for those URLs are returned.\n   */\n\n\n  async cookies(...urls) {\n    const originalCookies = (await this._client.send('Network.getCookies', {\n      urls: urls.length ? urls : [this.url()]\n    })).cookies;\n    const unsupportedCookieAttributes = ['priority'];\n\n    const filterUnsupportedAttributes = cookie => {\n      for (const attr of unsupportedCookieAttributes) delete cookie[attr];\n\n      return cookie;\n    };\n\n    return originalCookies.map(filterUnsupportedAttributes);\n  }\n\n  async deleteCookie(...cookies) {\n    const pageURL = this.url();\n\n    for (const cookie of cookies) {\n      const item = Object.assign({}, cookie);\n      if (!cookie.url && pageURL.startsWith('http')) item.url = pageURL;\n      await this._client.send('Network.deleteCookies', item);\n    }\n  }\n\n  async setCookie(...cookies) {\n    const pageURL = this.url();\n    const startsWithHTTP = pageURL.startsWith('http');\n    const items = cookies.map(cookie => {\n      const item = Object.assign({}, cookie);\n      if (!item.url && startsWithHTTP) item.url = pageURL;\n      assert_js_1.assert(item.url !== 'about:blank', `Blank page can not have cookie \"${item.name}\"`);\n      assert_js_1.assert(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie \"${item.name}\"`);\n      return item;\n    });\n    await this.deleteCookie(...items);\n    if (items.length) await this._client.send('Network.setCookies', {\n      cookies: items\n    });\n  }\n\n  async addScriptTag(options) {\n    return this.mainFrame().addScriptTag(options);\n  }\n\n  async addStyleTag(options) {\n    return this.mainFrame().addStyleTag(options);\n  }\n\n  async exposeFunction(name, puppeteerFunction) {\n    if (this._pageBindings.has(name)) throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);\n\n    this._pageBindings.set(name, puppeteerFunction);\n\n    const expression = helper_js_1.helper.pageBindingInitString('exposedFun', name);\n    await this._client.send('Runtime.addBinding', {\n      name: name\n    });\n    await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: expression\n    });\n    await Promise.all(this.frames().map(frame => frame.evaluate(expression).catch(helper_js_1.debugError)));\n  }\n\n  async authenticate(credentials) {\n    return this._frameManager.networkManager().authenticate(credentials);\n  }\n\n  async setExtraHTTPHeaders(headers) {\n    return this._frameManager.networkManager().setExtraHTTPHeaders(headers);\n  }\n\n  async setUserAgent(userAgent) {\n    return this._frameManager.networkManager().setUserAgent(userAgent);\n  }\n\n  async metrics() {\n    const response = await this._client.send('Performance.getMetrics');\n    return this._buildMetricsObject(response.metrics);\n  }\n\n  _emitMetrics(event) {\n    this.emit(\"metrics\"\n    /* Metrics */\n    , {\n      title: event.title,\n      metrics: this._buildMetricsObject(event.metrics)\n    });\n  }\n\n  _buildMetricsObject(metrics) {\n    const result = {};\n\n    for (const metric of metrics || []) {\n      if (supportedMetrics.has(metric.name)) result[metric.name] = metric.value;\n    }\n\n    return result;\n  }\n\n  _handleException(exceptionDetails) {\n    const message = helper_js_1.helper.getExceptionMessage(exceptionDetails);\n    const err = new Error(message);\n    err.stack = ''; // Don't report clientside error with a node stack attached\n\n    this.emit(\"pageerror\"\n    /* PageError */\n    , err);\n  }\n\n  async _onConsoleAPI(event) {\n    if (event.executionContextId === 0) {\n      // DevTools protocol stores the last 1000 console messages. These\n      // messages are always reported even for removed execution contexts. In\n      // this case, they are marked with executionContextId = 0 and are\n      // reported upon enabling Runtime agent.\n      //\n      // Ignore these messages since:\n      // - there's no execution context we can use to operate with message\n      //   arguments\n      // - these messages are reported before Puppeteer clients can subscribe\n      //   to the 'console'\n      //   page event.\n      //\n      // @see https://github.com/puppeteer/puppeteer/issues/3865\n      return;\n    }\n\n    const context = this._frameManager.executionContextById(event.executionContextId);\n\n    const values = event.args.map(arg => JSHandle_js_1.createJSHandle(context, arg));\n\n    this._addConsoleMessage(event.type, values, event.stackTrace);\n  }\n\n  async _onBindingCalled(event) {\n    let payload;\n\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n\n    const {\n      type,\n      name,\n      seq,\n      args\n    } = payload;\n    if (type !== 'exposedFun' || !this._pageBindings.has(name)) return;\n    let expression = null;\n\n    try {\n      const result = await this._pageBindings.get(name)(...args);\n      expression = helper_js_1.helper.pageBindingDeliverResultString(name, seq, result);\n    } catch (error) {\n      if (error instanceof Error) expression = helper_js_1.helper.pageBindingDeliverErrorString(name, seq, error.message, error.stack);else expression = helper_js_1.helper.pageBindingDeliverErrorValueString(name, seq, error);\n    }\n\n    this._client.send('Runtime.evaluate', {\n      expression,\n      contextId: event.executionContextId\n    }).catch(helper_js_1.debugError);\n  }\n\n  _addConsoleMessage(type, args, stackTrace) {\n    if (!this.listenerCount(\"console\"\n    /* Console */\n    )) {\n      args.forEach(arg => arg.dispose());\n      return;\n    }\n\n    const textTokens = [];\n\n    for (const arg of args) {\n      const remoteObject = arg._remoteObject;\n      if (remoteObject.objectId) textTokens.push(arg.toString());else textTokens.push(helper_js_1.helper.valueFromRemoteObject(remoteObject));\n    }\n\n    const stackTraceLocations = [];\n\n    if (stackTrace) {\n      for (const callFrame of stackTrace.callFrames) {\n        stackTraceLocations.push({\n          url: callFrame.url,\n          lineNumber: callFrame.lineNumber,\n          columnNumber: callFrame.columnNumber\n        });\n      }\n    }\n\n    const message = new ConsoleMessage_js_1.ConsoleMessage(type, textTokens.join(' '), args, stackTraceLocations);\n    this.emit(\"console\"\n    /* Console */\n    , message);\n  }\n\n  _onDialog(event) {\n    let dialogType = null;\n    const validDialogTypes = new Set(['alert', 'confirm', 'prompt', 'beforeunload']);\n\n    if (validDialogTypes.has(event.type)) {\n      dialogType = event.type;\n    }\n\n    assert_js_1.assert(dialogType, 'Unknown javascript dialog type: ' + event.type);\n    const dialog = new Dialog_js_1.Dialog(this._client, dialogType, event.message, event.defaultPrompt);\n    this.emit(\"dialog\"\n    /* Dialog */\n    , dialog);\n  }\n\n  url() {\n    return this.mainFrame().url();\n  }\n\n  async content() {\n    return await this._frameManager.mainFrame().content();\n  }\n\n  async setContent(html, options = {}) {\n    await this._frameManager.mainFrame().setContent(html, options);\n  }\n\n  async goto(url, options = {}) {\n    return await this._frameManager.mainFrame().goto(url, options);\n  }\n\n  async reload(options) {\n    const result = await Promise.all([this.waitForNavigation(options), this._client.send('Page.reload')]);\n    return result[0];\n  }\n\n  async waitForNavigation(options = {}) {\n    return await this._frameManager.mainFrame().waitForNavigation(options);\n  }\n\n  _sessionClosePromise() {\n    if (!this._disconnectPromise) this._disconnectPromise = new Promise(fulfill => this._client.once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => fulfill(new Error('Target closed'))));\n    return this._disconnectPromise;\n  }\n\n  async waitForRequest(urlOrPredicate, options = {}) {\n    const {\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    return helper_js_1.helper.waitForEvent(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Request, request => {\n      if (helper_js_1.helper.isString(urlOrPredicate)) return urlOrPredicate === request.url();\n      if (typeof urlOrPredicate === 'function') return !!urlOrPredicate(request);\n      return false;\n    }, timeout, this._sessionClosePromise());\n  }\n\n  async waitForResponse(urlOrPredicate, options = {}) {\n    const {\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    return helper_js_1.helper.waitForEvent(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Response, async response => {\n      if (helper_js_1.helper.isString(urlOrPredicate)) return urlOrPredicate === response.url();\n      if (typeof urlOrPredicate === 'function') return !!(await urlOrPredicate(response));\n      return false;\n    }, timeout, this._sessionClosePromise());\n  }\n\n  async goBack(options = {}) {\n    return this._go(-1, options);\n  }\n\n  async goForward(options = {}) {\n    return this._go(+1, options);\n  }\n\n  async _go(delta, options) {\n    const history = await this._client.send('Page.getNavigationHistory');\n    const entry = history.entries[history.currentIndex + delta];\n    if (!entry) return null;\n    const result = await Promise.all([this.waitForNavigation(options), this._client.send('Page.navigateToHistoryEntry', {\n      entryId: entry.id\n    })]);\n    return result[0];\n  }\n\n  async bringToFront() {\n    await this._client.send('Page.bringToFront');\n  }\n\n  async emulate(options) {\n    await Promise.all([this.setViewport(options.viewport), this.setUserAgent(options.userAgent)]);\n  }\n\n  async setJavaScriptEnabled(enabled) {\n    if (this._javascriptEnabled === enabled) return;\n    this._javascriptEnabled = enabled;\n    await this._client.send('Emulation.setScriptExecutionDisabled', {\n      value: !enabled\n    });\n  }\n\n  async setBypassCSP(enabled) {\n    await this._client.send('Page.setBypassCSP', {\n      enabled\n    });\n  }\n\n  async emulateMediaType(type) {\n    assert_js_1.assert(type === 'screen' || type === 'print' || type === null, 'Unsupported media type: ' + type);\n    await this._client.send('Emulation.setEmulatedMedia', {\n      media: type || ''\n    });\n  }\n\n  async emulateMediaFeatures(features) {\n    if (features === null) await this._client.send('Emulation.setEmulatedMedia', {\n      features: null\n    });\n\n    if (Array.isArray(features)) {\n      features.every(mediaFeature => {\n        const name = mediaFeature.name;\n        assert_js_1.assert(/^prefers-(?:color-scheme|reduced-motion)$/.test(name), 'Unsupported media feature: ' + name);\n        return true;\n      });\n      await this._client.send('Emulation.setEmulatedMedia', {\n        features: features\n      });\n    }\n  }\n\n  async emulateTimezone(timezoneId) {\n    try {\n      await this._client.send('Emulation.setTimezoneOverride', {\n        timezoneId: timezoneId || ''\n      });\n    } catch (error) {\n      if (error.message.includes('Invalid timezone')) throw new Error(`Invalid timezone ID: ${timezoneId}`);\n      throw error;\n    }\n  }\n  /**\n   * Emulates the idle state.\n   * If no arguments set, clears idle state emulation.\n   *\n   * @example\n   * ```js\n   * // set idle emulation\n   * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n   *\n   * // do some checks here\n   * ...\n   *\n   * // clear idle emulation\n   * await page.emulateIdleState();\n   * ```\n   *\n   * @param overrides Mock idle state. If not set, clears idle overrides\n   * @param isUserActive Mock isUserActive\n   * @param isScreenUnlocked Mock isScreenUnlocked\n   */\n\n\n  async emulateIdleState(overrides) {\n    if (overrides) {\n      await this._client.send('Emulation.setIdleOverride', {\n        isUserActive: overrides.isUserActive,\n        isScreenUnlocked: overrides.isScreenUnlocked\n      });\n    } else {\n      await this._client.send('Emulation.clearIdleOverride');\n    }\n  }\n  /**\n   * Simulates the given vision deficiency on the page.\n   *\n   * @example\n   * ```js\n   * const puppeteer = require('puppeteer');\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.goto('https://v8.dev/blog/10-years');\n   *\n   *   await page.emulateVisionDeficiency('achromatopsia');\n   *   await page.screenshot({ path: 'achromatopsia.png' });\n   *\n   *   await page.emulateVisionDeficiency('deuteranopia');\n   *   await page.screenshot({ path: 'deuteranopia.png' });\n   *\n   *   await page.emulateVisionDeficiency('blurredVision');\n   *   await page.screenshot({ path: 'blurred-vision.png' });\n   *\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param type - the type of deficiency to simulate, or `'none'` to reset.\n   */\n\n\n  async emulateVisionDeficiency(type) {\n    const visionDeficiencies = new Set(['none', 'achromatopsia', 'blurredVision', 'deuteranopia', 'protanopia', 'tritanopia']);\n\n    try {\n      assert_js_1.assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);\n      await this._client.send('Emulation.setEmulatedVisionDeficiency', {\n        type: type || 'none'\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async setViewport(viewport) {\n    const needsReload = await this._emulationManager.emulateViewport(viewport);\n    this._viewport = viewport;\n    if (needsReload) await this.reload();\n  }\n\n  viewport() {\n    return this._viewport;\n  }\n  /**\n   * @remarks\n   *\n   * Evaluates a function in the page's context and returns the result.\n   *\n   * If the function passed to `page.evaluteHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```js\n   * const result = await frame.evaluate(() => {\n   *   return Promise.resolve(8 * 7);\n   * });\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   * ```\n   * const aHandle = await page.evaluate('1 + 2');\n   * ```\n   *\n   * To get the best TypeScript experience, you should pass in as the\n   * generic the type of `pageFunction`:\n   *\n   * ```\n   * const aHandle = await page.evaluate<() => number>(() => 2);\n   * ```\n   *\n   * @example\n   *\n   * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n   * as arguments to the `pageFunction`:\n   *\n   * ```\n   * const bodyHandle = await page.$('body');\n   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n   * await bodyHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   *\n   * @returns the return value of `pageFunction`.\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    return this._frameManager.mainFrame().evaluate(pageFunction, ...args);\n  }\n\n  async evaluateOnNewDocument(pageFunction, ...args) {\n    const source = helper_js_1.helper.evaluationString(pageFunction, ...args);\n    await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n      source\n    });\n  }\n\n  async setCacheEnabled(enabled = true) {\n    await this._frameManager.networkManager().setCacheEnabled(enabled);\n  }\n\n  async screenshot(options = {}) {\n    let screenshotType = null; // options.type takes precedence over inferring the type from options.path\n    // because it may be a 0-length file with no extension created beforehand\n    // (i.e. as a temp file).\n\n    if (options.type) {\n      assert_js_1.assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);\n      screenshotType = options.type;\n    } else if (options.path) {\n      const filePath = options.path;\n      const extension = filePath.slice(filePath.lastIndexOf('.') + 1).toLowerCase();\n      if (extension === 'png') screenshotType = 'png';else if (extension === 'jpg' || extension === 'jpeg') screenshotType = 'jpeg';\n      assert_js_1.assert(screenshotType, `Unsupported screenshot type for extension \\`.${extension}\\``);\n    }\n\n    if (!screenshotType) screenshotType = 'png';\n\n    if (options.quality) {\n      assert_js_1.assert(screenshotType === 'jpeg', 'options.quality is unsupported for the ' + screenshotType + ' screenshots');\n      assert_js_1.assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + typeof options.quality);\n      assert_js_1.assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');\n      assert_js_1.assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);\n    }\n\n    assert_js_1.assert(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');\n\n    if (options.clip) {\n      assert_js_1.assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + typeof options.clip.x);\n      assert_js_1.assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + typeof options.clip.y);\n      assert_js_1.assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + typeof options.clip.width);\n      assert_js_1.assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + typeof options.clip.height);\n      assert_js_1.assert(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');\n      assert_js_1.assert(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');\n    }\n\n    return this._screenshotTaskQueue.postTask(() => this._screenshotTask(screenshotType, options));\n  }\n\n  async _screenshotTask(format, options) {\n    await this._client.send('Target.activateTarget', {\n      targetId: this._target._targetId\n    });\n    let clip = options.clip ? processClip(options.clip) : undefined;\n\n    if (options.fullPage) {\n      const metrics = await this._client.send('Page.getLayoutMetrics');\n      const width = Math.ceil(metrics.contentSize.width);\n      const height = Math.ceil(metrics.contentSize.height); // Overwrite clip for full page.\n\n      clip = {\n        x: 0,\n        y: 0,\n        width,\n        height,\n        scale: 1\n      };\n    }\n\n    const shouldSetDefaultBackground = options.omitBackground && format === 'png';\n    if (shouldSetDefaultBackground) await this._client.send('Emulation.setDefaultBackgroundColorOverride', {\n      color: {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n      }\n    });\n    const result = await this._client.send('Page.captureScreenshot', {\n      format,\n      quality: options.quality,\n      clip,\n      captureBeyondViewport: true\n    });\n    if (shouldSetDefaultBackground) await this._client.send('Emulation.setDefaultBackgroundColorOverride');\n    if (options.fullPage && this._viewport) await this.setViewport(this._viewport);\n    const buffer = options.encoding === 'base64' ? result.data : Buffer.from(result.data, 'base64');\n\n    if (!environment_js_1.isNode && options.path) {\n      throw new Error('Screenshots can only be written to a file path in a Node environment.');\n    }\n\n    const fs = await helper_js_1.helper.importFSModule();\n    if (options.path) await fs.promises.writeFile(options.path, buffer);\n    return buffer;\n\n    function processClip(clip) {\n      const x = Math.round(clip.x);\n      const y = Math.round(clip.y);\n      const width = Math.round(clip.width + clip.x - x);\n      const height = Math.round(clip.height + clip.y - y);\n      return {\n        x,\n        y,\n        width,\n        height,\n        scale: 1\n      };\n    }\n  }\n  /**\n   * Generatees a PDF of the page with the `print` CSS media type.\n   * @remarks\n   *\n   * IMPORTANT: PDF generation is only supported in Chrome headless mode.\n   *\n   * To generate a PDF with the `screen` media type, call\n   * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n   * calling `page.pdf()`.\n   *\n   * By default, `page.pdf()` generates a pdf with modified colors for printing.\n   * Use the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n   * property to force rendering of exact colors.\n   *\n   *\n   * @param options - options for generating the PDF.\n   */\n\n\n  async pdf(options = {}) {\n    const {\n      scale = 1,\n      displayHeaderFooter = false,\n      headerTemplate = '',\n      footerTemplate = '',\n      printBackground = false,\n      landscape = false,\n      pageRanges = '',\n      preferCSSPageSize = false,\n      margin = {},\n      path = null\n    } = options;\n    let paperWidth = 8.5;\n    let paperHeight = 11;\n\n    if (options.format) {\n      const format = PDFOptions_js_1.paperFormats[options.format.toLowerCase()];\n      assert_js_1.assert(format, 'Unknown paper format: ' + options.format);\n      paperWidth = format.width;\n      paperHeight = format.height;\n    } else {\n      paperWidth = convertPrintParameterToInches(options.width) || paperWidth;\n      paperHeight = convertPrintParameterToInches(options.height) || paperHeight;\n    }\n\n    const marginTop = convertPrintParameterToInches(margin.top) || 0;\n    const marginLeft = convertPrintParameterToInches(margin.left) || 0;\n    const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;\n    const marginRight = convertPrintParameterToInches(margin.right) || 0;\n    const result = await this._client.send('Page.printToPDF', {\n      transferMode: 'ReturnAsStream',\n      landscape,\n      displayHeaderFooter,\n      headerTemplate,\n      footerTemplate,\n      printBackground,\n      scale,\n      paperWidth,\n      paperHeight,\n      marginTop,\n      marginBottom,\n      marginLeft,\n      marginRight,\n      pageRanges,\n      preferCSSPageSize\n    });\n    return await helper_js_1.helper.readProtocolStream(this._client, result.stream, path);\n  }\n\n  async title() {\n    return this.mainFrame().title();\n  }\n\n  async close(options = {\n    runBeforeUnload: undefined\n  }) {\n    assert_js_1.assert(!!this._client._connection, 'Protocol error: Connection closed. Most likely the page has been closed.');\n    const runBeforeUnload = !!options.runBeforeUnload;\n\n    if (runBeforeUnload) {\n      await this._client.send('Page.close');\n    } else {\n      await this._client._connection.send('Target.closeTarget', {\n        targetId: this._target._targetId\n      });\n      await this._target._isClosedPromise;\n    }\n  }\n\n  isClosed() {\n    return this._closed;\n  }\n\n  get mouse() {\n    return this._mouse;\n  }\n\n  click(selector, options = {}) {\n    return this.mainFrame().click(selector, options);\n  }\n\n  focus(selector) {\n    return this.mainFrame().focus(selector);\n  }\n\n  hover(selector) {\n    return this.mainFrame().hover(selector);\n  }\n\n  select(selector, ...values) {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  tap(selector) {\n    return this.mainFrame().tap(selector);\n  }\n\n  type(selector, text, options) {\n    return this.mainFrame().type(selector, text, options);\n  }\n  /**\n   * @remarks\n   *\n   * This method behaves differently depending on the first parameter. If it's a\n   * `string`, it will be treated as a `selector` or `xpath` (if the string\n   * starts with `//`). This method then is a shortcut for\n   * {@link Page.waitForSelector} or {@link Page.waitForXPath}.\n   *\n   * If the first argument is a function this method is a shortcut for\n   * {@link Page.waitForFunction}.\n   *\n   * If the first argument is a `number`, it's treated as a timeout in\n   * milliseconds and the method returns a promise which resolves after the\n   * timeout.\n   *\n   * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n   * wait for.\n   * @param options - optional waiting parameters.\n   * @param args - arguments to pass to `pageFunction`.\n   *\n   * @deprecated Don't use this method directly. Instead use the more explicit\n   * methods available: {@link Page.waitForSelector},\n   * {@link Page.waitForXPath}, {@link Page.waitForFunction} or\n   * {@link Page.waitForTimeout}.\n   */\n\n\n  waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n    return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);\n  }\n  /**\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   *\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Page.waitForSelector}, {@link Page.waitForXPath} or\n   * {@link Page.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```\n   * await page.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n\n\n  waitForTimeout(milliseconds) {\n    return this.mainFrame().waitForTimeout(milliseconds);\n  }\n\n  waitForSelector(selector, options = {}) {\n    return this.mainFrame().waitForSelector(selector, options);\n  }\n\n  waitForXPath(xpath, options = {}) {\n    return this.mainFrame().waitForXPath(xpath, options);\n  }\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n\n}\n\nexports.Page = Page;\nconst supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\nconst unitToPixels = {\n  px: 1,\n  in: 96,\n  cm: 37.8,\n  mm: 3.78\n};\n\nfunction convertPrintParameterToInches(parameter) {\n  if (typeof parameter === 'undefined') return undefined;\n  let pixels;\n\n  if (helper_js_1.helper.isNumber(parameter)) {\n    // Treat numbers as pixel values to be aligned with phantom's paperSize.\n    pixels =\n    /** @type {number} */\n    parameter;\n  } else if (helper_js_1.helper.isString(parameter)) {\n    const text =\n    /** @type {string} */\n    parameter;\n    let unit = text.substring(text.length - 2).toLowerCase();\n    let valueText = '';\n\n    if (unitToPixels.hasOwnProperty(unit)) {\n      valueText = text.substring(0, text.length - 2);\n    } else {\n      // In case of unknown unit try to parse the whole parameter as number of pixels.\n      // This is consistent with phantom's paperSize behavior.\n      unit = 'px';\n      valueText = text;\n    }\n\n    const value = Number(valueText);\n    assert_js_1.assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n    pixels = value * unitToPixels[unit];\n  } else {\n    throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);\n  }\n\n  return pixels / 96;\n}","map":{"version":3,"sources":["../../../../src/common/Page.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;AAEH,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AAKA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAKA,MAAA,UAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAGA,MAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AAEA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAOA,MAAA,kBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,MAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AAWA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAqOA,MAAM,mBAAN,CAAyB;AAGvB,EAAA,WAAA,GAAA;AACE,SAAK,MAAL,GAAc,OAAO,CAAC,OAAR,CAAwC,SAAxC,CAAd;AACD;;AAEM,EAAA,QAAQ,CACb,IADa,EACuB;AAEpC,UAAM,MAAM,GAAG,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAf;;AACA,SAAK,MAAL,GAAc,MAAM,CAAC,KAAP,CAAa,MAAK,CAAG,CAArB,CAAd;AACA,WAAO,MAAP;AACD;;AAbsB;AAgBzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CG;;;AACH,MAAa,IAAb,SAA0B,iBAAA,CAAA,YAA1B,CAAsC;AAuCpC;;AAEG;AACH,EAAA,WAAA,CAAY,MAAZ,EAAgC,MAAhC,EAAgD,iBAAhD,EAA0E;AACxE;AA3BM,SAAA,OAAA,GAAU,KAAV;AAKA,SAAA,gBAAA,GAAmB,IAAI,oBAAA,CAAA,eAAJ,EAAnB;AAMA,SAAA,aAAA,GAAgB,IAAI,GAAJ,EAAhB;AAEA,SAAA,kBAAA,GAAqB,IAArB;AAGA,SAAA,QAAA,GAAW,IAAI,GAAJ,EAAX,CAUkE,CAT1E;AACA;;AACQ,SAAA,wBAAA,GAA2B,IAAI,GAAJ,EAA3B;AASN,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,SAAL,GAAiB,IAAI,UAAA,CAAA,QAAJ,CAAa,MAAb,CAAjB;AACA,SAAK,MAAL,GAAc,IAAI,UAAA,CAAA,KAAJ,CAAU,MAAV,EAAkB,KAAK,SAAvB,CAAd;AACA,SAAK,YAAL,GAAoB,IAAI,UAAA,CAAA,WAAJ,CAAgB,MAAhB,EAAwB,KAAK,SAA7B,CAApB;AACA,SAAK,cAAL,GAAsB,IAAI,kBAAA,CAAA,aAAJ,CAAkB,MAAlB,CAAtB;AACA,SAAK,aAAL,GAAqB,IAAI,iBAAA,CAAA,YAAJ,CACnB,MADmB,EAEnB,IAFmB,EAGnB,iBAHmB,EAInB,KAAK,gBAJc,CAArB;AAMA,SAAK,iBAAL,GAAyB,IAAI,qBAAA,CAAA,gBAAJ,CAAqB,MAArB,CAAzB;AACA,SAAK,QAAL,GAAgB,IAAI,YAAA,CAAA,OAAJ,CAAY,MAAZ,CAAhB;AACA,SAAK,SAAL,GAAiB,IAAI,aAAA,CAAA,QAAJ,CAAa,MAAb,CAAjB;AACA,SAAK,oBAAL,GAA4B,IAAI,mBAAJ,EAA5B;AACA,SAAK,SAAL,GAAiB,IAAjB;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,yBAAV,EAAsC,KAAD,IAAU;AAC7C,UAAI,KAAK,CAAC,UAAN,CAAiB,IAAjB,KAA0B,QAA9B,EAAwC;AACtC;AACA,QAAA,MAAM,CACH,IADH,CACQ,yBADR,EACmC;AAC/B,UAAA,SAAS,EAAE,KAAK,CAAC;AADc,SADnC,EAIG,KAJH,CAIS,WAAA,CAAA,UAJT;AAKA;AACD;;AACD,YAAM,OAAO,GAAG,eAAA,CAAA,UAAA,CAAW,WAAX,CAAuB,MAAvB,EAA+B,OAA/B,CAAuC,KAAK,CAAC,SAA7C,CAAhB;AACA,YAAM,MAAM,GAAG,IAAI,cAAA,CAAA,SAAJ,CACb,OADa,EAEb,KAAK,CAAC,UAAN,CAAiB,GAFJ,EAGb,KAAK,kBAAL,CAAwB,IAAxB,CAA6B,IAA7B,CAHa,EAIb,KAAK,gBAAL,CAAsB,IAAtB,CAA2B,IAA3B,CAJa,CAAf;;AAMA,WAAK,QAAL,CAAc,GAAd,CAAkB,KAAK,CAAC,SAAxB,EAAmC,MAAnC;;AACA,WAAK,IAAL,CAAS;AAAA;AAAT,QAA2C,MAA3C;AACD,KAnBD;AAoBA,IAAA,MAAM,CAAC,EAAP,CAAU,2BAAV,EAAwC,KAAD,IAAU;AAC/C,YAAM,MAAM,GAAG,KAAK,QAAL,CAAc,GAAd,CAAkB,KAAK,CAAC,SAAxB,CAAf;;AACA,UAAI,CAAC,MAAL,EAAa;AACb,WAAK,IAAL,CAAS;AAAA;AAAT,QAA6C,MAA7C;;AACA,WAAK,QAAL,CAAc,MAAd,CAAqB,KAAK,CAAC,SAA3B;AACD,KALD;;AAOA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,iBAAA,CAAA,yBAAA,CAA0B,aAAhD,EAAgE,KAAD,IAC7D,KAAK,IAAL,CAAS;AAAA;AAAT,MAA2C,KAA3C,CADF;;AAGA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,iBAAA,CAAA,yBAAA,CAA0B,aAAhD,EAAgE,KAAD,IAC7D,KAAK,IAAL,CAAS;AAAA;AAAT,MAA2C,KAA3C,CADF;;AAGA,SAAK,aAAL,CAAmB,EAAnB,CAAsB,iBAAA,CAAA,yBAAA,CAA0B,cAAhD,EAAiE,KAAD,IAC9D,KAAK,IAAL,CAAS;AAAA;AAAT,MAA4C,KAA5C,CADF;;AAIA,UAAM,cAAc,GAAG,KAAK,aAAL,CAAmB,cAAnB,EAAvB;;AACA,IAAA,cAAc,CAAC,EAAf,CAAkB,mBAAA,CAAA,2BAAA,CAA4B,OAA9C,EAAwD,KAAD,IACrD,KAAK,IAAL,CAAS;AAAA;AAAT,MAAqC,KAArC,CADF;AAGA,IAAA,cAAc,CAAC,EAAf,CAAkB,mBAAA,CAAA,2BAAA,CAA4B,QAA9C,EAAyD,KAAD,IACtD,KAAK,IAAL,CAAS;AAAA;AAAT,MAAsC,KAAtC,CADF;AAGA,IAAA,cAAc,CAAC,EAAf,CAAkB,mBAAA,CAAA,2BAAA,CAA4B,aAA9C,EAA8D,KAAD,IAC3D,KAAK,IAAL,CAAS;AAAA;AAAT,MAA2C,KAA3C,CADF;AAGA,IAAA,cAAc,CAAC,EAAf,CAAkB,mBAAA,CAAA,2BAAA,CAA4B,eAA9C,EAAgE,KAAD,IAC7D,KAAK,IAAL,CAAS;AAAA;AAAT,MAA6C,KAA7C,CADF;AAGA,SAAK,wBAAL,GAAgC,IAAI,GAAJ,EAAhC;AAEA,IAAA,MAAM,CAAC,EAAP,CAAU,2BAAV,EAAuC,MACrC,KAAK,IAAL,CAAS;AAAA;AAAT,KADF;AAGA,IAAA,MAAM,CAAC,EAAP,CAAU,qBAAV,EAAiC,MAAM,KAAK,IAAL,CAAS;AAAA;AAAT,KAAvC;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,0BAAV,EAAuC,KAAD,IAAW,KAAK,aAAL,CAAmB,KAAnB,CAAjD;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,uBAAV,EAAoC,KAAD,IAAW,KAAK,gBAAL,CAAsB,KAAtB,CAA9C;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,8BAAV,EAA2C,KAAD,IAAW,KAAK,SAAL,CAAe,KAAf,CAArD;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,yBAAV,EAAsC,SAAD,IACnC,KAAK,gBAAL,CAAsB,SAAS,CAAC,gBAAhC,CADF;AAGA,IAAA,MAAM,CAAC,EAAP,CAAU,yBAAV,EAAqC,MAAM,KAAK,gBAAL,EAA3C;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,qBAAV,EAAkC,KAAD,IAAW,KAAK,YAAL,CAAkB,KAAlB,CAA5C;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,gBAAV,EAA6B,KAAD,IAAW,KAAK,gBAAL,CAAsB,KAAtB,CAAvC;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,wBAAV,EAAqC,KAAD,IAAW,KAAK,cAAL,CAAoB,KAApB,CAA/C;;AACA,SAAK,OAAL,CAAa,gBAAb,CAA8B,IAA9B,CAAmC,MAAK;AACtC,WAAK,IAAL,CAAS;AAAA;AAAT;AACA,WAAK,OAAL,GAAe,IAAf;AACD,KAHD;AAID;AAnID;;AAEG;;;AACgB,eAAN,MAAM,CACjB,MADiB,EAEjB,MAFiB,EAGjB,iBAHiB,EAIjB,eAJiB,EAIe;AAEhC,UAAM,IAAI,GAAG,IAAI,IAAJ,CAAS,MAAT,EAAiB,MAAjB,EAAyB,iBAAzB,CAAb;AACA,UAAM,IAAI,CAAC,WAAL,EAAN;AACA,QAAI,eAAJ,EAAqB,MAAM,IAAI,CAAC,WAAL,CAAiB,eAAjB,CAAN;AACrB,WAAO,IAAP;AACD;;AAwHwB,QAAX,WAAW,GAAA;AACvB,UAAM,OAAO,CAAC,GAAR,CAAY,CAChB,KAAK,aAAL,CAAmB,UAAnB,EADgB,EAEhB,KAAK,OAAL,CAAa,IAAb,CAAkB,sBAAlB,EAA0C;AACxC,MAAA,UAAU,EAAE,IAD4B;AAExC,MAAA,sBAAsB,EAAE,KAFgB;AAGxC,MAAA,OAAO,EAAE;AAH+B,KAA1C,CAFgB,EAOhB,KAAK,OAAL,CAAa,IAAb,CAAkB,oBAAlB,CAPgB,EAQhB,KAAK,OAAL,CAAa,IAAb,CAAkB,YAAlB,CARgB,CAAZ,CAAN;AAUD;;AAE2B,QAAd,cAAc,CAC1B,KAD0B,EACiB;AAE3C,QAAI,CAAC,KAAK,wBAAL,CAA8B,IAAnC,EAAyC;;AACzC,UAAM,KAAK,GAAG,KAAK,aAAL,CAAmB,KAAnB,CAAyB,KAAK,CAAC,OAA/B,CAAd;;AACA,UAAM,OAAO,GAAG,MAAM,KAAK,CAAC,gBAAN,EAAtB;AACA,UAAM,OAAO,GAAG,MAAM,OAAO,CAAC,mBAAR,CAA4B,KAAK,CAAC,aAAlC,CAAtB;AACA,UAAM,YAAY,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,wBAAhB,CAArB;;AACA,SAAK,wBAAL,CAA8B,KAA9B;;AACA,UAAM,WAAW,GAAG,IAAI,gBAAA,CAAA,WAAJ,CAAgB,OAAhB,EAAyB,KAAzB,CAApB;;AACA,SAAK,MAAM,WAAX,IAA0B,YAA1B,EAAwC,WAAW,CAAC,IAAZ,CAAiB,IAAjB,EAAuB,WAAvB;AACzC;AAED;;AAEG;;;AACI,EAAA,mBAAmB,GAAA;AACxB,WAAO,KAAK,kBAAZ;AACD;AAED;;;AAGG;;;AACqB,QAAlB,kBAAkB,CACtB,OAAA,GAA8B,EADR,EACU;AAEhC,QAAI,CAAC,KAAK,wBAAL,CAA8B,IAAnC,EACE,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,oCAAlB,EAAwD;AAC5D,MAAA,OAAO,EAAE;AADmD,KAAxD,CAAN;AAIF,UAAM;AAAE,MAAA,OAAO,GAAG,KAAK,gBAAL,CAAsB,OAAtB;AAAZ,QAAgD,OAAtD;AACA,QAAI,QAAJ;AACA,UAAM,OAAO,GAAG,IAAI,OAAJ,CAA0B,CAAD,IAAQ,QAAQ,GAAG,CAA5C,CAAhB;;AACA,SAAK,wBAAL,CAA8B,GAA9B,CAAkC,QAAlC;;AACA,WAAO,WAAA,CAAA,MAAA,CACJ,eADI,CAEH,OAFG,EAGH,0BAHG,EAIH,OAJG,EAMJ,KANI,CAMG,KAAD,IAAU;AACf,WAAK,wBAAL,CAA8B,MAA9B,CAAqC,QAArC;;AACA,YAAM,KAAN;AACD,KATI,CAAP;AAUD;AAED;;;;;;;;;;;AAWG;;;AACiB,QAAd,cAAc,CAAC,OAAD,EAA4B;AAC9C,UAAM;AAAE,MAAA,SAAF;AAAa,MAAA,QAAb;AAAuB,MAAA,QAAQ,GAAG;AAAlC,QAAwC,OAA9C;AACA,QAAI,SAAS,GAAG,CAAC,GAAb,IAAoB,SAAS,GAAG,GAApC,EACE,MAAM,IAAI,KAAJ,CACJ,sBAAsB,SAAS,kDAD3B,CAAN;AAGF,QAAI,QAAQ,GAAG,CAAC,EAAZ,IAAkB,QAAQ,GAAG,EAAjC,EACE,MAAM,IAAI,KAAJ,CACJ,qBAAqB,QAAQ,+CADzB,CAAN;AAGF,QAAI,QAAQ,GAAG,CAAf,EACE,MAAM,IAAI,KAAJ,CACJ,qBAAqB,QAAQ,uCADzB,CAAN;AAGF,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,kCAAlB,EAAsD;AAC1D,MAAA,SAD0D;AAE1D,MAAA,QAF0D;AAG1D,MAAA;AAH0D,KAAtD,CAAN;AAKD;AAED;;AAEG;;;AACH,EAAA,MAAM,GAAA;AACJ,WAAO,KAAK,OAAZ;AACD;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,OAAL,CAAa,OAAb,EAAP;AACD;AAED;;AAEG;;;AACH,EAAA,cAAc,GAAA;AACZ,WAAO,KAAK,OAAL,CAAa,cAAb,EAAP;AACD;;AAEO,EAAA,gBAAgB,GAAA;AACtB,SAAK,IAAL,CAAU,OAAV,EAAmB,IAAI,KAAJ,CAAU,eAAV,CAAnB;AACD;;AAEO,EAAA,gBAAgB,CAAC,KAAD,EAAoC;AAC1D,UAAM;AAAE,MAAA,KAAF;AAAS,MAAA,IAAT;AAAe,MAAA,IAAf;AAAqB,MAAA,MAArB;AAA6B,MAAA,GAA7B;AAAkC,MAAA;AAAlC,QAAiD,KAAK,CAAC,KAA7D;AACA,QAAI,IAAJ,EAAU,IAAI,CAAC,GAAL,CAAU,GAAD,IAAS,WAAA,CAAA,MAAA,CAAO,aAAP,CAAqB,KAAK,OAA1B,EAAmC,GAAnC,CAAlB;AACV,QAAI,MAAM,KAAK,QAAf,EACE,KAAK,IAAL,CAAS;AAAA;AAAT,MAEE,IAAI,mBAAA,CAAA,cAAJ,CAAmB,KAAnB,EAA0B,IAA1B,EAAgC,EAAhC,EAAoC,CAAC;AAAE,MAAA,GAAF;AAAO,MAAA;AAAP,KAAD,CAApC,CAFF;AAIH;AAED;;AAEG;;;AACH,EAAA,SAAS,GAAA;AACP,WAAO,KAAK,aAAL,CAAmB,SAAnB,EAAP;AACD;;AAEW,MAAR,QAAQ,GAAA;AACV,WAAO,KAAK,SAAZ;AACD;;AAEc,MAAX,WAAW,GAAA;AACb,WAAO,KAAK,YAAZ;AACD;;AAEW,MAAR,QAAQ,GAAA;AACV,WAAO,KAAK,SAAZ;AACD;;AAEU,MAAP,OAAO,GAAA;AACT,WAAO,KAAK,QAAZ;AACD;;AAEgB,MAAb,aAAa,GAAA;AACf,WAAO,KAAK,cAAZ;AACD;AAED;;AAEG;;;AACH,EAAA,MAAM,GAAA;AACJ,WAAO,KAAK,aAAL,CAAmB,MAAnB,EAAP;AACD;AAED;;;;AAIG;;;AACH,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,CAAC,IAAN,CAAW,KAAK,QAAL,CAAc,MAAd,EAAX,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCG;;;AACyB,QAAtB,sBAAsB,CAAC,KAAD,EAAe;AACzC,WAAO,KAAK,aAAL,CAAmB,cAAnB,GAAoC,sBAApC,CAA2D,KAA3D,CAAP;AACD;AAED;;AAEG;;;AACH,EAAA,cAAc,CAAC,OAAD,EAAiB;AAC7B,WAAO,KAAK,aAAL,CAAmB,cAAnB,GAAoC,cAApC,CAAmD,OAAnD,CAAP;AACD;;AAED,EAAA,wBAAwB,CACtB,iBADsB,EACqB;AAE3C,WAAO,KAAK,aAAL,CACJ,cADI,GAEJ,wBAFI,CAEqB,iBAFrB,CAAP;AAGD;AAED;;AAEG;;;AACH,EAAA,2BAA2B,CAAC,OAAD,EAAgB;AACzC,SAAK,gBAAL,CAAsB,2BAAtB,CAAkD,OAAlD;AACD;AAED;;AAEG;;;AACH,EAAA,iBAAiB,CAAC,OAAD,EAAgB;AAC/B,SAAK,gBAAL,CAAsB,iBAAtB,CAAwC,OAAxC;AACD;AAED;;;;;;;;;;AAUG;;;AACI,QAAD,CAAC,CAAC,QAAD,EAAiB;AACtB,WAAO,KAAK,SAAL,GAAiB,CAAjB,CAAmB,QAAnB,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDG;;;AACiB,QAAd,cAAc,CAClB,YADkB,EAElB,GAAG,IAFe,EAEe;AAEjC,UAAM,OAAO,GAAG,MAAM,KAAK,SAAL,GAAiB,gBAAjB,EAAtB;AACA,WAAO,OAAO,CAAC,cAAR,CAAoC,YAApC,EAAkD,GAAG,IAArD,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;AAqBG;;;AACe,QAAZ,YAAY,CAAC,eAAD,EAA0B;AAC1C,UAAM,OAAO,GAAG,MAAM,KAAK,SAAL,GAAiB,gBAAjB,EAAtB;AACA,WAAO,OAAO,CAAC,YAAR,CAAqB,eAArB,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDG;;;AACQ,QAAL,KAAK,CACT,QADS,EAET,YAFS,EAgBT,GAAG,IAhBM,EAgBwB;AAEjC,WAAO,KAAK,SAAL,GAAiB,KAAjB,CAAmC,QAAnC,EAA6C,YAA7C,EAA2D,GAAG,IAA9D,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6DG;;;AACS,QAAN,MAAM,CACV,QADU,EAEV,YAFU,EAUV,GAAG,IAVO,EAUuB;AAEjC,WAAO,KAAK,SAAL,GAAiB,MAAjB,CAAoC,QAApC,EAA8C,YAA9C,EAA4D,GAAG,IAA/D,CAAP;AACD;;AAEO,QAAF,EAAE,CAAC,QAAD,EAAiB;AACvB,WAAO,KAAK,SAAL,GAAiB,EAAjB,CAAoB,QAApB,CAAP;AACD;;AAEO,QAAF,EAAE,CAAC,UAAD,EAAmB;AACzB,WAAO,KAAK,SAAL,GAAiB,EAAjB,CAAoB,UAApB,CAAP;AACD;AAED;;;AAGG;;;AACU,QAAP,OAAO,CAAC,GAAG,IAAJ,EAAkB;AAC7B,UAAM,eAAe,GAAG,CACtB,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,oBAAlB,EAAwC;AAC5C,MAAA,IAAI,EAAE,IAAI,CAAC,MAAL,GAAc,IAAd,GAAqB,CAAC,KAAK,GAAL,EAAD;AADiB,KAAxC,CADgB,EAItB,OAJF;AAMA,UAAM,2BAA2B,GAAG,CAAC,UAAD,CAApC;;AACA,UAAM,2BAA2B,GAC/B,MADkC,IAEP;AAC3B,WAAK,MAAM,IAAX,IAAmB,2BAAnB,EAAgD,OAAO,MAAM,CAAC,IAAD,CAAb;;AAChD,aAAO,MAAP;AACD,KALD;;AAMA,WAAO,eAAe,CAAC,GAAhB,CAAoB,2BAApB,CAAP;AACD;;AAEiB,QAAZ,YAAY,CAChB,GAAG,OADa,EACmC;AAEnD,UAAM,OAAO,GAAG,KAAK,GAAL,EAAhB;;AACA,SAAK,MAAM,MAAX,IAAqB,OAArB,EAA8B;AAC5B,YAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,MAAlB,CAAb;AACA,UAAI,CAAC,MAAM,CAAC,GAAR,IAAe,OAAO,CAAC,UAAR,CAAmB,MAAnB,CAAnB,EAA+C,IAAI,CAAC,GAAL,GAAW,OAAX;AAC/C,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,uBAAlB,EAA2C,IAA3C,CAAN;AACD;AACF;;AAEc,QAAT,SAAS,CAAC,GAAG,OAAJ,EAA2C;AACxD,UAAM,OAAO,GAAG,KAAK,GAAL,EAAhB;AACA,UAAM,cAAc,GAAG,OAAO,CAAC,UAAR,CAAmB,MAAnB,CAAvB;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,GAAR,CAAa,MAAD,IAAW;AACnC,YAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,MAAlB,CAAb;AACA,UAAI,CAAC,IAAI,CAAC,GAAN,IAAa,cAAjB,EAAiC,IAAI,CAAC,GAAL,GAAW,OAAX;AACjC,MAAA,WAAA,CAAA,MAAA,CACE,IAAI,CAAC,GAAL,KAAa,aADf,EAEE,mCAAmC,IAAI,CAAC,IAAI,GAF9C;AAIA,MAAA,WAAA,CAAA,MAAA,CACE,CAAC,MAAM,CAAC,SAAP,CAAiB,UAAjB,CAA4B,IAA5B,CAAiC,IAAI,CAAC,GAAL,IAAY,EAA7C,EAAiD,OAAjD,CADH,EAEE,sCAAsC,IAAI,CAAC,IAAI,GAFjD;AAIA,aAAO,IAAP;AACD,KAZa,CAAd;AAaA,UAAM,KAAK,YAAL,CAAkB,GAAG,KAArB,CAAN;AACA,QAAI,KAAK,CAAC,MAAV,EACE,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,oBAAlB,EAAwC;AAAE,MAAA,OAAO,EAAE;AAAX,KAAxC,CAAN;AACH;;AAEiB,QAAZ,YAAY,CAAC,OAAD,EAKjB;AACC,WAAO,KAAK,SAAL,GAAiB,YAAjB,CAA8B,OAA9B,CAAP;AACD;;AAEgB,QAAX,WAAW,CAAC,OAAD,EAIhB;AACC,WAAO,KAAK,SAAL,GAAiB,WAAjB,CAA6B,OAA7B,CAAP;AACD;;AAEmB,QAAd,cAAc,CAClB,IADkB,EAElB,iBAFkB,EAES;AAE3B,QAAI,KAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,CAAJ,EACE,MAAM,IAAI,KAAJ,CACJ,wCAAwC,IAAI,aAAa,IAAI,oBADzD,CAAN;;AAGF,SAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,EAA6B,iBAA7B;;AAEA,UAAM,UAAU,GAAG,WAAA,CAAA,MAAA,CAAO,qBAAP,CAA6B,YAA7B,EAA2C,IAA3C,CAAnB;AACA,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,oBAAlB,EAAwC;AAAE,MAAA,IAAI,EAAE;AAAR,KAAxC,CAAN;AACA,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,uCAAlB,EAA2D;AAC/D,MAAA,MAAM,EAAE;AADuD,KAA3D,CAAN;AAGA,UAAM,OAAO,CAAC,GAAR,CACJ,KAAK,MAAL,GAAc,GAAd,CAAmB,KAAD,IAAW,KAAK,CAAC,QAAN,CAAe,UAAf,EAA2B,KAA3B,CAAiC,WAAA,CAAA,UAAjC,CAA7B,CADI,CAAN;AAGD;;AAEiB,QAAZ,YAAY,CAAC,WAAD,EAAyB;AACzC,WAAO,KAAK,aAAL,CAAmB,cAAnB,GAAoC,YAApC,CAAiD,WAAjD,CAAP;AACD;;AAEwB,QAAnB,mBAAmB,CAAC,OAAD,EAAgC;AACvD,WAAO,KAAK,aAAL,CAAmB,cAAnB,GAAoC,mBAApC,CAAwD,OAAxD,CAAP;AACD;;AAEiB,QAAZ,YAAY,CAAC,SAAD,EAAkB;AAClC,WAAO,KAAK,aAAL,CAAmB,cAAnB,GAAoC,YAApC,CAAiD,SAAjD,CAAP;AACD;;AAEY,QAAP,OAAO,GAAA;AACX,UAAM,QAAQ,GAAG,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,wBAAlB,CAAvB;AACA,WAAO,KAAK,mBAAL,CAAyB,QAAQ,CAAC,OAAlC,CAAP;AACD;;AAEO,EAAA,YAAY,CAAC,KAAD,EAAyC;AAC3D,SAAK,IAAL,CAAS;AAAA;AAAT,MAAqC;AACnC,MAAA,KAAK,EAAE,KAAK,CAAC,KADsB;AAEnC,MAAA,OAAO,EAAE,KAAK,mBAAL,CAAyB,KAAK,CAAC,OAA/B;AAF0B,KAArC;AAID;;AAEO,EAAA,mBAAmB,CACzB,OADyB,EACc;AAEvC,UAAM,MAAM,GAAG,EAAf;;AACA,SAAK,MAAM,MAAX,IAAqB,OAAO,IAAI,EAAhC,EAAoC;AAClC,UAAI,gBAAgB,CAAC,GAAjB,CAAqB,MAAM,CAAC,IAA5B,CAAJ,EAAuC,MAAM,CAAC,MAAM,CAAC,IAAR,CAAN,GAAsB,MAAM,CAAC,KAA7B;AACxC;;AACD,WAAO,MAAP;AACD;;AAEO,EAAA,gBAAgB,CACtB,gBADsB,EAC6B;AAEnD,UAAM,OAAO,GAAG,WAAA,CAAA,MAAA,CAAO,mBAAP,CAA2B,gBAA3B,CAAhB;AACA,UAAM,GAAG,GAAG,IAAI,KAAJ,CAAU,OAAV,CAAZ;AACA,IAAA,GAAG,CAAC,KAAJ,GAAY,EAAZ,CAJmD,CAInC;;AAChB,SAAK,IAAL,CAAS;AAAA;AAAT,MAAuC,GAAvC;AACD;;AAE0B,QAAb,aAAa,CACzB,KADyB,EACoB;AAE7C,QAAI,KAAK,CAAC,kBAAN,KAA6B,CAAjC,EAAoC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AACD,UAAM,OAAO,GAAG,KAAK,aAAL,CAAmB,oBAAnB,CACd,KAAK,CAAC,kBADQ,CAAhB;;AAGA,UAAM,MAAM,GAAG,KAAK,CAAC,IAAN,CAAW,GAAX,CAAgB,GAAD,IAAS,aAAA,CAAA,cAAA,CAAe,OAAf,EAAwB,GAAxB,CAAxB,CAAf;;AACA,SAAK,kBAAL,CAAwB,KAAK,CAAC,IAA9B,EAAoC,MAApC,EAA4C,KAAK,CAAC,UAAlD;AACD;;AAE6B,QAAhB,gBAAgB,CAC5B,KAD4B,EACc;AAE1C,QAAI,OAAJ;;AACA,QAAI;AACF,MAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,OAAjB,CAAV;AACD,KAFD,CAEE,MAAM;AACN;AACA;AACA;AACD;;AACD,UAAM;AAAE,MAAA,IAAF;AAAQ,MAAA,IAAR;AAAc,MAAA,GAAd;AAAmB,MAAA;AAAnB,QAA4B,OAAlC;AACA,QAAI,IAAI,KAAK,YAAT,IAAyB,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,CAA9B,EAA4D;AAC5D,QAAI,UAAU,GAAG,IAAjB;;AACA,QAAI;AACF,YAAM,MAAM,GAAG,MAAM,KAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,EAA6B,GAAG,IAAhC,CAArB;AACA,MAAA,UAAU,GAAG,WAAA,CAAA,MAAA,CAAO,8BAAP,CAAsC,IAAtC,EAA4C,GAA5C,EAAiD,MAAjD,CAAb;AACD,KAHD,CAGE,OAAO,KAAP,EAAc;AACd,UAAI,KAAK,YAAY,KAArB,EACE,UAAU,GAAG,WAAA,CAAA,MAAA,CAAO,6BAAP,CACX,IADW,EAEX,GAFW,EAGX,KAAK,CAAC,OAHK,EAIX,KAAK,CAAC,KAJK,CAAb,CADF,KAQE,UAAU,GAAG,WAAA,CAAA,MAAA,CAAO,kCAAP,CACX,IADW,EAEX,GAFW,EAGX,KAHW,CAAb;AAKH;;AACD,SAAK,OAAL,CACG,IADH,CACQ,kBADR,EAC4B;AACxB,MAAA,UADwB;AAExB,MAAA,SAAS,EAAE,KAAK,CAAC;AAFO,KAD5B,EAKG,KALH,CAKS,WAAA,CAAA,UALT;AAMD;;AAEO,EAAA,kBAAkB,CACxB,IADwB,EAExB,IAFwB,EAGxB,UAHwB,EAGgB;AAExC,QAAI,CAAC,KAAK,aAAL,CAAkB;AAAA;AAAlB,KAAL,EAAoD;AAClD,MAAA,IAAI,CAAC,OAAL,CAAc,GAAD,IAAS,GAAG,CAAC,OAAJ,EAAtB;AACA;AACD;;AACD,UAAM,UAAU,GAAG,EAAnB;;AACA,SAAK,MAAM,GAAX,IAAkB,IAAlB,EAAwB;AACtB,YAAM,YAAY,GAAG,GAAG,CAAC,aAAzB;AACA,UAAI,YAAY,CAAC,QAAjB,EAA2B,UAAU,CAAC,IAAX,CAAgB,GAAG,CAAC,QAAJ,EAAhB,EAA3B,KACK,UAAU,CAAC,IAAX,CAAgB,WAAA,CAAA,MAAA,CAAO,qBAAP,CAA6B,YAA7B,CAAhB;AACN;;AACD,UAAM,mBAAmB,GAAG,EAA5B;;AACA,QAAI,UAAJ,EAAgB;AACd,WAAK,MAAM,SAAX,IAAwB,UAAU,CAAC,UAAnC,EAA+C;AAC7C,QAAA,mBAAmB,CAAC,IAApB,CAAyB;AACvB,UAAA,GAAG,EAAE,SAAS,CAAC,GADQ;AAEvB,UAAA,UAAU,EAAE,SAAS,CAAC,UAFC;AAGvB,UAAA,YAAY,EAAE,SAAS,CAAC;AAHD,SAAzB;AAKD;AACF;;AACD,UAAM,OAAO,GAAG,IAAI,mBAAA,CAAA,cAAJ,CACd,IADc,EAEd,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAFc,EAGd,IAHc,EAId,mBAJc,CAAhB;AAMA,SAAK,IAAL,CAAS;AAAA;AAAT,MAAqC,OAArC;AACD;;AAEO,EAAA,SAAS,CAAC,KAAD,EAAkD;AACjE,QAAI,UAAU,GAAG,IAAjB;AACA,UAAM,gBAAgB,GAAG,IAAI,GAAJ,CAAkC,CACzD,OADyD,EAEzD,SAFyD,EAGzD,QAHyD,EAIzD,cAJyD,CAAlC,CAAzB;;AAOA,QAAI,gBAAgB,CAAC,GAAjB,CAAqB,KAAK,CAAC,IAA3B,CAAJ,EAAsC;AACpC,MAAA,UAAU,GAAG,KAAK,CAAC,IAAnB;AACD;;AACD,IAAA,WAAA,CAAA,MAAA,CAAO,UAAP,EAAmB,qCAAqC,KAAK,CAAC,IAA9D;AAEA,UAAM,MAAM,GAAG,IAAI,WAAA,CAAA,MAAJ,CACb,KAAK,OADQ,EAEb,UAFa,EAGb,KAAK,CAAC,OAHO,EAIb,KAAK,CAAC,aAJO,CAAf;AAMA,SAAK,IAAL,CAAS;AAAA;AAAT,MAAoC,MAApC;AACD;;AAED,EAAA,GAAG,GAAA;AACD,WAAO,KAAK,SAAL,GAAiB,GAAjB,EAAP;AACD;;AAEY,QAAP,OAAO,GAAA;AACX,WAAO,MAAM,KAAK,aAAL,CAAmB,SAAnB,GAA+B,OAA/B,EAAb;AACD;;AAEe,QAAV,UAAU,CAAC,IAAD,EAAe,OAAA,GAA0B,EAAzC,EAA2C;AACzD,UAAM,KAAK,aAAL,CAAmB,SAAnB,GAA+B,UAA/B,CAA0C,IAA1C,EAAgD,OAAhD,CAAN;AACD;;AAES,QAAJ,IAAI,CACR,GADQ,EAER,OAAA,GAAiD,EAFzC,EAE2C;AAEnD,WAAO,MAAM,KAAK,aAAL,CAAmB,SAAnB,GAA+B,IAA/B,CAAoC,GAApC,EAAyC,OAAzC,CAAb;AACD;;AAEW,QAAN,MAAM,CAAC,OAAD,EAAyB;AACnC,UAAM,MAAM,GAAG,MAAM,OAAO,CAAC,GAAR,CAAgC,CACnD,KAAK,iBAAL,CAAuB,OAAvB,CADmD,EAEnD,KAAK,OAAL,CAAa,IAAb,CAAkB,aAAlB,CAFmD,CAAhC,CAArB;AAKA,WAAO,MAAM,CAAC,CAAD,CAAb;AACD;;AAEsB,QAAjB,iBAAiB,CACrB,OAAA,GAA0B,EADL,EACO;AAE5B,WAAO,MAAM,KAAK,aAAL,CAAmB,SAAnB,GAA+B,iBAA/B,CAAiD,OAAjD,CAAb;AACD;;AAEO,EAAA,oBAAoB,GAAA;AAC1B,QAAI,CAAC,KAAK,kBAAV,EACE,KAAK,kBAAL,GAA0B,IAAI,OAAJ,CAAa,OAAD,IACpC,KAAK,OAAL,CAAa,IAAb,CAAkB,eAAA,CAAA,uBAAA,CAAwB,YAA1C,EAAwD,MACtD,OAAO,CAAC,IAAI,KAAJ,CAAU,eAAV,CAAD,CADT,CADwB,CAA1B;AAKF,WAAO,KAAK,kBAAZ;AACD;;AAEmB,QAAd,cAAc,CAClB,cADkB,EAElB,OAAA,GAAgC,EAFd,EAEgB;AAElC,UAAM;AAAE,MAAA,OAAO,GAAG,KAAK,gBAAL,CAAsB,OAAtB;AAAZ,QAAgD,OAAtD;AACA,WAAO,WAAA,CAAA,MAAA,CAAO,YAAP,CACL,KAAK,aAAL,CAAmB,cAAnB,EADK,EAEL,mBAAA,CAAA,2BAAA,CAA4B,OAFvB,EAGJ,OAAD,IAAY;AACV,UAAI,WAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,cAAhB,CAAJ,EACE,OAAO,cAAc,KAAK,OAAO,CAAC,GAAR,EAA1B;AACF,UAAI,OAAO,cAAP,KAA0B,UAA9B,EACE,OAAO,CAAC,CAAC,cAAc,CAAC,OAAD,CAAvB;AACF,aAAO,KAAP;AACD,KATI,EAUL,OAVK,EAWL,KAAK,oBAAL,EAXK,CAAP;AAaD;;AAEoB,QAAf,eAAe,CACnB,cADmB,EAEnB,OAAA,GAAgC,EAFb,EAEe;AAElC,UAAM;AAAE,MAAA,OAAO,GAAG,KAAK,gBAAL,CAAsB,OAAtB;AAAZ,QAAgD,OAAtD;AACA,WAAO,WAAA,CAAA,MAAA,CAAO,YAAP,CACL,KAAK,aAAL,CAAmB,cAAnB,EADK,EAEL,mBAAA,CAAA,2BAAA,CAA4B,QAFvB,EAGL,MAAO,QAAP,IAAmB;AACjB,UAAI,WAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,cAAhB,CAAJ,EACE,OAAO,cAAc,KAAK,QAAQ,CAAC,GAAT,EAA1B;AACF,UAAI,OAAO,cAAP,KAA0B,UAA9B,EACE,OAAO,CAAC,EAAE,MAAM,cAAc,CAAC,QAAD,CAAtB,CAAR;AACF,aAAO,KAAP;AACD,KATI,EAUL,OAVK,EAWL,KAAK,oBAAL,EAXK,CAAP;AAaD;;AAEW,QAAN,MAAM,CAAC,OAAA,GAA0B,EAA3B,EAA6B;AACvC,WAAO,KAAK,GAAL,CAAS,CAAC,CAAV,EAAa,OAAb,CAAP;AACD;;AAEc,QAAT,SAAS,CAAC,OAAA,GAA0B,EAA3B,EAA6B;AAC1C,WAAO,KAAK,GAAL,CAAS,CAAC,CAAV,EAAa,OAAb,CAAP;AACD;;AAEgB,QAAH,GAAG,CACf,KADe,EAEf,OAFe,EAEQ;AAEvB,UAAM,OAAO,GAAG,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,2BAAlB,CAAtB;AACA,UAAM,KAAK,GAAG,OAAO,CAAC,OAAR,CAAgB,OAAO,CAAC,YAAR,GAAuB,KAAvC,CAAd;AACA,QAAI,CAAC,KAAL,EAAY,OAAO,IAAP;AACZ,UAAM,MAAM,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,CAC/B,KAAK,iBAAL,CAAuB,OAAvB,CAD+B,EAE/B,KAAK,OAAL,CAAa,IAAb,CAAkB,6BAAlB,EAAiD;AAAE,MAAA,OAAO,EAAE,KAAK,CAAC;AAAjB,KAAjD,CAF+B,CAAZ,CAArB;AAIA,WAAO,MAAM,CAAC,CAAD,CAAb;AACD;;AAEiB,QAAZ,YAAY,GAAA;AAChB,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,mBAAlB,CAAN;AACD;;AAEY,QAAP,OAAO,CAAC,OAAD,EAGZ;AACC,UAAM,OAAO,CAAC,GAAR,CAAY,CAChB,KAAK,WAAL,CAAiB,OAAO,CAAC,QAAzB,CADgB,EAEhB,KAAK,YAAL,CAAkB,OAAO,CAAC,SAA1B,CAFgB,CAAZ,CAAN;AAID;;AAEyB,QAApB,oBAAoB,CAAC,OAAD,EAAiB;AACzC,QAAI,KAAK,kBAAL,KAA4B,OAAhC,EAAyC;AACzC,SAAK,kBAAL,GAA0B,OAA1B;AACA,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,sCAAlB,EAA0D;AAC9D,MAAA,KAAK,EAAE,CAAC;AADsD,KAA1D,CAAN;AAGD;;AAEiB,QAAZ,YAAY,CAAC,OAAD,EAAiB;AACjC,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,mBAAlB,EAAuC;AAAE,MAAA;AAAF,KAAvC,CAAN;AACD;;AAEqB,QAAhB,gBAAgB,CAAC,IAAD,EAAc;AAClC,IAAA,WAAA,CAAA,MAAA,CACE,IAAI,KAAK,QAAT,IAAqB,IAAI,KAAK,OAA9B,IAAyC,IAAI,KAAK,IADpD,EAEE,6BAA6B,IAF/B;AAIA,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,4BAAlB,EAAgD;AACpD,MAAA,KAAK,EAAE,IAAI,IAAI;AADqC,KAAhD,CAAN;AAGD;;AAEyB,QAApB,oBAAoB,CAAC,QAAD,EAA0B;AAClD,QAAI,QAAQ,KAAK,IAAjB,EACE,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,4BAAlB,EAAgD;AAAE,MAAA,QAAQ,EAAE;AAAZ,KAAhD,CAAN;;AACF,QAAI,KAAK,CAAC,OAAN,CAAc,QAAd,CAAJ,EAA6B;AAC3B,MAAA,QAAQ,CAAC,KAAT,CAAgB,YAAD,IAAiB;AAC9B,cAAM,IAAI,GAAG,YAAY,CAAC,IAA1B;AACA,QAAA,WAAA,CAAA,MAAA,CACE,4CAA4C,IAA5C,CAAiD,IAAjD,CADF,EAEE,gCAAgC,IAFlC;AAIA,eAAO,IAAP;AACD,OAPD;AAQA,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,4BAAlB,EAAgD;AACpD,QAAA,QAAQ,EAAE;AAD0C,OAAhD,CAAN;AAGD;AACF;;AAEoB,QAAf,eAAe,CAAC,UAAD,EAAoB;AACvC,QAAI;AACF,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,+BAAlB,EAAmD;AACvD,QAAA,UAAU,EAAE,UAAU,IAAI;AAD6B,OAAnD,CAAN;AAGD,KAJD,CAIE,OAAO,KAAP,EAAc;AACd,UAAI,KAAK,CAAC,OAAN,CAAc,QAAd,CAAuB,kBAAvB,CAAJ,EACE,MAAM,IAAI,KAAJ,CAAU,wBAAwB,UAAU,EAA5C,CAAN;AACF,YAAM,KAAN;AACD;AACF;AAED;;;;;;;;;;;;;;;;;;;AAmBG;;;AACmB,QAAhB,gBAAgB,CAAC,SAAD,EAGrB;AACC,QAAI,SAAJ,EAAe;AACb,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,2BAAlB,EAA+C;AACnD,QAAA,YAAY,EAAE,SAAS,CAAC,YAD2B;AAEnD,QAAA,gBAAgB,EAAE,SAAS,CAAC;AAFuB,OAA/C,CAAN;AAID,KALD,MAKO;AACL,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,6BAAlB,CAAN;AACD;AACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BG;;;AAC0B,QAAvB,uBAAuB,CAC3B,IAD2B,EACyC;AAEpE,UAAM,kBAAkB,GAAG,IAAI,GAAJ,CAEzB,CACA,MADA,EAEA,eAFA,EAGA,eAHA,EAIA,cAJA,EAKA,YALA,EAMA,YANA,CAFyB,CAA3B;;AAUA,QAAI;AACF,MAAA,WAAA,CAAA,MAAA,CACE,CAAC,IAAD,IAAS,kBAAkB,CAAC,GAAnB,CAAuB,IAAvB,CADX,EAEE,kCAAkC,IAAI,EAFxC;AAIA,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,uCAAlB,EAA2D;AAC/D,QAAA,IAAI,EAAE,IAAI,IAAI;AADiD,OAA3D,CAAN;AAGD,KARD,CAQE,OAAO,KAAP,EAAc;AACd,YAAM,KAAN;AACD;AACF;;AAEgB,QAAX,WAAW,CAAC,QAAD,EAAmB;AAClC,UAAM,WAAW,GAAG,MAAM,KAAK,iBAAL,CAAuB,eAAvB,CAAuC,QAAvC,CAA1B;AACA,SAAK,SAAL,GAAiB,QAAjB;AACA,QAAI,WAAJ,EAAiB,MAAM,KAAK,MAAL,EAAN;AAClB;;AAED,EAAA,QAAQ,GAAA;AACN,WAAO,KAAK,SAAZ;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CG;;;AACW,QAAR,QAAQ,CACZ,YADY,EAEZ,GAAG,IAFS,EAEqB;AAEjC,WAAO,KAAK,aAAL,CAAmB,SAAnB,GAA+B,QAA/B,CAA2C,YAA3C,EAAyD,GAAG,IAA5D,CAAP;AACD;;AAE0B,QAArB,qBAAqB,CACzB,YADyB,EAEzB,GAAG,IAFsB,EAEP;AAElB,UAAM,MAAM,GAAG,WAAA,CAAA,MAAA,CAAO,gBAAP,CAAwB,YAAxB,EAAsC,GAAG,IAAzC,CAAf;AACA,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,uCAAlB,EAA2D;AAC/D,MAAA;AAD+D,KAA3D,CAAN;AAGD;;AAEoB,QAAf,eAAe,CAAC,OAAO,GAAG,IAAX,EAAe;AAClC,UAAM,KAAK,aAAL,CAAmB,cAAnB,GAAoC,eAApC,CAAoD,OAApD,CAAN;AACD;;AAEe,QAAV,UAAU,CACd,OAAA,GAA6B,EADf,EACiB;AAE/B,QAAI,cAAc,GAAG,IAArB,CAF+B,CAG/B;AACA;AACA;;AACA,QAAI,OAAO,CAAC,IAAZ,EAAkB;AAChB,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,CAAC,IAAR,KAAiB,KAAjB,IAA0B,OAAO,CAAC,IAAR,KAAiB,MAD7C,EAEE,iCAAiC,OAAO,CAAC,IAF3C;AAIA,MAAA,cAAc,GAAG,OAAO,CAAC,IAAzB;AACD,KAND,MAMO,IAAI,OAAO,CAAC,IAAZ,EAAkB;AACvB,YAAM,QAAQ,GAAG,OAAO,CAAC,IAAzB;AACA,YAAM,SAAS,GAAG,QAAQ,CACvB,KADe,CACT,QAAQ,CAAC,WAAT,CAAqB,GAArB,IAA4B,CADnB,EAEf,WAFe,EAAlB;AAGA,UAAI,SAAS,KAAK,KAAlB,EAAyB,cAAc,GAAG,KAAjB,CAAzB,KACK,IAAI,SAAS,KAAK,KAAd,IAAuB,SAAS,KAAK,MAAzC,EACH,cAAc,GAAG,MAAjB;AACF,MAAA,WAAA,CAAA,MAAA,CACE,cADF,EAEE,gDAAgD,SAAS,IAF3D;AAID;;AAED,QAAI,CAAC,cAAL,EAAqB,cAAc,GAAG,KAAjB;;AAErB,QAAI,OAAO,CAAC,OAAZ,EAAqB;AACnB,MAAA,WAAA,CAAA,MAAA,CACE,cAAc,KAAK,MADrB,EAEE,4CACE,cADF,GAEE,cAJJ;AAMA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,OAAO,CAAC,OAAf,KAA2B,QAD7B,EAEE,uDACE,OAAO,OAAO,CAAC,OAHnB;AAKA,MAAA,WAAA,CAAA,MAAA,CACE,MAAM,CAAC,SAAP,CAAiB,OAAO,CAAC,OAAzB,CADF,EAEE,2CAFF;AAIA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,CAAC,OAAR,IAAmB,CAAnB,IAAwB,OAAO,CAAC,OAAR,IAAmB,GAD7C,EAEE,uEACE,OAAO,CAAC,OAHZ;AAKD;;AACD,IAAA,WAAA,CAAA,MAAA,CACE,CAAC,OAAO,CAAC,IAAT,IAAiB,CAAC,OAAO,CAAC,QAD5B,EAEE,iDAFF;;AAIA,QAAI,OAAO,CAAC,IAAZ,EAAkB;AAChB,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,OAAO,CAAC,IAAR,CAAa,CAApB,KAA0B,QAD5B,EAEE,sDACE,OAAO,OAAO,CAAC,IAAR,CAAa,CAHxB;AAKA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,OAAO,CAAC,IAAR,CAAa,CAApB,KAA0B,QAD5B,EAEE,sDACE,OAAO,OAAO,CAAC,IAAR,CAAa,CAHxB;AAKA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,OAAO,CAAC,IAAR,CAAa,KAApB,KAA8B,QADhC,EAEE,0DACE,OAAO,OAAO,CAAC,IAAR,CAAa,KAHxB;AAKA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,OAAO,CAAC,IAAR,CAAa,MAApB,KAA+B,QADjC,EAEE,2DACE,OAAO,OAAO,CAAC,IAAR,CAAa,MAHxB;AAKA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,CAAC,IAAR,CAAa,KAAb,KAAuB,CADzB,EAEE,0CAFF;AAIA,MAAA,WAAA,CAAA,MAAA,CACE,OAAO,CAAC,IAAR,CAAa,MAAb,KAAwB,CAD1B,EAEE,2CAFF;AAID;;AACD,WAAO,KAAK,oBAAL,CAA0B,QAA1B,CAAmC,MACxC,KAAK,eAAL,CAAqB,cAArB,EAAqC,OAArC,CADK,CAAP;AAGD;;AAE4B,QAAf,eAAe,CAC3B,MAD2B,EAE3B,OAF2B,EAEA;AAE3B,UAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,uBAAlB,EAA2C;AAC/C,MAAA,QAAQ,EAAE,KAAK,OAAL,CAAa;AADwB,KAA3C,CAAN;AAGA,QAAI,IAAI,GAAG,OAAO,CAAC,IAAR,GAAe,WAAW,CAAC,OAAO,CAAC,IAAT,CAA1B,GAA2C,SAAtD;;AAEA,QAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,YAAM,OAAO,GAAG,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,uBAAlB,CAAtB;AACA,YAAM,KAAK,GAAG,IAAI,CAAC,IAAL,CAAU,OAAO,CAAC,WAAR,CAAoB,KAA9B,CAAd;AACA,YAAM,MAAM,GAAG,IAAI,CAAC,IAAL,CAAU,OAAO,CAAC,WAAR,CAAoB,MAA9B,CAAf,CAHoB,CAKpB;;AACA,MAAA,IAAI,GAAG;AAAE,QAAA,CAAC,EAAE,CAAL;AAAQ,QAAA,CAAC,EAAE,CAAX;AAAc,QAAA,KAAd;AAAqB,QAAA,MAArB;AAA6B,QAAA,KAAK,EAAE;AAApC,OAAP;AACD;;AACD,UAAM,0BAA0B,GAC9B,OAAO,CAAC,cAAR,IAA0B,MAAM,KAAK,KADvC;AAEA,QAAI,0BAAJ,EACE,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,6CAAlB,EAAiE;AACrE,MAAA,KAAK,EAAE;AAAE,QAAA,CAAC,EAAE,CAAL;AAAQ,QAAA,CAAC,EAAE,CAAX;AAAc,QAAA,CAAC,EAAE,CAAjB;AAAoB,QAAA,CAAC,EAAE;AAAvB;AAD8D,KAAjE,CAAN;AAGF,UAAM,MAAM,GAAG,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,wBAAlB,EAA4C;AAC/D,MAAA,MAD+D;AAE/D,MAAA,OAAO,EAAE,OAAO,CAAC,OAF8C;AAG/D,MAAA,IAH+D;AAI/D,MAAA,qBAAqB,EAAE;AAJwC,KAA5C,CAArB;AAMA,QAAI,0BAAJ,EACE,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,6CAAlB,CAAN;AAEF,QAAI,OAAO,CAAC,QAAR,IAAoB,KAAK,SAA7B,EACE,MAAM,KAAK,WAAL,CAAiB,KAAK,SAAtB,CAAN;AAEF,UAAM,MAAM,GACV,OAAO,CAAC,QAAR,KAAqB,QAArB,GACI,MAAM,CAAC,IADX,GAEI,MAAM,CAAC,IAAP,CAAY,MAAM,CAAC,IAAnB,EAAyB,QAAzB,CAHN;;AAIA,QAAI,CAAC,gBAAA,CAAA,MAAD,IAAW,OAAO,CAAC,IAAvB,EAA6B;AAC3B,YAAM,IAAI,KAAJ,CACJ,uEADI,CAAN;AAGD;;AACD,UAAM,EAAE,GAAG,MAAM,WAAA,CAAA,MAAA,CAAO,cAAP,EAAjB;AACA,QAAI,OAAO,CAAC,IAAZ,EAAkB,MAAM,EAAE,CAAC,QAAH,CAAY,SAAZ,CAAsB,OAAO,CAAC,IAA9B,EAAoC,MAApC,CAAN;AAClB,WAAO,MAAP;;AAEA,aAAS,WAAT,CACE,IADF,EACsB;AAEpB,YAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,CAAhB,CAAV;AACA,YAAM,CAAC,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,CAAhB,CAAV;AACA,YAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,CAAlB,GAAsB,CAAjC,CAAd;AACA,YAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,MAAL,GAAc,IAAI,CAAC,CAAnB,GAAuB,CAAlC,CAAf;AACA,aAAO;AAAE,QAAA,CAAF;AAAK,QAAA,CAAL;AAAQ,QAAA,KAAR;AAAe,QAAA,MAAf;AAAuB,QAAA,KAAK,EAAE;AAA9B,OAAP;AACD;AACF;AAED;;;;;;;;;;;;;;;;;AAiBG;;;AACM,QAAH,GAAG,CAAC,OAAA,GAAsB,EAAvB,EAAyB;AAChC,UAAM;AACJ,MAAA,KAAK,GAAG,CADJ;AAEJ,MAAA,mBAAmB,GAAG,KAFlB;AAGJ,MAAA,cAAc,GAAG,EAHb;AAIJ,MAAA,cAAc,GAAG,EAJb;AAKJ,MAAA,eAAe,GAAG,KALd;AAMJ,MAAA,SAAS,GAAG,KANR;AAOJ,MAAA,UAAU,GAAG,EAPT;AAQJ,MAAA,iBAAiB,GAAG,KARhB;AASJ,MAAA,MAAM,GAAG,EATL;AAUJ,MAAA,IAAI,GAAG;AAVH,QAWF,OAXJ;AAaA,QAAI,UAAU,GAAG,GAAjB;AACA,QAAI,WAAW,GAAG,EAAlB;;AACA,QAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,YAAM,MAAM,GAAG,eAAA,CAAA,YAAA,CAAa,OAAO,CAAC,MAAR,CAAe,WAAf,EAAb,CAAf;AACA,MAAA,WAAA,CAAA,MAAA,CAAO,MAAP,EAAe,2BAA2B,OAAO,CAAC,MAAlD;AACA,MAAA,UAAU,GAAG,MAAM,CAAC,KAApB;AACA,MAAA,WAAW,GAAG,MAAM,CAAC,MAArB;AACD,KALD,MAKO;AACL,MAAA,UAAU,GAAG,6BAA6B,CAAC,OAAO,CAAC,KAAT,CAA7B,IAAgD,UAA7D;AACA,MAAA,WAAW,GACT,6BAA6B,CAAC,OAAO,CAAC,MAAT,CAA7B,IAAiD,WADnD;AAED;;AAED,UAAM,SAAS,GAAG,6BAA6B,CAAC,MAAM,CAAC,GAAR,CAA7B,IAA6C,CAA/D;AACA,UAAM,UAAU,GAAG,6BAA6B,CAAC,MAAM,CAAC,IAAR,CAA7B,IAA8C,CAAjE;AACA,UAAM,YAAY,GAAG,6BAA6B,CAAC,MAAM,CAAC,MAAR,CAA7B,IAAgD,CAArE;AACA,UAAM,WAAW,GAAG,6BAA6B,CAAC,MAAM,CAAC,KAAR,CAA7B,IAA+C,CAAnE;AAEA,UAAM,MAAM,GAAG,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,iBAAlB,EAAqC;AACxD,MAAA,YAAY,EAAE,gBAD0C;AAExD,MAAA,SAFwD;AAGxD,MAAA,mBAHwD;AAIxD,MAAA,cAJwD;AAKxD,MAAA,cALwD;AAMxD,MAAA,eANwD;AAOxD,MAAA,KAPwD;AAQxD,MAAA,UARwD;AASxD,MAAA,WATwD;AAUxD,MAAA,SAVwD;AAWxD,MAAA,YAXwD;AAYxD,MAAA,UAZwD;AAaxD,MAAA,WAbwD;AAcxD,MAAA,UAdwD;AAexD,MAAA;AAfwD,KAArC,CAArB;AAiBA,WAAO,MAAM,WAAA,CAAA,MAAA,CAAO,kBAAP,CAA0B,KAAK,OAA/B,EAAwC,MAAM,CAAC,MAA/C,EAAuD,IAAvD,CAAb;AACD;;AAEU,QAAL,KAAK,GAAA;AACT,WAAO,KAAK,SAAL,GAAiB,KAAjB,EAAP;AACD;;AAEU,QAAL,KAAK,CACT,OAAA,GAAyC;AAAE,IAAA,eAAe,EAAE;AAAnB,GADhC,EAC8D;AAEvE,IAAA,WAAA,CAAA,MAAA,CACE,CAAC,CAAC,KAAK,OAAL,CAAa,WADjB,EAEE,0EAFF;AAIA,UAAM,eAAe,GAAG,CAAC,CAAC,OAAO,CAAC,eAAlC;;AACA,QAAI,eAAJ,EAAqB;AACnB,YAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,YAAlB,CAAN;AACD,KAFD,MAEO;AACL,YAAM,KAAK,OAAL,CAAa,WAAb,CAAyB,IAAzB,CAA8B,oBAA9B,EAAoD;AACxD,QAAA,QAAQ,EAAE,KAAK,OAAL,CAAa;AADiC,OAApD,CAAN;AAGA,YAAM,KAAK,OAAL,CAAa,gBAAnB;AACD;AACF;;AAED,EAAA,QAAQ,GAAA;AACN,WAAO,KAAK,OAAZ;AACD;;AAEQ,MAAL,KAAK,GAAA;AACP,WAAO,KAAK,MAAZ;AACD;;AAED,EAAA,KAAK,CACH,QADG,EAEH,OAAA,GAII,EAND,EAMG;AAEN,WAAO,KAAK,SAAL,GAAiB,KAAjB,CAAuB,QAAvB,EAAiC,OAAjC,CAAP;AACD;;AAED,EAAA,KAAK,CAAC,QAAD,EAAiB;AACpB,WAAO,KAAK,SAAL,GAAiB,KAAjB,CAAuB,QAAvB,CAAP;AACD;;AAED,EAAA,KAAK,CAAC,QAAD,EAAiB;AACpB,WAAO,KAAK,SAAL,GAAiB,KAAjB,CAAuB,QAAvB,CAAP;AACD;;AAED,EAAA,MAAM,CAAC,QAAD,EAAmB,GAAG,MAAtB,EAAsC;AAC1C,WAAO,KAAK,SAAL,GAAiB,MAAjB,CAAwB,QAAxB,EAAkC,GAAG,MAArC,CAAP;AACD;;AAED,EAAA,GAAG,CAAC,QAAD,EAAiB;AAClB,WAAO,KAAK,SAAL,GAAiB,GAAjB,CAAqB,QAArB,CAAP;AACD;;AAED,EAAA,IAAI,CACF,QADE,EAEF,IAFE,EAGF,OAHE,EAGyB;AAE3B,WAAO,KAAK,SAAL,GAAiB,IAAjB,CAAsB,QAAtB,EAAgC,IAAhC,EAAsC,OAAtC,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;AAwBG;;;AACH,EAAA,OAAO,CACL,2BADK,EAEL,OAAA,GAKI,EAPC,EAQL,GAAG,IARE,EAQ4B;AAEjC,WAAO,KAAK,SAAL,GAAiB,OAAjB,CACL,2BADK,EAEL,OAFK,EAGL,GAAG,IAHE,CAAP;AAKD;AAED;;;;;;;;;;;;;;;;;;AAkBG;;;AACH,EAAA,cAAc,CAAC,YAAD,EAAqB;AACjC,WAAO,KAAK,SAAL,GAAiB,cAAjB,CAAgC,YAAhC,CAAP;AACD;;AAED,EAAA,eAAe,CACb,QADa,EAEb,OAAA,GAII,EANS,EAMP;AAEN,WAAO,KAAK,SAAL,GAAiB,eAAjB,CAAiC,QAAjC,EAA2C,OAA3C,CAAP;AACD;;AAED,EAAA,YAAY,CACV,KADU,EAEV,OAAA,GAII,EANM,EAMJ;AAEN,WAAO,KAAK,SAAL,GAAiB,YAAjB,CAA8B,KAA9B,EAAqC,OAArC,CAAP;AACD;;AAED,EAAA,eAAe,CACb,YADa,EAEb,OAAA,GAGI,EALS,EAMb,GAAG,IANU,EAMoB;AAEjC,WAAO,KAAK,SAAL,GAAiB,eAAjB,CAAiC,YAAjC,EAA+C,OAA/C,EAAwD,GAAG,IAA3D,CAAP;AACD;;AAzkDmC;;AAAtC,OAAA,CAAA,IAAA,GAAA,IAAA;AA4kDA,MAAM,gBAAgB,GAAG,IAAI,GAAJ,CAAgB,CACvC,WADuC,EAEvC,WAFuC,EAGvC,QAHuC,EAIvC,kBAJuC,EAKvC,OALuC,EAMvC,aANuC,EAOvC,kBAPuC,EAQvC,gBARuC,EASvC,qBATuC,EAUvC,gBAVuC,EAWvC,cAXuC,EAYvC,gBAZuC,EAavC,iBAbuC,CAAhB,CAAzB;AAgBA,MAAM,YAAY,GAAG;AACnB,EAAA,EAAE,EAAE,CADe;AAEnB,EAAA,EAAE,EAAE,EAFe;AAGnB,EAAA,EAAE,EAAE,IAHe;AAInB,EAAA,EAAE,EAAE;AAJe,CAArB;;AAOA,SAAS,6BAAT,CACE,SADF,EAC6B;AAE3B,MAAI,OAAO,SAAP,KAAqB,WAAzB,EAAsC,OAAO,SAAP;AACtC,MAAI,MAAJ;;AACA,MAAI,WAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,SAAhB,CAAJ,EAAgC;AAC9B;AACA,IAAA,MAAM;AAAG;AAAsB,IAAA,SAA/B;AACD,GAHD,MAGO,IAAI,WAAA,CAAA,MAAA,CAAO,QAAP,CAAgB,SAAhB,CAAJ,EAAgC;AACrC,UAAM,IAAI;AAAG;AAAsB,IAAA,SAAnC;AACA,QAAI,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe,IAAI,CAAC,MAAL,GAAc,CAA7B,EAAgC,WAAhC,EAAX;AACA,QAAI,SAAS,GAAG,EAAhB;;AACA,QAAI,YAAY,CAAC,cAAb,CAA4B,IAA5B,CAAJ,EAAuC;AACrC,MAAA,SAAS,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,EAAkB,IAAI,CAAC,MAAL,GAAc,CAAhC,CAAZ;AACD,KAFD,MAEO;AACL;AACA;AACA,MAAA,IAAI,GAAG,IAAP;AACA,MAAA,SAAS,GAAG,IAAZ;AACD;;AACD,UAAM,KAAK,GAAG,MAAM,CAAC,SAAD,CAApB;AACA,IAAA,WAAA,CAAA,MAAA,CAAO,CAAC,KAAK,CAAC,KAAD,CAAb,EAAsB,sCAAsC,IAA5D;AACA,IAAA,MAAM,GAAG,KAAK,GAAG,YAAY,CAAC,IAAD,CAA7B;AACD,GAfM,MAeA;AACL,UAAM,IAAI,KAAJ,CACJ,8CAA8C,OAAO,SADjD,CAAN;AAGD;;AACD,SAAO,MAAM,GAAG,EAAhB;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Page = void 0;\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst Connection_js_1 = require(\"./Connection.js\");\nconst Dialog_js_1 = require(\"./Dialog.js\");\nconst EmulationManager_js_1 = require(\"./EmulationManager.js\");\nconst FrameManager_js_1 = require(\"./FrameManager.js\");\nconst Input_js_1 = require(\"./Input.js\");\nconst Tracing_js_1 = require(\"./Tracing.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst Coverage_js_1 = require(\"./Coverage.js\");\nconst WebWorker_js_1 = require(\"./WebWorker.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\nconst NetworkManager_js_1 = require(\"./NetworkManager.js\");\nconst Accessibility_js_1 = require(\"./Accessibility.js\");\nconst TimeoutSettings_js_1 = require(\"./TimeoutSettings.js\");\nconst FileChooser_js_1 = require(\"./FileChooser.js\");\nconst ConsoleMessage_js_1 = require(\"./ConsoleMessage.js\");\nconst PDFOptions_js_1 = require(\"./PDFOptions.js\");\nconst environment_js_1 = require(\"../environment.js\");\nclass ScreenshotTaskQueue {\n    constructor() {\n        this._chain = Promise.resolve(undefined);\n    }\n    postTask(task) {\n        const result = this._chain.then(task);\n        this._chain = result.catch(() => { });\n        return result;\n    }\n}\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page} in Chromium.\n *\n * @remarks\n *\n * One Browser instance might have multiple Page instances.\n *\n * @example\n * This example creates a page, navigates it to a URL, and then * saves a screenshot:\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEmittedEvents} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n * ```js\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the `off` method:\n *\n * ```js\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n * @public\n */\nclass Page extends EventEmitter_js_1.EventEmitter {\n    /**\n     * @internal\n     */\n    constructor(client, target, ignoreHTTPSErrors) {\n        super();\n        this._closed = false;\n        this._timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();\n        this._pageBindings = new Map();\n        this._javascriptEnabled = true;\n        this._workers = new Map();\n        // TODO: improve this typedef - it's a function that takes a file chooser or\n        // something?\n        this._fileChooserInterceptors = new Set();\n        this._client = client;\n        this._target = target;\n        this._keyboard = new Input_js_1.Keyboard(client);\n        this._mouse = new Input_js_1.Mouse(client, this._keyboard);\n        this._touchscreen = new Input_js_1.Touchscreen(client, this._keyboard);\n        this._accessibility = new Accessibility_js_1.Accessibility(client);\n        this._frameManager = new FrameManager_js_1.FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);\n        this._emulationManager = new EmulationManager_js_1.EmulationManager(client);\n        this._tracing = new Tracing_js_1.Tracing(client);\n        this._coverage = new Coverage_js_1.Coverage(client);\n        this._screenshotTaskQueue = new ScreenshotTaskQueue();\n        this._viewport = null;\n        client.on('Target.attachedToTarget', (event) => {\n            if (event.targetInfo.type !== 'worker') {\n                // If we don't detach from service workers, they will never die.\n                client\n                    .send('Target.detachFromTarget', {\n                    sessionId: event.sessionId,\n                })\n                    .catch(helper_js_1.debugError);\n                return;\n            }\n            const session = Connection_js_1.Connection.fromSession(client).session(event.sessionId);\n            const worker = new WebWorker_js_1.WebWorker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));\n            this._workers.set(event.sessionId, worker);\n            this.emit(\"workercreated\" /* WorkerCreated */, worker);\n        });\n        client.on('Target.detachedFromTarget', (event) => {\n            const worker = this._workers.get(event.sessionId);\n            if (!worker)\n                return;\n            this.emit(\"workerdestroyed\" /* WorkerDestroyed */, worker);\n            this._workers.delete(event.sessionId);\n        });\n        this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached, (event) => this.emit(\"frameattached\" /* FrameAttached */, event));\n        this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached, (event) => this.emit(\"framedetached\" /* FrameDetached */, event));\n        this._frameManager.on(FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated, (event) => this.emit(\"framenavigated\" /* FrameNavigated */, event));\n        const networkManager = this._frameManager.networkManager();\n        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Request, (event) => this.emit(\"request\" /* Request */, event));\n        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.Response, (event) => this.emit(\"response\" /* Response */, event));\n        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, (event) => this.emit(\"requestfailed\" /* RequestFailed */, event));\n        networkManager.on(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished, (event) => this.emit(\"requestfinished\" /* RequestFinished */, event));\n        this._fileChooserInterceptors = new Set();\n        client.on('Page.domContentEventFired', () => this.emit(\"domcontentloaded\" /* DOMContentLoaded */));\n        client.on('Page.loadEventFired', () => this.emit(\"load\" /* Load */));\n        client.on('Runtime.consoleAPICalled', (event) => this._onConsoleAPI(event));\n        client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));\n        client.on('Page.javascriptDialogOpening', (event) => this._onDialog(event));\n        client.on('Runtime.exceptionThrown', (exception) => this._handleException(exception.exceptionDetails));\n        client.on('Inspector.targetCrashed', () => this._onTargetCrashed());\n        client.on('Performance.metrics', (event) => this._emitMetrics(event));\n        client.on('Log.entryAdded', (event) => this._onLogEntryAdded(event));\n        client.on('Page.fileChooserOpened', (event) => this._onFileChooser(event));\n        this._target._isClosedPromise.then(() => {\n            this.emit(\"close\" /* Close */);\n            this._closed = true;\n        });\n    }\n    /**\n     * @internal\n     */\n    static async create(client, target, ignoreHTTPSErrors, defaultViewport) {\n        const page = new Page(client, target, ignoreHTTPSErrors);\n        await page._initialize();\n        if (defaultViewport)\n            await page.setViewport(defaultViewport);\n        return page;\n    }\n    async _initialize() {\n        await Promise.all([\n            this._frameManager.initialize(),\n            this._client.send('Target.setAutoAttach', {\n                autoAttach: true,\n                waitForDebuggerOnStart: false,\n                flatten: true,\n            }),\n            this._client.send('Performance.enable'),\n            this._client.send('Log.enable'),\n        ]);\n    }\n    async _onFileChooser(event) {\n        if (!this._fileChooserInterceptors.size)\n            return;\n        const frame = this._frameManager.frame(event.frameId);\n        const context = await frame.executionContext();\n        const element = await context._adoptBackendNodeId(event.backendNodeId);\n        const interceptors = Array.from(this._fileChooserInterceptors);\n        this._fileChooserInterceptors.clear();\n        const fileChooser = new FileChooser_js_1.FileChooser(element, event);\n        for (const interceptor of interceptors)\n            interceptor.call(null, fileChooser);\n    }\n    /**\n     * @returns `true` if the page has JavaScript enabled, `false` otherwise.\n     */\n    isJavaScriptEnabled() {\n        return this._javascriptEnabled;\n    }\n    /**\n     * @param options - Optional waiting parameters\n     * @returns Resolves after a page requests a file picker.\n     */\n    async waitForFileChooser(options = {}) {\n        if (!this._fileChooserInterceptors.size)\n            await this._client.send('Page.setInterceptFileChooserDialog', {\n                enabled: true,\n            });\n        const { timeout = this._timeoutSettings.timeout() } = options;\n        let callback;\n        const promise = new Promise((x) => (callback = x));\n        this._fileChooserInterceptors.add(callback);\n        return helper_js_1.helper\n            .waitWithTimeout(promise, 'waiting for file chooser', timeout)\n            .catch((error) => {\n            this._fileChooserInterceptors.delete(callback);\n            throw error;\n        });\n    }\n    /**\n     * Sets the page's geolocation.\n     *\n     * @remarks\n     * Consider using {@link BrowserContext.overridePermissions} to grant\n     * permissions for the page to read its geolocation.\n     *\n     * @example\n     * ```js\n     * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n     * ```\n     */\n    async setGeolocation(options) {\n        const { longitude, latitude, accuracy = 0 } = options;\n        if (longitude < -180 || longitude > 180)\n            throw new Error(`Invalid longitude \"${longitude}\": precondition -180 <= LONGITUDE <= 180 failed.`);\n        if (latitude < -90 || latitude > 90)\n            throw new Error(`Invalid latitude \"${latitude}\": precondition -90 <= LATITUDE <= 90 failed.`);\n        if (accuracy < 0)\n            throw new Error(`Invalid accuracy \"${accuracy}\": precondition 0 <= ACCURACY failed.`);\n        await this._client.send('Emulation.setGeolocationOverride', {\n            longitude,\n            latitude,\n            accuracy,\n        });\n    }\n    /**\n     * @returns A target this page was created from.\n     */\n    target() {\n        return this._target;\n    }\n    /**\n     * @returns The browser this page belongs to.\n     */\n    browser() {\n        return this._target.browser();\n    }\n    /**\n     * @returns The browser context that the page belongs to\n     */\n    browserContext() {\n        return this._target.browserContext();\n    }\n    _onTargetCrashed() {\n        this.emit('error', new Error('Page crashed!'));\n    }\n    _onLogEntryAdded(event) {\n        const { level, text, args, source, url, lineNumber } = event.entry;\n        if (args)\n            args.map((arg) => helper_js_1.helper.releaseObject(this._client, arg));\n        if (source !== 'worker')\n            this.emit(\"console\" /* Console */, new ConsoleMessage_js_1.ConsoleMessage(level, text, [], [{ url, lineNumber }]));\n    }\n    /**\n     * @returns The page's main frame.\n     */\n    mainFrame() {\n        return this._frameManager.mainFrame();\n    }\n    get keyboard() {\n        return this._keyboard;\n    }\n    get touchscreen() {\n        return this._touchscreen;\n    }\n    get coverage() {\n        return this._coverage;\n    }\n    get tracing() {\n        return this._tracing;\n    }\n    get accessibility() {\n        return this._accessibility;\n    }\n    /**\n     * @returns An array of all frames attached to the page.\n     */\n    frames() {\n        return this._frameManager.frames();\n    }\n    /**\n     * @returns all of the dedicated\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorkers}\n     * associated with the page.\n     */\n    workers() {\n        return Array.from(this._workers.values());\n    }\n    /**\n     * @param value - Whether to enable request interception.\n     *\n     * @remarks\n     * Activating request interception enables {@link HTTPRequest.abort},\n     * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods.  This\n     * provides the capability to modify network requests that are made by a page.\n     *\n     * Once request interception is enabled, every request will stall unless it's\n     * continued, responded or aborted.\n     *\n     * **NOTE** Enabling request interception disables page caching.\n     *\n     * @example\n     * An example of a naïve request interceptor that aborts all image requests:\n     * ```js\n     * const puppeteer = require('puppeteer');\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   await page.setRequestInterception(true);\n     *   page.on('request', interceptedRequest => {\n     *     if (interceptedRequest.url().endsWith('.png') ||\n     *         interceptedRequest.url().endsWith('.jpg'))\n     *       interceptedRequest.abort();\n     *     else\n     *       interceptedRequest.continue();\n     *     });\n     *   await page.goto('https://example.com');\n     *   await browser.close();\n     * })();\n     * ```\n     */\n    async setRequestInterception(value) {\n        return this._frameManager.networkManager().setRequestInterception(value);\n    }\n    /**\n     * @param enabled - When `true`, enables offline mode for the page.\n     */\n    setOfflineMode(enabled) {\n        return this._frameManager.networkManager().setOfflineMode(enabled);\n    }\n    emulateNetworkConditions(networkConditions) {\n        return this._frameManager\n            .networkManager()\n            .emulateNetworkConditions(networkConditions);\n    }\n    /**\n     * @param timeout - Maximum navigation time in milliseconds.\n     */\n    setDefaultNavigationTimeout(timeout) {\n        this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n    }\n    /**\n     * @param timeout - Maximum time in milliseconds.\n     */\n    setDefaultTimeout(timeout) {\n        this._timeoutSettings.setDefaultTimeout(timeout);\n    }\n    /**\n     * Runs `document.querySelector` within the page. If no element matches the\n     * selector, the return value resolves to `null`.\n     *\n     * @remarks\n     * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query page for.\n     */\n    async $(selector) {\n        return this.mainFrame().$(selector);\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Page.evaluate | page.evaluate} and\n     * `page.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * If the function passed to `page.evaluteHandle` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     * ```\n     * const aHandle = await page.evaluateHandle('document')\n     * ```\n     *\n     * @example\n     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n     * ```\n     * const aHandle = await page.evaluateHandle(() => document.body);\n     * const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);\n     * console.log(await resultHandle.jsonValue());\n     * await resultHandle.dispose();\n     * ```\n     *\n     * Most of the time this function returns a {@link JSHandle},\n     * but if `pageFunction` returns a reference to an element,\n     * you instead get an {@link ElementHandle} back:\n     *\n     * @example\n     * ```\n     * const button = await page.evaluateHandle(() => document.querySelector('button'));\n     * // can call `click` because `button` is an `ElementHandle`\n     * await button.click();\n     * ```\n     *\n     * The TypeScript definitions assume that `evaluateHandle` returns\n     *  a `JSHandle`, but if you know it's going to return an\n     * `ElementHandle`, pass it as the generic argument:\n     *\n     * ```\n     * const button = await page.evaluateHandle<ElementHandle>(...);\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        const context = await this.mainFrame().executionContext();\n        return context.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * This method iterates the JavaScript heap and finds all objects with the\n     * given prototype.\n     *\n     * @remarks\n     *\n     * @example\n     *\n     * ```js\n     * // Create a Map object\n     * await page.evaluate(() => window.map = new Map());\n     * // Get a handle to the Map object prototype\n     * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n     * // Query all map instances into an array\n     * const mapInstances = await page.queryObjects(mapPrototype);\n     * // Count amount of map objects in heap\n     * const count = await page.evaluate(maps => maps.length, mapInstances);\n     * await mapInstances.dispose();\n     * await mapPrototype.dispose();\n     * ```\n     * @param prototypeHandle - a handle to the object prototype.\n     */\n    async queryObjects(prototypeHandle) {\n        const context = await this.mainFrame().executionContext();\n        return context.queryObjects(prototypeHandle);\n    }\n    /**\n     * This method runs `document.querySelector` within the page and passes the\n     * result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     *\n     * If no element is found matching `selector`, the method will throw an error.\n     *\n     * If `pageFunction` returns a promise `$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```\n     * const searchValue = await page.$eval('#search', el => el.value);\n     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n     * const html = await page.$eval('.main-container', el => el.outerHTML);\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * const searchValue = await page.$eval('#search', (el: HTMLInputElement) => el.value);\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$eval`:\n     *\n     * @example\n     *\n     * ```\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const searchValue = await page.$eval<string>(\n     *  '#search', (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of `document.querySelector(selector)` as its\n     * first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $eval(selector, pageFunction, ...args) {\n        return this.mainFrame().$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the page and passes the result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     *\n     * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```\n     * // get the amount of divs on the page\n     * const divCount = await page.$$eval('div', divs => divs.length);\n     *\n     * // get the text content of all the `.options` elements:\n     * const options = await page.$$eval('div > span.options', options => {\n     *   return options.map(option => option.textContent)\n     * });\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element[]`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n     *   return elements.map(e => e.value);\n     * });\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$$eval`:\n     *\n     * @example\n     *\n     * ```\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const allInputValues = await page.$$eval<string[]>(\n     *  'input', (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n     * );\n     * ```\n     *\n     * @param selector the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction the function to be evaluated in the page context. Will\n     * be passed the result of `Array.from(document.querySelectorAll(selector))`\n     * as its first argument.\n     * @param args any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $$eval(selector, pageFunction, ...args) {\n        return this.mainFrame().$$eval(selector, pageFunction, ...args);\n    }\n    async $$(selector) {\n        return this.mainFrame().$$(selector);\n    }\n    async $x(expression) {\n        return this.mainFrame().$x(expression);\n    }\n    /**\n     * If no URLs are specified, this method returns cookies for the current page\n     * URL. If URLs are specified, only cookies for those URLs are returned.\n     */\n    async cookies(...urls) {\n        const originalCookies = (await this._client.send('Network.getCookies', {\n            urls: urls.length ? urls : [this.url()],\n        })).cookies;\n        const unsupportedCookieAttributes = ['priority'];\n        const filterUnsupportedAttributes = (cookie) => {\n            for (const attr of unsupportedCookieAttributes)\n                delete cookie[attr];\n            return cookie;\n        };\n        return originalCookies.map(filterUnsupportedAttributes);\n    }\n    async deleteCookie(...cookies) {\n        const pageURL = this.url();\n        for (const cookie of cookies) {\n            const item = Object.assign({}, cookie);\n            if (!cookie.url && pageURL.startsWith('http'))\n                item.url = pageURL;\n            await this._client.send('Network.deleteCookies', item);\n        }\n    }\n    async setCookie(...cookies) {\n        const pageURL = this.url();\n        const startsWithHTTP = pageURL.startsWith('http');\n        const items = cookies.map((cookie) => {\n            const item = Object.assign({}, cookie);\n            if (!item.url && startsWithHTTP)\n                item.url = pageURL;\n            assert_js_1.assert(item.url !== 'about:blank', `Blank page can not have cookie \"${item.name}\"`);\n            assert_js_1.assert(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie \"${item.name}\"`);\n            return item;\n        });\n        await this.deleteCookie(...items);\n        if (items.length)\n            await this._client.send('Network.setCookies', { cookies: items });\n    }\n    async addScriptTag(options) {\n        return this.mainFrame().addScriptTag(options);\n    }\n    async addStyleTag(options) {\n        return this.mainFrame().addStyleTag(options);\n    }\n    async exposeFunction(name, puppeteerFunction) {\n        if (this._pageBindings.has(name))\n            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);\n        this._pageBindings.set(name, puppeteerFunction);\n        const expression = helper_js_1.helper.pageBindingInitString('exposedFun', name);\n        await this._client.send('Runtime.addBinding', { name: name });\n        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n            source: expression,\n        });\n        await Promise.all(this.frames().map((frame) => frame.evaluate(expression).catch(helper_js_1.debugError)));\n    }\n    async authenticate(credentials) {\n        return this._frameManager.networkManager().authenticate(credentials);\n    }\n    async setExtraHTTPHeaders(headers) {\n        return this._frameManager.networkManager().setExtraHTTPHeaders(headers);\n    }\n    async setUserAgent(userAgent) {\n        return this._frameManager.networkManager().setUserAgent(userAgent);\n    }\n    async metrics() {\n        const response = await this._client.send('Performance.getMetrics');\n        return this._buildMetricsObject(response.metrics);\n    }\n    _emitMetrics(event) {\n        this.emit(\"metrics\" /* Metrics */, {\n            title: event.title,\n            metrics: this._buildMetricsObject(event.metrics),\n        });\n    }\n    _buildMetricsObject(metrics) {\n        const result = {};\n        for (const metric of metrics || []) {\n            if (supportedMetrics.has(metric.name))\n                result[metric.name] = metric.value;\n        }\n        return result;\n    }\n    _handleException(exceptionDetails) {\n        const message = helper_js_1.helper.getExceptionMessage(exceptionDetails);\n        const err = new Error(message);\n        err.stack = ''; // Don't report clientside error with a node stack attached\n        this.emit(\"pageerror\" /* PageError */, err);\n    }\n    async _onConsoleAPI(event) {\n        if (event.executionContextId === 0) {\n            // DevTools protocol stores the last 1000 console messages. These\n            // messages are always reported even for removed execution contexts. In\n            // this case, they are marked with executionContextId = 0 and are\n            // reported upon enabling Runtime agent.\n            //\n            // Ignore these messages since:\n            // - there's no execution context we can use to operate with message\n            //   arguments\n            // - these messages are reported before Puppeteer clients can subscribe\n            //   to the 'console'\n            //   page event.\n            //\n            // @see https://github.com/puppeteer/puppeteer/issues/3865\n            return;\n        }\n        const context = this._frameManager.executionContextById(event.executionContextId);\n        const values = event.args.map((arg) => JSHandle_js_1.createJSHandle(context, arg));\n        this._addConsoleMessage(event.type, values, event.stackTrace);\n    }\n    async _onBindingCalled(event) {\n        let payload;\n        try {\n            payload = JSON.parse(event.payload);\n        }\n        catch {\n            // The binding was either called by something in the page or it was\n            // called before our wrapper was initialized.\n            return;\n        }\n        const { type, name, seq, args } = payload;\n        if (type !== 'exposedFun' || !this._pageBindings.has(name))\n            return;\n        let expression = null;\n        try {\n            const result = await this._pageBindings.get(name)(...args);\n            expression = helper_js_1.helper.pageBindingDeliverResultString(name, seq, result);\n        }\n        catch (error) {\n            if (error instanceof Error)\n                expression = helper_js_1.helper.pageBindingDeliverErrorString(name, seq, error.message, error.stack);\n            else\n                expression = helper_js_1.helper.pageBindingDeliverErrorValueString(name, seq, error);\n        }\n        this._client\n            .send('Runtime.evaluate', {\n            expression,\n            contextId: event.executionContextId,\n        })\n            .catch(helper_js_1.debugError);\n    }\n    _addConsoleMessage(type, args, stackTrace) {\n        if (!this.listenerCount(\"console\" /* Console */)) {\n            args.forEach((arg) => arg.dispose());\n            return;\n        }\n        const textTokens = [];\n        for (const arg of args) {\n            const remoteObject = arg._remoteObject;\n            if (remoteObject.objectId)\n                textTokens.push(arg.toString());\n            else\n                textTokens.push(helper_js_1.helper.valueFromRemoteObject(remoteObject));\n        }\n        const stackTraceLocations = [];\n        if (stackTrace) {\n            for (const callFrame of stackTrace.callFrames) {\n                stackTraceLocations.push({\n                    url: callFrame.url,\n                    lineNumber: callFrame.lineNumber,\n                    columnNumber: callFrame.columnNumber,\n                });\n            }\n        }\n        const message = new ConsoleMessage_js_1.ConsoleMessage(type, textTokens.join(' '), args, stackTraceLocations);\n        this.emit(\"console\" /* Console */, message);\n    }\n    _onDialog(event) {\n        let dialogType = null;\n        const validDialogTypes = new Set([\n            'alert',\n            'confirm',\n            'prompt',\n            'beforeunload',\n        ]);\n        if (validDialogTypes.has(event.type)) {\n            dialogType = event.type;\n        }\n        assert_js_1.assert(dialogType, 'Unknown javascript dialog type: ' + event.type);\n        const dialog = new Dialog_js_1.Dialog(this._client, dialogType, event.message, event.defaultPrompt);\n        this.emit(\"dialog\" /* Dialog */, dialog);\n    }\n    url() {\n        return this.mainFrame().url();\n    }\n    async content() {\n        return await this._frameManager.mainFrame().content();\n    }\n    async setContent(html, options = {}) {\n        await this._frameManager.mainFrame().setContent(html, options);\n    }\n    async goto(url, options = {}) {\n        return await this._frameManager.mainFrame().goto(url, options);\n    }\n    async reload(options) {\n        const result = await Promise.all([\n            this.waitForNavigation(options),\n            this._client.send('Page.reload'),\n        ]);\n        return result[0];\n    }\n    async waitForNavigation(options = {}) {\n        return await this._frameManager.mainFrame().waitForNavigation(options);\n    }\n    _sessionClosePromise() {\n        if (!this._disconnectPromise)\n            this._disconnectPromise = new Promise((fulfill) => this._client.once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => fulfill(new Error('Target closed'))));\n        return this._disconnectPromise;\n    }\n    async waitForRequest(urlOrPredicate, options = {}) {\n        const { timeout = this._timeoutSettings.timeout() } = options;\n        return helper_js_1.helper.waitForEvent(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Request, (request) => {\n            if (helper_js_1.helper.isString(urlOrPredicate))\n                return urlOrPredicate === request.url();\n            if (typeof urlOrPredicate === 'function')\n                return !!urlOrPredicate(request);\n            return false;\n        }, timeout, this._sessionClosePromise());\n    }\n    async waitForResponse(urlOrPredicate, options = {}) {\n        const { timeout = this._timeoutSettings.timeout() } = options;\n        return helper_js_1.helper.waitForEvent(this._frameManager.networkManager(), NetworkManager_js_1.NetworkManagerEmittedEvents.Response, async (response) => {\n            if (helper_js_1.helper.isString(urlOrPredicate))\n                return urlOrPredicate === response.url();\n            if (typeof urlOrPredicate === 'function')\n                return !!(await urlOrPredicate(response));\n            return false;\n        }, timeout, this._sessionClosePromise());\n    }\n    async goBack(options = {}) {\n        return this._go(-1, options);\n    }\n    async goForward(options = {}) {\n        return this._go(+1, options);\n    }\n    async _go(delta, options) {\n        const history = await this._client.send('Page.getNavigationHistory');\n        const entry = history.entries[history.currentIndex + delta];\n        if (!entry)\n            return null;\n        const result = await Promise.all([\n            this.waitForNavigation(options),\n            this._client.send('Page.navigateToHistoryEntry', { entryId: entry.id }),\n        ]);\n        return result[0];\n    }\n    async bringToFront() {\n        await this._client.send('Page.bringToFront');\n    }\n    async emulate(options) {\n        await Promise.all([\n            this.setViewport(options.viewport),\n            this.setUserAgent(options.userAgent),\n        ]);\n    }\n    async setJavaScriptEnabled(enabled) {\n        if (this._javascriptEnabled === enabled)\n            return;\n        this._javascriptEnabled = enabled;\n        await this._client.send('Emulation.setScriptExecutionDisabled', {\n            value: !enabled,\n        });\n    }\n    async setBypassCSP(enabled) {\n        await this._client.send('Page.setBypassCSP', { enabled });\n    }\n    async emulateMediaType(type) {\n        assert_js_1.assert(type === 'screen' || type === 'print' || type === null, 'Unsupported media type: ' + type);\n        await this._client.send('Emulation.setEmulatedMedia', {\n            media: type || '',\n        });\n    }\n    async emulateMediaFeatures(features) {\n        if (features === null)\n            await this._client.send('Emulation.setEmulatedMedia', { features: null });\n        if (Array.isArray(features)) {\n            features.every((mediaFeature) => {\n                const name = mediaFeature.name;\n                assert_js_1.assert(/^prefers-(?:color-scheme|reduced-motion)$/.test(name), 'Unsupported media feature: ' + name);\n                return true;\n            });\n            await this._client.send('Emulation.setEmulatedMedia', {\n                features: features,\n            });\n        }\n    }\n    async emulateTimezone(timezoneId) {\n        try {\n            await this._client.send('Emulation.setTimezoneOverride', {\n                timezoneId: timezoneId || '',\n            });\n        }\n        catch (error) {\n            if (error.message.includes('Invalid timezone'))\n                throw new Error(`Invalid timezone ID: ${timezoneId}`);\n            throw error;\n        }\n    }\n    /**\n     * Emulates the idle state.\n     * If no arguments set, clears idle state emulation.\n     *\n     * @example\n     * ```js\n     * // set idle emulation\n     * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n     *\n     * // do some checks here\n     * ...\n     *\n     * // clear idle emulation\n     * await page.emulateIdleState();\n     * ```\n     *\n     * @param overrides Mock idle state. If not set, clears idle overrides\n     * @param isUserActive Mock isUserActive\n     * @param isScreenUnlocked Mock isScreenUnlocked\n     */\n    async emulateIdleState(overrides) {\n        if (overrides) {\n            await this._client.send('Emulation.setIdleOverride', {\n                isUserActive: overrides.isUserActive,\n                isScreenUnlocked: overrides.isScreenUnlocked,\n            });\n        }\n        else {\n            await this._client.send('Emulation.clearIdleOverride');\n        }\n    }\n    /**\n     * Simulates the given vision deficiency on the page.\n     *\n     * @example\n     * ```js\n     * const puppeteer = require('puppeteer');\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   await page.goto('https://v8.dev/blog/10-years');\n     *\n     *   await page.emulateVisionDeficiency('achromatopsia');\n     *   await page.screenshot({ path: 'achromatopsia.png' });\n     *\n     *   await page.emulateVisionDeficiency('deuteranopia');\n     *   await page.screenshot({ path: 'deuteranopia.png' });\n     *\n     *   await page.emulateVisionDeficiency('blurredVision');\n     *   await page.screenshot({ path: 'blurred-vision.png' });\n     *\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param type - the type of deficiency to simulate, or `'none'` to reset.\n     */\n    async emulateVisionDeficiency(type) {\n        const visionDeficiencies = new Set([\n            'none',\n            'achromatopsia',\n            'blurredVision',\n            'deuteranopia',\n            'protanopia',\n            'tritanopia',\n        ]);\n        try {\n            assert_js_1.assert(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);\n            await this._client.send('Emulation.setEmulatedVisionDeficiency', {\n                type: type || 'none',\n            });\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async setViewport(viewport) {\n        const needsReload = await this._emulationManager.emulateViewport(viewport);\n        this._viewport = viewport;\n        if (needsReload)\n            await this.reload();\n    }\n    viewport() {\n        return this._viewport;\n    }\n    /**\n     * @remarks\n     *\n     * Evaluates a function in the page's context and returns the result.\n     *\n     * If the function passed to `page.evaluteHandle` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```js\n     * const result = await frame.evaluate(() => {\n     *   return Promise.resolve(8 * 7);\n     * });\n     * console.log(result); // prints \"56\"\n     * ```\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     * ```\n     * const aHandle = await page.evaluate('1 + 2');\n     * ```\n     *\n     * To get the best TypeScript experience, you should pass in as the\n     * generic the type of `pageFunction`:\n     *\n     * ```\n     * const aHandle = await page.evaluate<() => number>(() => 2);\n     * ```\n     *\n     * @example\n     *\n     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n     * as arguments to the `pageFunction`:\n     *\n     * ```\n     * const bodyHandle = await page.$('body');\n     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n     * await bodyHandle.dispose();\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     *\n     * @returns the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction, ...args) {\n        return this._frameManager.mainFrame().evaluate(pageFunction, ...args);\n    }\n    async evaluateOnNewDocument(pageFunction, ...args) {\n        const source = helper_js_1.helper.evaluationString(pageFunction, ...args);\n        await this._client.send('Page.addScriptToEvaluateOnNewDocument', {\n            source,\n        });\n    }\n    async setCacheEnabled(enabled = true) {\n        await this._frameManager.networkManager().setCacheEnabled(enabled);\n    }\n    async screenshot(options = {}) {\n        let screenshotType = null;\n        // options.type takes precedence over inferring the type from options.path\n        // because it may be a 0-length file with no extension created beforehand\n        // (i.e. as a temp file).\n        if (options.type) {\n            assert_js_1.assert(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);\n            screenshotType = options.type;\n        }\n        else if (options.path) {\n            const filePath = options.path;\n            const extension = filePath\n                .slice(filePath.lastIndexOf('.') + 1)\n                .toLowerCase();\n            if (extension === 'png')\n                screenshotType = 'png';\n            else if (extension === 'jpg' || extension === 'jpeg')\n                screenshotType = 'jpeg';\n            assert_js_1.assert(screenshotType, `Unsupported screenshot type for extension \\`.${extension}\\``);\n        }\n        if (!screenshotType)\n            screenshotType = 'png';\n        if (options.quality) {\n            assert_js_1.assert(screenshotType === 'jpeg', 'options.quality is unsupported for the ' +\n                screenshotType +\n                ' screenshots');\n            assert_js_1.assert(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' +\n                typeof options.quality);\n            assert_js_1.assert(Number.isInteger(options.quality), 'Expected options.quality to be an integer');\n            assert_js_1.assert(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' +\n                options.quality);\n        }\n        assert_js_1.assert(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');\n        if (options.clip) {\n            assert_js_1.assert(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' +\n                typeof options.clip.x);\n            assert_js_1.assert(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' +\n                typeof options.clip.y);\n            assert_js_1.assert(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' +\n                typeof options.clip.width);\n            assert_js_1.assert(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' +\n                typeof options.clip.height);\n            assert_js_1.assert(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');\n            assert_js_1.assert(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');\n        }\n        return this._screenshotTaskQueue.postTask(() => this._screenshotTask(screenshotType, options));\n    }\n    async _screenshotTask(format, options) {\n        await this._client.send('Target.activateTarget', {\n            targetId: this._target._targetId,\n        });\n        let clip = options.clip ? processClip(options.clip) : undefined;\n        if (options.fullPage) {\n            const metrics = await this._client.send('Page.getLayoutMetrics');\n            const width = Math.ceil(metrics.contentSize.width);\n            const height = Math.ceil(metrics.contentSize.height);\n            // Overwrite clip for full page.\n            clip = { x: 0, y: 0, width, height, scale: 1 };\n        }\n        const shouldSetDefaultBackground = options.omitBackground && format === 'png';\n        if (shouldSetDefaultBackground)\n            await this._client.send('Emulation.setDefaultBackgroundColorOverride', {\n                color: { r: 0, g: 0, b: 0, a: 0 },\n            });\n        const result = await this._client.send('Page.captureScreenshot', {\n            format,\n            quality: options.quality,\n            clip,\n            captureBeyondViewport: true,\n        });\n        if (shouldSetDefaultBackground)\n            await this._client.send('Emulation.setDefaultBackgroundColorOverride');\n        if (options.fullPage && this._viewport)\n            await this.setViewport(this._viewport);\n        const buffer = options.encoding === 'base64'\n            ? result.data\n            : Buffer.from(result.data, 'base64');\n        if (!environment_js_1.isNode && options.path) {\n            throw new Error('Screenshots can only be written to a file path in a Node environment.');\n        }\n        const fs = await helper_js_1.helper.importFSModule();\n        if (options.path)\n            await fs.promises.writeFile(options.path, buffer);\n        return buffer;\n        function processClip(clip) {\n            const x = Math.round(clip.x);\n            const y = Math.round(clip.y);\n            const width = Math.round(clip.width + clip.x - x);\n            const height = Math.round(clip.height + clip.y - y);\n            return { x, y, width, height, scale: 1 };\n        }\n    }\n    /**\n     * Generatees a PDF of the page with the `print` CSS media type.\n     * @remarks\n     *\n     * IMPORTANT: PDF generation is only supported in Chrome headless mode.\n     *\n     * To generate a PDF with the `screen` media type, call\n     * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n     * calling `page.pdf()`.\n     *\n     * By default, `page.pdf()` generates a pdf with modified colors for printing.\n     * Use the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n     * property to force rendering of exact colors.\n     *\n     *\n     * @param options - options for generating the PDF.\n     */\n    async pdf(options = {}) {\n        const { scale = 1, displayHeaderFooter = false, headerTemplate = '', footerTemplate = '', printBackground = false, landscape = false, pageRanges = '', preferCSSPageSize = false, margin = {}, path = null, } = options;\n        let paperWidth = 8.5;\n        let paperHeight = 11;\n        if (options.format) {\n            const format = PDFOptions_js_1.paperFormats[options.format.toLowerCase()];\n            assert_js_1.assert(format, 'Unknown paper format: ' + options.format);\n            paperWidth = format.width;\n            paperHeight = format.height;\n        }\n        else {\n            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;\n            paperHeight =\n                convertPrintParameterToInches(options.height) || paperHeight;\n        }\n        const marginTop = convertPrintParameterToInches(margin.top) || 0;\n        const marginLeft = convertPrintParameterToInches(margin.left) || 0;\n        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;\n        const marginRight = convertPrintParameterToInches(margin.right) || 0;\n        const result = await this._client.send('Page.printToPDF', {\n            transferMode: 'ReturnAsStream',\n            landscape,\n            displayHeaderFooter,\n            headerTemplate,\n            footerTemplate,\n            printBackground,\n            scale,\n            paperWidth,\n            paperHeight,\n            marginTop,\n            marginBottom,\n            marginLeft,\n            marginRight,\n            pageRanges,\n            preferCSSPageSize,\n        });\n        return await helper_js_1.helper.readProtocolStream(this._client, result.stream, path);\n    }\n    async title() {\n        return this.mainFrame().title();\n    }\n    async close(options = { runBeforeUnload: undefined }) {\n        assert_js_1.assert(!!this._client._connection, 'Protocol error: Connection closed. Most likely the page has been closed.');\n        const runBeforeUnload = !!options.runBeforeUnload;\n        if (runBeforeUnload) {\n            await this._client.send('Page.close');\n        }\n        else {\n            await this._client._connection.send('Target.closeTarget', {\n                targetId: this._target._targetId,\n            });\n            await this._target._isClosedPromise;\n        }\n    }\n    isClosed() {\n        return this._closed;\n    }\n    get mouse() {\n        return this._mouse;\n    }\n    click(selector, options = {}) {\n        return this.mainFrame().click(selector, options);\n    }\n    focus(selector) {\n        return this.mainFrame().focus(selector);\n    }\n    hover(selector) {\n        return this.mainFrame().hover(selector);\n    }\n    select(selector, ...values) {\n        return this.mainFrame().select(selector, ...values);\n    }\n    tap(selector) {\n        return this.mainFrame().tap(selector);\n    }\n    type(selector, text, options) {\n        return this.mainFrame().type(selector, text, options);\n    }\n    /**\n     * @remarks\n     *\n     * This method behaves differently depending on the first parameter. If it's a\n     * `string`, it will be treated as a `selector` or `xpath` (if the string\n     * starts with `//`). This method then is a shortcut for\n     * {@link Page.waitForSelector} or {@link Page.waitForXPath}.\n     *\n     * If the first argument is a function this method is a shortcut for\n     * {@link Page.waitForFunction}.\n     *\n     * If the first argument is a `number`, it's treated as a timeout in\n     * milliseconds and the method returns a promise which resolves after the\n     * timeout.\n     *\n     * @param selectorOrFunctionOrTimeout - a selector, predicate or timeout to\n     * wait for.\n     * @param options - optional waiting parameters.\n     * @param args - arguments to pass to `pageFunction`.\n     *\n     * @deprecated Don't use this method directly. Instead use the more explicit\n     * methods available: {@link Page.waitForSelector},\n     * {@link Page.waitForXPath}, {@link Page.waitForFunction} or\n     * {@link Page.waitForTimeout}.\n     */\n    waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {\n        return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);\n    }\n    /**\n     * Causes your script to wait for the given number of milliseconds.\n     *\n     * @remarks\n     *\n     * It's generally recommended to not wait for a number of seconds, but instead\n     * use {@link Page.waitForSelector}, {@link Page.waitForXPath} or\n     * {@link Page.waitForFunction} to wait for exactly the conditions you want.\n     *\n     * @example\n     *\n     * Wait for 1 second:\n     *\n     * ```\n     * await page.waitForTimeout(1000);\n     * ```\n     *\n     * @param milliseconds - the number of milliseconds to wait.\n     */\n    waitForTimeout(milliseconds) {\n        return this.mainFrame().waitForTimeout(milliseconds);\n    }\n    waitForSelector(selector, options = {}) {\n        return this.mainFrame().waitForSelector(selector, options);\n    }\n    waitForXPath(xpath, options = {}) {\n        return this.mainFrame().waitForXPath(xpath, options);\n    }\n    waitForFunction(pageFunction, options = {}, ...args) {\n        return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n    }\n}\nexports.Page = Page;\nconst supportedMetrics = new Set([\n    'Timestamp',\n    'Documents',\n    'Frames',\n    'JSEventListeners',\n    'Nodes',\n    'LayoutCount',\n    'RecalcStyleCount',\n    'LayoutDuration',\n    'RecalcStyleDuration',\n    'ScriptDuration',\n    'TaskDuration',\n    'JSHeapUsedSize',\n    'JSHeapTotalSize',\n]);\nconst unitToPixels = {\n    px: 1,\n    in: 96,\n    cm: 37.8,\n    mm: 3.78,\n};\nfunction convertPrintParameterToInches(parameter) {\n    if (typeof parameter === 'undefined')\n        return undefined;\n    let pixels;\n    if (helper_js_1.helper.isNumber(parameter)) {\n        // Treat numbers as pixel values to be aligned with phantom's paperSize.\n        pixels = /** @type {number} */ parameter;\n    }\n    else if (helper_js_1.helper.isString(parameter)) {\n        const text = /** @type {string} */ parameter;\n        let unit = text.substring(text.length - 2).toLowerCase();\n        let valueText = '';\n        if (unitToPixels.hasOwnProperty(unit)) {\n            valueText = text.substring(0, text.length - 2);\n        }\n        else {\n            // In case of unknown unit try to parse the whole parameter as number of pixels.\n            // This is consistent with phantom's paperSize behavior.\n            unit = 'px';\n            valueText = text;\n        }\n        const value = Number(valueText);\n        assert_js_1.assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n        pixels = value * unitToPixels[unit];\n    }\n    else {\n        throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);\n    }\n    return pixels / 96;\n}\n//# sourceMappingURL=Page.js.map"]},"metadata":{},"sourceType":"script"}