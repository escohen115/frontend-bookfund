{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ElementHandle = exports.JSHandle = exports.createJSHandle = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst QueryHandler_js_1 = require(\"./QueryHandler.js\");\n\nconst environment_js_1 = require(\"../environment.js\");\n/**\n * @internal\n */\n\n\nfunction createJSHandle(context, remoteObject) {\n  const frame = context.frame();\n\n  if (remoteObject.subtype === 'node' && frame) {\n    const frameManager = frame._frameManager;\n    return new ElementHandle(context, context._client, remoteObject, frameManager.page(), frameManager);\n  }\n\n  return new JSHandle(context, context._client, remoteObject);\n}\n\nexports.createJSHandle = createJSHandle;\n/**\n * Represents an in-page JavaScript object. JSHandles can be created with the\n * {@link Page.evaluateHandle | page.evaluateHandle} method.\n *\n * @example\n * ```js\n * const windowHandle = await page.evaluateHandle(() => window);\n * ```\n *\n * JSHandle prevents the referenced JavaScript object from being garbage-collected\n * unless the handle is {@link JSHandle.dispose | disposed}. JSHandles are auto-\n * disposed when their origin frame gets navigated or the parent context gets destroyed.\n *\n * JSHandle instances can be used as arguments for {@link Page.$eval},\n * {@link Page.evaluate}, and {@link Page.evaluateHandle}.\n *\n * @public\n */\n\nclass JSHandle {\n  /**\n   * @internal\n   */\n  constructor(context, client, remoteObject) {\n    /**\n     * @internal\n     */\n    this._disposed = false;\n    this._context = context;\n    this._client = client;\n    this._remoteObject = remoteObject;\n  }\n  /** Returns the execution context the handle belongs to.\n   */\n\n\n  executionContext() {\n    return this._context;\n  }\n  /**\n   * This method passes this handle as the first argument to `pageFunction`.\n   * If `pageFunction` returns a Promise, then `handle.evaluate` would wait\n   * for the promise to resolve and return its value.\n   *\n   * @example\n   * ```js\n   * const tweetHandle = await page.$('.tweet .retweets');\n   * expect(await tweetHandle.evaluate(node => node.innerText)).toBe('10');\n   * ```\n   */\n\n\n  async evaluate(pageFunction, ...args) {\n    return await this.executionContext().evaluate(pageFunction, this, ...args);\n  }\n  /**\n   * This method passes this handle as the first argument to `pageFunction`.\n   *\n   * @remarks\n   *\n   * The only difference between `jsHandle.evaluate` and\n   * `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle`\n   * returns an in-page object (JSHandle).\n   *\n   * If the function passed to `jsHandle.evaluateHandle` returns a Promise,\n   * then `evaluateHandle.evaluateHandle` waits for the promise to resolve and\n   * returns its value.\n   *\n   * See {@link Page.evaluateHandle} for more details.\n   */\n\n\n  async evaluateHandle(pageFunction, ...args) {\n    return await this.executionContext().evaluateHandle(pageFunction, this, ...args);\n  }\n  /** Fetches a single property from the referenced object.\n   */\n\n\n  async getProperty(propertyName) {\n    const objectHandle = await this.evaluateHandle((object, propertyName) => {\n      const result = {\n        __proto__: null\n      };\n      result[propertyName] = object[propertyName];\n      return result;\n    }, propertyName);\n    const properties = await objectHandle.getProperties();\n    const result = properties.get(propertyName) || null;\n    await objectHandle.dispose();\n    return result;\n  }\n  /**\n   * The method returns a map with property names as keys and JSHandle\n   * instances for the property values.\n   *\n   * @example\n   * ```js\n   * const listHandle = await page.evaluateHandle(() => document.body.children);\n   * const properties = await listHandle.getProperties();\n   * const children = [];\n   * for (const property of properties.values()) {\n   *   const element = property.asElement();\n   *   if (element)\n   *     children.push(element);\n   * }\n   * children; // holds elementHandles to all children of document.body\n   * ```\n   */\n\n\n  async getProperties() {\n    const response = await this._client.send('Runtime.getProperties', {\n      objectId: this._remoteObject.objectId,\n      ownProperties: true\n    });\n    const result = new Map();\n\n    for (const property of response.result) {\n      if (!property.enumerable) continue;\n      result.set(property.name, createJSHandle(this._context, property.value));\n    }\n\n    return result;\n  }\n  /**\n   * Returns a JSON representation of the object.\n   *\n   * @remarks\n   *\n   * The JSON is generated by running {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify | JSON.stringify}\n   * on the object in page and consequent {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse | JSON.parse} in puppeteer.\n   * **NOTE** The method throws if the referenced object is not stringifiable.\n   */\n\n\n  async jsonValue() {\n    if (this._remoteObject.objectId) {\n      const response = await this._client.send('Runtime.callFunctionOn', {\n        functionDeclaration: 'function() { return this; }',\n        objectId: this._remoteObject.objectId,\n        returnByValue: true,\n        awaitPromise: true\n      });\n      return helper_js_1.helper.valueFromRemoteObject(response.result);\n    }\n\n    return helper_js_1.helper.valueFromRemoteObject(this._remoteObject);\n  }\n  /**\n   * Returns either `null` or the object handle itself, if the object handle is\n   * an instance of {@link ElementHandle}.\n   */\n\n\n  asElement() {\n    // This always returns null, but subclasses can override this and return an\n    // ElementHandle.\n    return null;\n  }\n  /**\n   * Stops referencing the element handle, and resolves when the object handle is\n   * successfully disposed of.\n   */\n\n\n  async dispose() {\n    if (this._disposed) return;\n    this._disposed = true;\n    await helper_js_1.helper.releaseObject(this._client, this._remoteObject);\n  }\n  /**\n   * Returns a string representation of the JSHandle.\n   *\n   * @remarks Useful during debugging.\n   */\n\n\n  toString() {\n    if (this._remoteObject.objectId) {\n      const type = this._remoteObject.subtype || this._remoteObject.type;\n      return 'JSHandle@' + type;\n    }\n\n    return 'JSHandle:' + helper_js_1.helper.valueFromRemoteObject(this._remoteObject);\n  }\n\n}\n\nexports.JSHandle = JSHandle;\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n *\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *  const browser = await puppeteer.launch();\n *  const page = await browser.newPage();\n *  await page.goto('https://example.com');\n *  const hrefElement = await page.$('a');\n *  await hrefElement.click();\n *  // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\n\nclass ElementHandle extends JSHandle {\n  /**\n   * @internal\n   */\n  constructor(context, client, remoteObject, page, frameManager) {\n    super(context, client, remoteObject);\n    this._client = client;\n    this._remoteObject = remoteObject;\n    this._page = page;\n    this._frameManager = frameManager;\n  }\n\n  asElement() {\n    return this;\n  }\n  /**\n   * Resolves to the content frame for element handles referencing\n   * iframe nodes, or null otherwise\n   */\n\n\n  async contentFrame() {\n    const nodeInfo = await this._client.send('DOM.describeNode', {\n      objectId: this._remoteObject.objectId\n    });\n    if (typeof nodeInfo.node.frameId !== 'string') return null;\n    return this._frameManager.frame(nodeInfo.node.frameId);\n  }\n\n  async _scrollIntoViewIfNeeded() {\n    const error = await this.evaluate(async (element, pageJavascriptEnabled) => {\n      if (!element.isConnected) return 'Node is detached from document';\n      if (element.nodeType !== Node.ELEMENT_NODE) return 'Node is not of type HTMLElement'; // force-scroll if page's javascript is disabled.\n\n      if (!pageJavascriptEnabled) {\n        element.scrollIntoView({\n          block: 'center',\n          inline: 'center',\n          // @ts-expect-error Chrome still supports behavior: instant but\n          // it's not in the spec so TS shouts We don't want to make this\n          // breaking change in Puppeteer yet so we'll ignore the line.\n          behavior: 'instant'\n        });\n        return false;\n      }\n\n      const visibleRatio = await new Promise(resolve => {\n        const observer = new IntersectionObserver(entries => {\n          resolve(entries[0].intersectionRatio);\n          observer.disconnect();\n        });\n        observer.observe(element);\n      });\n\n      if (visibleRatio !== 1.0) {\n        element.scrollIntoView({\n          block: 'center',\n          inline: 'center',\n          // @ts-expect-error Chrome still supports behavior: instant but\n          // it's not in the spec so TS shouts We don't want to make this\n          // breaking change in Puppeteer yet so we'll ignore the line.\n          behavior: 'instant'\n        });\n      }\n\n      return false;\n    }, this._page.isJavaScriptEnabled());\n    if (error) throw new Error(error);\n  }\n\n  async _clickablePoint() {\n    const [result, layoutMetrics] = await Promise.all([this._client.send('DOM.getContentQuads', {\n      objectId: this._remoteObject.objectId\n    }).catch(helper_js_1.debugError), this._client.send('Page.getLayoutMetrics')]);\n    if (!result || !result.quads.length) throw new Error('Node is either not visible or not an HTMLElement'); // Filter out quads that have too small area to click into.\n\n    const {\n      clientWidth,\n      clientHeight\n    } = layoutMetrics.layoutViewport;\n    const quads = result.quads.map(quad => this._fromProtocolQuad(quad)).map(quad => this._intersectQuadWithViewport(quad, clientWidth, clientHeight)).filter(quad => computeQuadArea(quad) > 1);\n    if (!quads.length) throw new Error('Node is either not visible or not an HTMLElement'); // Return the middle point of the first quad.\n\n    const quad = quads[0];\n    let x = 0;\n    let y = 0;\n\n    for (const point of quad) {\n      x += point.x;\n      y += point.y;\n    }\n\n    return {\n      x: x / 4,\n      y: y / 4\n    };\n  }\n\n  _getBoxModel() {\n    const params = {\n      objectId: this._remoteObject.objectId\n    };\n    return this._client.send('DOM.getBoxModel', params).catch(error => helper_js_1.debugError(error));\n  }\n\n  _fromProtocolQuad(quad) {\n    return [{\n      x: quad[0],\n      y: quad[1]\n    }, {\n      x: quad[2],\n      y: quad[3]\n    }, {\n      x: quad[4],\n      y: quad[5]\n    }, {\n      x: quad[6],\n      y: quad[7]\n    }];\n  }\n\n  _intersectQuadWithViewport(quad, width, height) {\n    return quad.map(point => ({\n      x: Math.min(Math.max(point.x, 0), width),\n      y: Math.min(Math.max(point.y, 0), height)\n    }));\n  }\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n\n\n  async hover() {\n    await this._scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this._clickablePoint();\n    await this._page.mouse.move(x, y);\n  }\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n\n\n  async click(options = {}) {\n    await this._scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this._clickablePoint();\n    await this._page.mouse.click(x, y, options);\n  }\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   * ```js\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   * @param values - Values of options to select. If the `<select>` has the\n   *    `multiple` attribute, all values are considered, otherwise only the first\n   *    one is taken into account.\n   */\n\n\n  async select(...values) {\n    for (const value of values) assert_js_1.assert(helper_js_1.helper.isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n\n    return this.evaluate((element, values) => {\n      if (element.nodeName.toLowerCase() !== 'select') throw new Error('Element is not a <select> element.');\n      const options = Array.from(element.options);\n      element.value = undefined;\n\n      for (const option of options) {\n        option.selected = values.includes(option.value);\n        if (option.selected && !element.multiple) break;\n      }\n\n      element.dispatchEvent(new Event('input', {\n        bubbles: true\n      }));\n      element.dispatchEvent(new Event('change', {\n        bubbles: true\n      }));\n      return options.filter(option => option.selected).map(option => option.value);\n    }, values);\n  }\n  /**\n   * This method expects `elementHandle` to point to an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}.\n   * @param filePaths - Sets the value of the file input to these paths.\n   *    If some of the  `filePaths` are relative paths, then they are resolved\n   *    relative to the {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}\n   */\n\n\n  async uploadFile(...filePaths) {\n    const isMultiple = await this.evaluate(element => element.multiple);\n    assert_js_1.assert(filePaths.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');\n\n    if (!environment_js_1.isNode) {\n      throw new Error(`JSHandle#uploadFile can only be used in Node environments.`);\n    } // This import is only needed for `uploadFile`, so keep it scoped here to avoid paying\n    // the cost unnecessarily.\n\n\n    const path = await Promise.resolve().then(() => __importStar(require('path')));\n    const fs = await helper_js_1.helper.importFSModule(); // Locate all files and confirm that they exist.\n\n    const files = await Promise.all(filePaths.map(async filePath => {\n      const resolvedPath = path.resolve(filePath);\n\n      try {\n        await fs.promises.access(resolvedPath, fs.constants.R_OK);\n      } catch (error) {\n        if (error.code === 'ENOENT') throw new Error(`${filePath} does not exist or is not readable`);\n      }\n\n      return resolvedPath;\n    }));\n    const {\n      objectId\n    } = this._remoteObject;\n    const {\n      node\n    } = await this._client.send('DOM.describeNode', {\n      objectId\n    });\n    const {\n      backendNodeId\n    } = node; // The zero-length array is a special case, it seems that DOM.setFileInputFiles does\n    // not actually update the files in that case, so the solution is to eval the element\n    // value to a new FileList directly.\n\n    if (files.length === 0) {\n      await this.evaluate(element => {\n        element.files = new DataTransfer().files; // Dispatch events for this case because it should behave akin to a user action.\n\n        element.dispatchEvent(new Event('input', {\n          bubbles: true\n        }));\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n      });\n    } else {\n      await this._client.send('DOM.setFileInputFiles', {\n        objectId,\n        files,\n        backendNodeId\n      });\n    }\n  }\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n\n\n  async tap() {\n    await this._scrollIntoViewIfNeeded();\n    const {\n      x,\n      y\n    } = await this._clickablePoint();\n    await this._page.touchscreen.tap(x, y);\n  }\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n\n\n  async focus() {\n    await this.evaluate(element => element.focus());\n  }\n  /**\n   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n   * `keyup` event for each character in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`,\n   * use {@link ElementHandle.press}.\n   *\n   * @example\n   * ```js\n   * await elementHandle.type('Hello'); // Types instantly\n   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @example\n   * An example of typing into a text field and then submitting the form:\n   *\n   * ```js\n   * const elementHandle = await page.$('input');\n   * await elementHandle.type('some text');\n   * await elementHandle.press('Enter');\n   * ```\n   */\n\n\n  async type(text, options) {\n    await this.focus();\n    await this._page.keyboard.type(text, options);\n  }\n  /**\n   * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n   *\n   * @remarks\n   * If `key` is a single character and no modifier keys besides `Shift`\n   * are being held down, a `keypress`/`input` event will also be generated.\n   * The `text` option can be specified to force an input event to be generated.\n   *\n   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n   * will type the text in upper case.\n   *\n   * @param key - Name of key to press, such as `ArrowLeft`.\n   *    See {@link KeyInput} for a list of all key names.\n   */\n\n\n  async press(key, options) {\n    await this.focus();\n    await this._page.keyboard.press(key, options);\n  }\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is not visible.\n   */\n\n\n  async boundingBox() {\n    const result = await this._getBoxModel();\n    if (!result) return null;\n    const quad = result.model.border;\n    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);\n    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);\n    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;\n    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  }\n  /**\n   * This method returns boxes of the element, or `null` if the element is not visible.\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n\n\n  async boxModel() {\n    const result = await this._getBoxModel();\n    if (!result) return null;\n    const {\n      content,\n      padding,\n      border,\n      margin,\n      width,\n      height\n    } = result.model;\n    return {\n      content: this._fromProtocolQuad(content),\n      padding: this._fromProtocolQuad(padding),\n      border: this._fromProtocolQuad(border),\n      margin: this._fromProtocolQuad(margin),\n      width,\n      height\n    };\n  }\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Page.screenshot} to take a screenshot of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n\n\n  async screenshot(options = {}) {\n    let needsViewportReset = false;\n    let boundingBox = await this.boundingBox();\n    assert_js_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n\n    const viewport = this._page.viewport();\n\n    if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {\n      const newViewport = {\n        width: Math.max(viewport.width, Math.ceil(boundingBox.width)),\n        height: Math.max(viewport.height, Math.ceil(boundingBox.height))\n      };\n      await this._page.setViewport(Object.assign({}, viewport, newViewport));\n      needsViewportReset = true;\n    }\n\n    await this._scrollIntoViewIfNeeded();\n    boundingBox = await this.boundingBox();\n    assert_js_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n    assert_js_1.assert(boundingBox.width !== 0, 'Node has 0 width.');\n    assert_js_1.assert(boundingBox.height !== 0, 'Node has 0 height.');\n    const {\n      layoutViewport: {\n        pageX,\n        pageY\n      }\n    } = await this._client.send('Page.getLayoutMetrics');\n    const clip = Object.assign({}, boundingBox);\n    clip.x += pageX;\n    clip.y += pageY;\n    const imageData = await this._page.screenshot(Object.assign({}, {\n      clip\n    }, options));\n    if (needsViewportReset) await this._page.setViewport(viewport);\n    return imageData;\n  }\n  /**\n   * Runs `element.querySelector` within the page. If no element matches the selector,\n   * the return value resolves to `null`.\n   */\n\n\n  async $(selector) {\n    const {\n      updatedSelector,\n      queryHandler\n    } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n    return queryHandler.queryOne(this, updatedSelector);\n  }\n  /**\n   * Runs `element.querySelectorAll` within the page. If no elements match the selector,\n   * the return value resolves to `[]`.\n   */\n\n\n  async $$(selector) {\n    const {\n      updatedSelector,\n      queryHandler\n    } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n    return queryHandler.queryAll(this, updatedSelector);\n  }\n  /**\n   * This method runs `document.querySelector` within the element and passes it as\n   * the first argument to `pageFunction`. If there's no element matching `selector`,\n   * the method throws an error.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise\n   * to resolve and return its value.\n   *\n   * @example\n   * ```js\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');\n   * ```\n   */\n\n\n  async $eval(selector, pageFunction, ...args) {\n    const elementHandle = await this.$(selector);\n    if (!elementHandle) throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n    const result = await elementHandle.evaluate(pageFunction, ...args);\n    await elementHandle.dispose();\n    /**\n     * This `as` is a little unfortunate but helps TS understand the behavior of\n     * `elementHandle.evaluate`. If evaluate returns an element it will return an\n     * ElementHandle instance, rather than the plain object. All the\n     * WrapElementHandle type does is wrap ReturnType into\n     * ElementHandle<ReturnType> if it is an ElementHandle, or leave it alone as\n     * ReturnType if it isn't.\n     */\n\n    return result;\n  }\n  /**\n   * This method runs `document.querySelectorAll` within the element and passes it as\n   * the first argument to `pageFunction`. If there's no element matching `selector`,\n   * the method throws an error.\n   *\n   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the\n   * promise to resolve and return its value.\n   *\n   * @example\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * @example\n   * ```js\n   * const feedHandle = await page.$('.feed');\n   * expect(await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)))\n   *  .toEqual(['Hello!', 'Hi!']);\n   * ```\n   */\n\n\n  async $$eval(selector, pageFunction, ...args) {\n    const {\n      updatedSelector,\n      queryHandler\n    } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n    const arrayHandle = await queryHandler.queryAllArray(this, updatedSelector);\n    const result = await arrayHandle.evaluate(pageFunction, ...args);\n    await arrayHandle.dispose();\n    /* This `as` exists for the same reason as the `as` in $eval above.\n     * See the comment there for a full explanation.\n     */\n\n    return result;\n  }\n  /**\n   * The method evaluates the XPath expression relative to the elementHandle.\n   * If there are no such elements, the method will resolve to an empty array.\n   * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}\n   */\n\n\n  async $x(expression) {\n    const arrayHandle = await this.evaluateHandle((element, expression) => {\n      const document = element.ownerDocument || element;\n      const iterator = document.evaluate(expression, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n      const array = [];\n      let item;\n\n      while (item = iterator.iterateNext()) array.push(item);\n\n      return array;\n    }, expression);\n    const properties = await arrayHandle.getProperties();\n    await arrayHandle.dispose();\n    const result = [];\n\n    for (const property of properties.values()) {\n      const elementHandle = property.asElement();\n      if (elementHandle) result.push(elementHandle);\n    }\n\n    return result;\n  }\n  /**\n   * Resolves to true if the element is visible in the current viewport.\n   */\n\n\n  async isIntersectingViewport() {\n    return await this.evaluate(async element => {\n      const visibleRatio = await new Promise(resolve => {\n        const observer = new IntersectionObserver(entries => {\n          resolve(entries[0].intersectionRatio);\n          observer.disconnect();\n        });\n        observer.observe(element);\n      });\n      return visibleRatio > 0;\n    });\n  }\n\n}\n\nexports.ElementHandle = ElementHandle;\n\nfunction computeQuadArea(quad) {\n  // Compute sum of all directed areas of adjacent triangles\n  // https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n  let area = 0;\n\n  for (let i = 0; i < quad.length; ++i) {\n    const p1 = quad[i];\n    const p2 = quad[(i + 1) % quad.length];\n    area += (p1.x * p2.y - p2.x * p1.y) / 2;\n  }\n\n  return Math.abs(area);\n}","map":{"version":3,"sources":["../../../../src/common/JSHandle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ElementHandle = exports.JSHandle = exports.createJSHandle = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst QueryHandler_js_1 = require(\"./QueryHandler.js\");\nconst environment_js_1 = require(\"../environment.js\");\n/**\n * @internal\n */\nfunction createJSHandle(context, remoteObject) {\n    const frame = context.frame();\n    if (remoteObject.subtype === 'node' && frame) {\n        const frameManager = frame._frameManager;\n        return new ElementHandle(context, context._client, remoteObject, frameManager.page(), frameManager);\n    }\n    return new JSHandle(context, context._client, remoteObject);\n}\nexports.createJSHandle = createJSHandle;\n/**\n * Represents an in-page JavaScript object. JSHandles can be created with the\n * {@link Page.evaluateHandle | page.evaluateHandle} method.\n *\n * @example\n * ```js\n * const windowHandle = await page.evaluateHandle(() => window);\n * ```\n *\n * JSHandle prevents the referenced JavaScript object from being garbage-collected\n * unless the handle is {@link JSHandle.dispose | disposed}. JSHandles are auto-\n * disposed when their origin frame gets navigated or the parent context gets destroyed.\n *\n * JSHandle instances can be used as arguments for {@link Page.$eval},\n * {@link Page.evaluate}, and {@link Page.evaluateHandle}.\n *\n * @public\n */\nclass JSHandle {\n    /**\n     * @internal\n     */\n    constructor(context, client, remoteObject) {\n        /**\n         * @internal\n         */\n        this._disposed = false;\n        this._context = context;\n        this._client = client;\n        this._remoteObject = remoteObject;\n    }\n    /** Returns the execution context the handle belongs to.\n     */\n    executionContext() {\n        return this._context;\n    }\n    /**\n     * This method passes this handle as the first argument to `pageFunction`.\n     * If `pageFunction` returns a Promise, then `handle.evaluate` would wait\n     * for the promise to resolve and return its value.\n     *\n     * @example\n     * ```js\n     * const tweetHandle = await page.$('.tweet .retweets');\n     * expect(await tweetHandle.evaluate(node => node.innerText)).toBe('10');\n     * ```\n     */\n    async evaluate(pageFunction, ...args) {\n        return await this.executionContext().evaluate(pageFunction, this, ...args);\n    }\n    /**\n     * This method passes this handle as the first argument to `pageFunction`.\n     *\n     * @remarks\n     *\n     * The only difference between `jsHandle.evaluate` and\n     * `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle`\n     * returns an in-page object (JSHandle).\n     *\n     * If the function passed to `jsHandle.evaluateHandle` returns a Promise,\n     * then `evaluateHandle.evaluateHandle` waits for the promise to resolve and\n     * returns its value.\n     *\n     * See {@link Page.evaluateHandle} for more details.\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return await this.executionContext().evaluateHandle(pageFunction, this, ...args);\n    }\n    /** Fetches a single property from the referenced object.\n     */\n    async getProperty(propertyName) {\n        const objectHandle = await this.evaluateHandle((object, propertyName) => {\n            const result = { __proto__: null };\n            result[propertyName] = object[propertyName];\n            return result;\n        }, propertyName);\n        const properties = await objectHandle.getProperties();\n        const result = properties.get(propertyName) || null;\n        await objectHandle.dispose();\n        return result;\n    }\n    /**\n     * The method returns a map with property names as keys and JSHandle\n     * instances for the property values.\n     *\n     * @example\n     * ```js\n     * const listHandle = await page.evaluateHandle(() => document.body.children);\n     * const properties = await listHandle.getProperties();\n     * const children = [];\n     * for (const property of properties.values()) {\n     *   const element = property.asElement();\n     *   if (element)\n     *     children.push(element);\n     * }\n     * children; // holds elementHandles to all children of document.body\n     * ```\n     */\n    async getProperties() {\n        const response = await this._client.send('Runtime.getProperties', {\n            objectId: this._remoteObject.objectId,\n            ownProperties: true,\n        });\n        const result = new Map();\n        for (const property of response.result) {\n            if (!property.enumerable)\n                continue;\n            result.set(property.name, createJSHandle(this._context, property.value));\n        }\n        return result;\n    }\n    /**\n     * Returns a JSON representation of the object.\n     *\n     * @remarks\n     *\n     * The JSON is generated by running {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify | JSON.stringify}\n     * on the object in page and consequent {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse | JSON.parse} in puppeteer.\n     * **NOTE** The method throws if the referenced object is not stringifiable.\n     */\n    async jsonValue() {\n        if (this._remoteObject.objectId) {\n            const response = await this._client.send('Runtime.callFunctionOn', {\n                functionDeclaration: 'function() { return this; }',\n                objectId: this._remoteObject.objectId,\n                returnByValue: true,\n                awaitPromise: true,\n            });\n            return helper_js_1.helper.valueFromRemoteObject(response.result);\n        }\n        return helper_js_1.helper.valueFromRemoteObject(this._remoteObject);\n    }\n    /**\n     * Returns either `null` or the object handle itself, if the object handle is\n     * an instance of {@link ElementHandle}.\n     */\n    asElement() {\n        // This always returns null, but subclasses can override this and return an\n        // ElementHandle.\n        return null;\n    }\n    /**\n     * Stops referencing the element handle, and resolves when the object handle is\n     * successfully disposed of.\n     */\n    async dispose() {\n        if (this._disposed)\n            return;\n        this._disposed = true;\n        await helper_js_1.helper.releaseObject(this._client, this._remoteObject);\n    }\n    /**\n     * Returns a string representation of the JSHandle.\n     *\n     * @remarks Useful during debugging.\n     */\n    toString() {\n        if (this._remoteObject.objectId) {\n            const type = this._remoteObject.subtype || this._remoteObject.type;\n            return 'JSHandle@' + type;\n        }\n        return 'JSHandle:' + helper_js_1.helper.valueFromRemoteObject(this._remoteObject);\n    }\n}\nexports.JSHandle = JSHandle;\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n *\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```js\n * const puppeteer = require('puppeteer');\n *\n * (async () => {\n *  const browser = await puppeteer.launch();\n *  const page = await browser.newPage();\n *  await page.goto('https://example.com');\n *  const hrefElement = await page.$('a');\n *  await hrefElement.click();\n *  // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nclass ElementHandle extends JSHandle {\n    /**\n     * @internal\n     */\n    constructor(context, client, remoteObject, page, frameManager) {\n        super(context, client, remoteObject);\n        this._client = client;\n        this._remoteObject = remoteObject;\n        this._page = page;\n        this._frameManager = frameManager;\n    }\n    asElement() {\n        return this;\n    }\n    /**\n     * Resolves to the content frame for element handles referencing\n     * iframe nodes, or null otherwise\n     */\n    async contentFrame() {\n        const nodeInfo = await this._client.send('DOM.describeNode', {\n            objectId: this._remoteObject.objectId,\n        });\n        if (typeof nodeInfo.node.frameId !== 'string')\n            return null;\n        return this._frameManager.frame(nodeInfo.node.frameId);\n    }\n    async _scrollIntoViewIfNeeded() {\n        const error = await this.evaluate(async (element, pageJavascriptEnabled) => {\n            if (!element.isConnected)\n                return 'Node is detached from document';\n            if (element.nodeType !== Node.ELEMENT_NODE)\n                return 'Node is not of type HTMLElement';\n            // force-scroll if page's javascript is disabled.\n            if (!pageJavascriptEnabled) {\n                element.scrollIntoView({\n                    block: 'center',\n                    inline: 'center',\n                    // @ts-expect-error Chrome still supports behavior: instant but\n                    // it's not in the spec so TS shouts We don't want to make this\n                    // breaking change in Puppeteer yet so we'll ignore the line.\n                    behavior: 'instant',\n                });\n                return false;\n            }\n            const visibleRatio = await new Promise((resolve) => {\n                const observer = new IntersectionObserver((entries) => {\n                    resolve(entries[0].intersectionRatio);\n                    observer.disconnect();\n                });\n                observer.observe(element);\n            });\n            if (visibleRatio !== 1.0) {\n                element.scrollIntoView({\n                    block: 'center',\n                    inline: 'center',\n                    // @ts-expect-error Chrome still supports behavior: instant but\n                    // it's not in the spec so TS shouts We don't want to make this\n                    // breaking change in Puppeteer yet so we'll ignore the line.\n                    behavior: 'instant',\n                });\n            }\n            return false;\n        }, this._page.isJavaScriptEnabled());\n        if (error)\n            throw new Error(error);\n    }\n    async _clickablePoint() {\n        const [result, layoutMetrics] = await Promise.all([\n            this._client\n                .send('DOM.getContentQuads', {\n                objectId: this._remoteObject.objectId,\n            })\n                .catch(helper_js_1.debugError),\n            this._client.send('Page.getLayoutMetrics'),\n        ]);\n        if (!result || !result.quads.length)\n            throw new Error('Node is either not visible or not an HTMLElement');\n        // Filter out quads that have too small area to click into.\n        const { clientWidth, clientHeight } = layoutMetrics.layoutViewport;\n        const quads = result.quads\n            .map((quad) => this._fromProtocolQuad(quad))\n            .map((quad) => this._intersectQuadWithViewport(quad, clientWidth, clientHeight))\n            .filter((quad) => computeQuadArea(quad) > 1);\n        if (!quads.length)\n            throw new Error('Node is either not visible or not an HTMLElement');\n        // Return the middle point of the first quad.\n        const quad = quads[0];\n        let x = 0;\n        let y = 0;\n        for (const point of quad) {\n            x += point.x;\n            y += point.y;\n        }\n        return {\n            x: x / 4,\n            y: y / 4,\n        };\n    }\n    _getBoxModel() {\n        const params = {\n            objectId: this._remoteObject.objectId,\n        };\n        return this._client\n            .send('DOM.getBoxModel', params)\n            .catch((error) => helper_js_1.debugError(error));\n    }\n    _fromProtocolQuad(quad) {\n        return [\n            { x: quad[0], y: quad[1] },\n            { x: quad[2], y: quad[3] },\n            { x: quad[4], y: quad[5] },\n            { x: quad[6], y: quad[7] },\n        ];\n    }\n    _intersectQuadWithViewport(quad, width, height) {\n        return quad.map((point) => ({\n            x: Math.min(Math.max(point.x, 0), width),\n            y: Math.min(Math.max(point.y, 0), height),\n        }));\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page.mouse} to hover over the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async hover() {\n        await this._scrollIntoViewIfNeeded();\n        const { x, y } = await this._clickablePoint();\n        await this._page.mouse.move(x, y);\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page.mouse} to click in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async click(options = {}) {\n        await this._scrollIntoViewIfNeeded();\n        const { x, y } = await this._clickablePoint();\n        await this._page.mouse.click(x, y, options);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     * ```js\n     * handle.select('blue'); // single selection\n     * handle.select('red', 'green', 'blue'); // multiple selections\n     * ```\n     * @param values - Values of options to select. If the `<select>` has the\n     *    `multiple` attribute, all values are considered, otherwise only the first\n     *    one is taken into account.\n     */\n    async select(...values) {\n        for (const value of values)\n            assert_js_1.assert(helper_js_1.helper.isString(value), 'Values must be strings. Found value \"' +\n                value +\n                '\" of type \"' +\n                typeof value +\n                '\"');\n        return this.evaluate((element, values) => {\n            if (element.nodeName.toLowerCase() !== 'select')\n                throw new Error('Element is not a <select> element.');\n            const options = Array.from(element.options);\n            element.value = undefined;\n            for (const option of options) {\n                option.selected = values.includes(option.value);\n                if (option.selected && !element.multiple)\n                    break;\n            }\n            element.dispatchEvent(new Event('input', { bubbles: true }));\n            element.dispatchEvent(new Event('change', { bubbles: true }));\n            return options\n                .filter((option) => option.selected)\n                .map((option) => option.value);\n        }, values);\n    }\n    /**\n     * This method expects `elementHandle` to point to an\n     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}.\n     * @param filePaths - Sets the value of the file input to these paths.\n     *    If some of the  `filePaths` are relative paths, then they are resolved\n     *    relative to the {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}\n     */\n    async uploadFile(...filePaths) {\n        const isMultiple = await this.evaluate((element) => element.multiple);\n        assert_js_1.assert(filePaths.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');\n        if (!environment_js_1.isNode) {\n            throw new Error(`JSHandle#uploadFile can only be used in Node environments.`);\n        }\n        // This import is only needed for `uploadFile`, so keep it scoped here to avoid paying\n        // the cost unnecessarily.\n        const path = await Promise.resolve().then(() => __importStar(require('path')));\n        const fs = await helper_js_1.helper.importFSModule();\n        // Locate all files and confirm that they exist.\n        const files = await Promise.all(filePaths.map(async (filePath) => {\n            const resolvedPath = path.resolve(filePath);\n            try {\n                await fs.promises.access(resolvedPath, fs.constants.R_OK);\n            }\n            catch (error) {\n                if (error.code === 'ENOENT')\n                    throw new Error(`${filePath} does not exist or is not readable`);\n            }\n            return resolvedPath;\n        }));\n        const { objectId } = this._remoteObject;\n        const { node } = await this._client.send('DOM.describeNode', { objectId });\n        const { backendNodeId } = node;\n        // The zero-length array is a special case, it seems that DOM.setFileInputFiles does\n        // not actually update the files in that case, so the solution is to eval the element\n        // value to a new FileList directly.\n        if (files.length === 0) {\n            await this.evaluate((element) => {\n                element.files = new DataTransfer().files;\n                // Dispatch events for this case because it should behave akin to a user action.\n                element.dispatchEvent(new Event('input', { bubbles: true }));\n                element.dispatchEvent(new Event('change', { bubbles: true }));\n            });\n        }\n        else {\n            await this._client.send('DOM.setFileInputFiles', {\n                objectId,\n                files,\n                backendNodeId,\n            });\n        }\n    }\n    /**\n     * This method scrolls element into view if needed, and then uses\n     * {@link Touchscreen.tap} to tap in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async tap() {\n        await this._scrollIntoViewIfNeeded();\n        const { x, y } = await this._clickablePoint();\n        await this._page.touchscreen.tap(x, y);\n    }\n    /**\n     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n     */\n    async focus() {\n        await this.evaluate((element) => element.focus());\n    }\n    /**\n     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n     * `keyup` event for each character in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`,\n     * use {@link ElementHandle.press}.\n     *\n     * @example\n     * ```js\n     * await elementHandle.type('Hello'); // Types instantly\n     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @example\n     * An example of typing into a text field and then submitting the form:\n     *\n     * ```js\n     * const elementHandle = await page.$('input');\n     * await elementHandle.type('some text');\n     * await elementHandle.press('Enter');\n     * ```\n     */\n    async type(text, options) {\n        await this.focus();\n        await this._page.keyboard.type(text, options);\n    }\n    /**\n     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n     *\n     * @remarks\n     * If `key` is a single character and no modifier keys besides `Shift`\n     * are being held down, a `keypress`/`input` event will also be generated.\n     * The `text` option can be specified to force an input event to be generated.\n     *\n     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n     * will type the text in upper case.\n     *\n     * @param key - Name of key to press, such as `ArrowLeft`.\n     *    See {@link KeyInput} for a list of all key names.\n     */\n    async press(key, options) {\n        await this.focus();\n        await this._page.keyboard.press(key, options);\n    }\n    /**\n     * This method returns the bounding box of the element (relative to the main frame),\n     * or `null` if the element is not visible.\n     */\n    async boundingBox() {\n        const result = await this._getBoxModel();\n        if (!result)\n            return null;\n        const quad = result.model.border;\n        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);\n        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);\n        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;\n        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;\n        return { x, y, width, height };\n    }\n    /**\n     * This method returns boxes of the element, or `null` if the element is not visible.\n     *\n     * @remarks\n     *\n     * Boxes are represented as an array of points;\n     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n     */\n    async boxModel() {\n        const result = await this._getBoxModel();\n        if (!result)\n            return null;\n        const { content, padding, border, margin, width, height } = result.model;\n        return {\n            content: this._fromProtocolQuad(content),\n            padding: this._fromProtocolQuad(padding),\n            border: this._fromProtocolQuad(border),\n            margin: this._fromProtocolQuad(margin),\n            width,\n            height,\n        };\n    }\n    /**\n     * This method scrolls element into view if needed, and then uses\n     * {@link Page.screenshot} to take a screenshot of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async screenshot(options = {}) {\n        let needsViewportReset = false;\n        let boundingBox = await this.boundingBox();\n        assert_js_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n        const viewport = this._page.viewport();\n        if (viewport &&\n            (boundingBox.width > viewport.width ||\n                boundingBox.height > viewport.height)) {\n            const newViewport = {\n                width: Math.max(viewport.width, Math.ceil(boundingBox.width)),\n                height: Math.max(viewport.height, Math.ceil(boundingBox.height)),\n            };\n            await this._page.setViewport(Object.assign({}, viewport, newViewport));\n            needsViewportReset = true;\n        }\n        await this._scrollIntoViewIfNeeded();\n        boundingBox = await this.boundingBox();\n        assert_js_1.assert(boundingBox, 'Node is either not visible or not an HTMLElement');\n        assert_js_1.assert(boundingBox.width !== 0, 'Node has 0 width.');\n        assert_js_1.assert(boundingBox.height !== 0, 'Node has 0 height.');\n        const { layoutViewport: { pageX, pageY }, } = await this._client.send('Page.getLayoutMetrics');\n        const clip = Object.assign({}, boundingBox);\n        clip.x += pageX;\n        clip.y += pageY;\n        const imageData = await this._page.screenshot(Object.assign({}, {\n            clip,\n        }, options));\n        if (needsViewportReset)\n            await this._page.setViewport(viewport);\n        return imageData;\n    }\n    /**\n     * Runs `element.querySelector` within the page. If no element matches the selector,\n     * the return value resolves to `null`.\n     */\n    async $(selector) {\n        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n        return queryHandler.queryOne(this, updatedSelector);\n    }\n    /**\n     * Runs `element.querySelectorAll` within the page. If no elements match the selector,\n     * the return value resolves to `[]`.\n     */\n    async $$(selector) {\n        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n        return queryHandler.queryAll(this, updatedSelector);\n    }\n    /**\n     * This method runs `document.querySelector` within the element and passes it as\n     * the first argument to `pageFunction`. If there's no element matching `selector`,\n     * the method throws an error.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise\n     * to resolve and return its value.\n     *\n     * @example\n     * ```js\n     * const tweetHandle = await page.$('.tweet');\n     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');\n     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');\n     * ```\n     */\n    async $eval(selector, pageFunction, ...args) {\n        const elementHandle = await this.$(selector);\n        if (!elementHandle)\n            throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n        const result = await elementHandle.evaluate(pageFunction, ...args);\n        await elementHandle.dispose();\n        /**\n         * This `as` is a little unfortunate but helps TS understand the behavior of\n         * `elementHandle.evaluate`. If evaluate returns an element it will return an\n         * ElementHandle instance, rather than the plain object. All the\n         * WrapElementHandle type does is wrap ReturnType into\n         * ElementHandle<ReturnType> if it is an ElementHandle, or leave it alone as\n         * ReturnType if it isn't.\n         */\n        return result;\n    }\n    /**\n     * This method runs `document.querySelectorAll` within the element and passes it as\n     * the first argument to `pageFunction`. If there's no element matching `selector`,\n     * the method throws an error.\n     *\n     * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the\n     * promise to resolve and return its value.\n     *\n     * @example\n     * ```html\n     * <div class=\"feed\">\n     *   <div class=\"tweet\">Hello!</div>\n     *   <div class=\"tweet\">Hi!</div>\n     * </div>\n     * ```\n     *\n     * @example\n     * ```js\n     * const feedHandle = await page.$('.feed');\n     * expect(await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText)))\n     *  .toEqual(['Hello!', 'Hi!']);\n     * ```\n     */\n    async $$eval(selector, pageFunction, ...args) {\n        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n        const arrayHandle = await queryHandler.queryAllArray(this, updatedSelector);\n        const result = await arrayHandle.evaluate(pageFunction, ...args);\n        await arrayHandle.dispose();\n        /* This `as` exists for the same reason as the `as` in $eval above.\n         * See the comment there for a full explanation.\n         */\n        return result;\n    }\n    /**\n     * The method evaluates the XPath expression relative to the elementHandle.\n     * If there are no such elements, the method will resolve to an empty array.\n     * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}\n     */\n    async $x(expression) {\n        const arrayHandle = await this.evaluateHandle((element, expression) => {\n            const document = element.ownerDocument || element;\n            const iterator = document.evaluate(expression, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n            const array = [];\n            let item;\n            while ((item = iterator.iterateNext()))\n                array.push(item);\n            return array;\n        }, expression);\n        const properties = await arrayHandle.getProperties();\n        await arrayHandle.dispose();\n        const result = [];\n        for (const property of properties.values()) {\n            const elementHandle = property.asElement();\n            if (elementHandle)\n                result.push(elementHandle);\n        }\n        return result;\n    }\n    /**\n     * Resolves to true if the element is visible in the current viewport.\n     */\n    async isIntersectingViewport() {\n        return await this.evaluate(async (element) => {\n            const visibleRatio = await new Promise((resolve) => {\n                const observer = new IntersectionObserver((entries) => {\n                    resolve(entries[0].intersectionRatio);\n                    observer.disconnect();\n                });\n                observer.observe(element);\n            });\n            return visibleRatio > 0;\n        });\n    }\n}\nexports.ElementHandle = ElementHandle;\nfunction computeQuadArea(quad) {\n    // Compute sum of all directed areas of adjacent triangles\n    // https://en.wikipedia.org/wiki/Polygon#Simple_polygons\n    let area = 0;\n    for (let i = 0; i < quad.length; ++i) {\n        const p1 = quad[i];\n        const p2 = quad[(i + 1) % quad.length];\n        area += (p1.x * p2.y - p2.x * p1.y) / 2;\n    }\n    return Math.abs(area);\n}\n//# sourceMappingURL=JSHandle.js.map"]},"metadata":{},"sourceType":"script"}