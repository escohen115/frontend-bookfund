{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ariaHandler = void 0;\n\nasync function queryAXTree(client, element, accessibleName, role) {\n  const {\n    nodes\n  } = await client.send('Accessibility.queryAXTree', {\n    objectId: element._remoteObject.objectId,\n    accessibleName,\n    role\n  });\n  const filteredNodes = nodes.filter(node => node.role.value !== 'text');\n  return filteredNodes;\n}\n\nfunction parseAriaSelector(selector) {\n  const normalize = value => value.replace(/ +/g, ' ').trim();\n\n  const knownAttributes = new Set(['name', 'role']);\n  const queryOptions = {};\n  const attributeRegexp = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*\"(?<value>\\\\.|[^\"\\\\]*)\"\\s*\\]/;\n  const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {\n    attribute = attribute.trim();\n    if (!knownAttributes.has(attribute)) throw new Error('Unkown aria attribute \"${groups.attribute}\" in selector');\n    queryOptions[attribute] = normalize(value);\n    return '';\n  });\n  if (defaultName && !queryOptions.name) queryOptions.name = normalize(defaultName);\n  return queryOptions;\n}\n\nconst queryOne = async (element, selector) => {\n  const exeCtx = element.executionContext();\n  const {\n    name,\n    role\n  } = parseAriaSelector(selector);\n  const res = await queryAXTree(exeCtx._client, element, name, role);\n\n  if (res.length < 1) {\n    return null;\n  }\n\n  return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);\n};\n\nconst waitFor = async (domWorld, selector, options) => {\n  const binding = {\n    name: 'ariaQuerySelector',\n    pptrFunction: async selector => {\n      const document = await domWorld._document();\n      const element = await queryOne(document, selector);\n      return element;\n    }\n  };\n  return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);\n};\n\nconst queryAll = async (element, selector) => {\n  const exeCtx = element.executionContext();\n  const {\n    name,\n    role\n  } = parseAriaSelector(selector);\n  const res = await queryAXTree(exeCtx._client, element, name, role);\n  return Promise.all(res.map(axNode => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));\n};\n\nconst queryAllArray = async (element, selector) => {\n  const elementHandles = await queryAll(element, selector);\n  const exeCtx = element.executionContext();\n  const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);\n  return jsHandle;\n};\n/**\n * @internal\n */\n\n\nexports.ariaHandler = {\n  queryOne,\n  waitFor,\n  queryAll,\n  queryAllArray\n};","map":{"version":3,"sources":["../../../../src/common/AriaQueryHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ariaHandler = void 0;\nasync function queryAXTree(client, element, accessibleName, role) {\n    const { nodes } = await client.send('Accessibility.queryAXTree', {\n        objectId: element._remoteObject.objectId,\n        accessibleName,\n        role,\n    });\n    const filteredNodes = nodes.filter((node) => node.role.value !== 'text');\n    return filteredNodes;\n}\nfunction parseAriaSelector(selector) {\n    const normalize = (value) => value.replace(/ +/g, ' ').trim();\n    const knownAttributes = new Set(['name', 'role']);\n    const queryOptions = {};\n    const attributeRegexp = /\\[\\s*(?<attribute>\\w+)\\s*=\\s*\"(?<value>\\\\.|[^\"\\\\]*)\"\\s*\\]/;\n    const defaultName = selector.replace(attributeRegexp, (_, attribute, value) => {\n        attribute = attribute.trim();\n        if (!knownAttributes.has(attribute))\n            throw new Error('Unkown aria attribute \"${groups.attribute}\" in selector');\n        queryOptions[attribute] = normalize(value);\n        return '';\n    });\n    if (defaultName && !queryOptions.name)\n        queryOptions.name = normalize(defaultName);\n    return queryOptions;\n}\nconst queryOne = async (element, selector) => {\n    const exeCtx = element.executionContext();\n    const { name, role } = parseAriaSelector(selector);\n    const res = await queryAXTree(exeCtx._client, element, name, role);\n    if (res.length < 1) {\n        return null;\n    }\n    return exeCtx._adoptBackendNodeId(res[0].backendDOMNodeId);\n};\nconst waitFor = async (domWorld, selector, options) => {\n    const binding = {\n        name: 'ariaQuerySelector',\n        pptrFunction: async (selector) => {\n            const document = await domWorld._document();\n            const element = await queryOne(document, selector);\n            return element;\n        },\n    };\n    return domWorld.waitForSelectorInPage((_, selector) => globalThis.ariaQuerySelector(selector), selector, options, binding);\n};\nconst queryAll = async (element, selector) => {\n    const exeCtx = element.executionContext();\n    const { name, role } = parseAriaSelector(selector);\n    const res = await queryAXTree(exeCtx._client, element, name, role);\n    return Promise.all(res.map((axNode) => exeCtx._adoptBackendNodeId(axNode.backendDOMNodeId)));\n};\nconst queryAllArray = async (element, selector) => {\n    const elementHandles = await queryAll(element, selector);\n    const exeCtx = element.executionContext();\n    const jsHandle = exeCtx.evaluateHandle((...elements) => elements, ...elementHandles);\n    return jsHandle;\n};\n/**\n * @internal\n */\nexports.ariaHandler = {\n    queryOne,\n    waitFor,\n    queryAll,\n    queryAllArray,\n};\n//# sourceMappingURL=AriaQueryHandler.js.map"]},"metadata":{},"sourceType":"script"}