{"ast":null,"code":"var chownr = require('chownr');\n\nvar tar = require('tar-stream');\n\nvar pump = require('pump');\n\nvar mkdirp = require('mkdirp-classic');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar os = require('os');\n\nvar win32 = os.platform() === 'win32';\n\nvar noop = function () {};\n\nvar echo = function (name) {\n  return name;\n};\n\nvar normalize = !win32 ? echo : function (name) {\n  return name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_');\n};\n\nvar statAll = function (fs, stat, cwd, ignore, entries, sort) {\n  var queue = entries || ['.'];\n  return function loop(callback) {\n    if (!queue.length) return callback();\n    var next = queue.shift();\n    var nextAbs = path.join(cwd, next);\n    stat.call(fs, nextAbs, function (err, stat) {\n      if (err) return callback(err);\n      if (!stat.isDirectory()) return callback(null, next, stat);\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err);\n        if (sort) files.sort();\n\n        for (var i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));\n        }\n\n        callback(null, next, stat);\n      });\n    });\n  };\n};\n\nvar strip = function (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/');\n    var linkname = header.linkname;\n\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/');\n    }\n\n    return map(header);\n  };\n};\n\nexports.pack = function (cwd, opts) {\n  if (!cwd) cwd = '.';\n  if (!opts) opts = {};\n  var xfs = opts.fs || fs;\n  var ignore = opts.ignore || opts.filter || noop;\n  var map = opts.map || noop;\n  var mapStream = opts.mapStream || echo;\n  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);\n  var strict = opts.strict !== false;\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n  var pack = opts.pack || tar.pack();\n  var finish = opts.finish || noop;\n  if (opts.strip) map = strip(map, opts.strip);\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8);\n    fmode |= parseInt(444, 8);\n  }\n\n  if (opts.writable) {\n    dmode |= parseInt(333, 8);\n    fmode |= parseInt(222, 8);\n  }\n\n  var onsymlink = function (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err);\n      header.linkname = normalize(linkname);\n      pack.entry(header, onnextentry);\n    });\n  };\n\n  var onstat = function (err, filename, stat) {\n    if (err) return pack.destroy(err);\n\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize();\n      return finish(pack);\n    }\n\n    if (stat.isSocket()) return onnextentry(); // tar does not support sockets...\n\n    var header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    };\n\n    if (stat.isDirectory()) {\n      header.size = 0;\n      header.type = 'directory';\n      header = map(header) || header;\n      return pack.entry(header, onnextentry);\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0;\n      header.type = 'symlink';\n      header = map(header) || header;\n      return onsymlink(filename, header);\n    } // TODO: add fifo etc...\n\n\n    header = map(header) || header;\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename));\n      return onnextentry();\n    }\n\n    var entry = pack.entry(header, onnextentry);\n    if (!entry) return;\n    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), {\n      start: 0,\n      end: header.size > 0 ? header.size - 1 : header.size\n    }), header);\n    rs.on('error', function (err) {\n      // always forward errors on destroy\n      entry.destroy(err);\n    });\n    pump(rs, entry);\n  };\n\n  var onnextentry = function (err) {\n    if (err) return pack.destroy(err);\n    statNext(onstat);\n  };\n\n  onnextentry();\n  return pack;\n};\n\nvar head = function (list) {\n  return list.length ? list[list.length - 1] : null;\n};\n\nvar processGetuid = function () {\n  return process.getuid ? process.getuid() : -1;\n};\n\nvar processUmask = function () {\n  return process.umask ? process.umask() : 0;\n};\n\nexports.extract = function (cwd, opts) {\n  if (!cwd) cwd = '.';\n  if (!opts) opts = {};\n  var xfs = opts.fs || fs;\n  var ignore = opts.ignore || opts.filter || noop;\n  var map = opts.map || noop;\n  var mapStream = opts.mapStream || echo;\n  var own = opts.chown !== false && !win32 && processGetuid() === 0;\n  var extract = opts.extract || tar.extract();\n  var stack = [];\n  var now = new Date();\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;\n  var strict = opts.strict !== false;\n  if (opts.strip) map = strip(map, opts.strip);\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8);\n    fmode |= parseInt(444, 8);\n  }\n\n  if (opts.writable) {\n    dmode |= parseInt(333, 8);\n    fmode |= parseInt(222, 8);\n  }\n\n  var utimesParent = function (name, cb) {\n    // we just set the mtime on the parent dir again everytime we write an entry\n    var top;\n\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop();\n\n    if (!top) return cb();\n    xfs.utimes(top[0], now, top[1], cb);\n  };\n\n  var utimes = function (name, header, cb) {\n    if (opts.utimes === false) return cb();\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb);\n    if (header.type === 'symlink') return utimesParent(name, cb); // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err);\n      utimesParent(name, cb);\n    });\n  };\n\n  var chperm = function (name, header, cb) {\n    var link = header.type === 'symlink';\n    /* eslint-disable node/no-deprecated-api */\n\n    var chmod = link ? xfs.lchmod : xfs.chmod;\n    var chown = link ? xfs.lchown : xfs.chown;\n    /* eslint-enable node/no-deprecated-api */\n\n    if (!chmod) return cb();\n    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask;\n    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown);else onchown(null);\n\n    function onchown(err) {\n      if (err) return cb(err);\n      if (!chmod) return cb();\n      chmod.call(xfs, name, mode, cb);\n    }\n  };\n\n  extract.on('entry', function (header, stream, next) {\n    header = map(header) || header;\n    header.name = normalize(header.name);\n    var name = path.join(cwd, path.join('/', header.name));\n\n    if (ignore(name, header)) {\n      stream.resume();\n      return next();\n    }\n\n    var stat = function (err) {\n      if (err) return next(err);\n      utimes(name, header, function (err) {\n        if (err) return next(err);\n        if (win32) return next();\n        chperm(name, header, next);\n      });\n    };\n\n    var onsymlink = function () {\n      if (win32) return next(); // skip symlinks on win for now before it can be tested\n\n      xfs.unlink(name, function () {\n        xfs.symlink(header.linkname, name, stat);\n      });\n    };\n\n    var onlink = function () {\n      if (win32) return next(); // skip links on win for now before it can be tested\n\n      xfs.unlink(name, function () {\n        var srcpath = path.join(cwd, path.join('/', header.linkname));\n        xfs.link(srcpath, name, function (err) {\n          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n            stream = xfs.createReadStream(srcpath);\n            return onfile();\n          }\n\n          stat(err);\n        });\n      });\n    };\n\n    var onfile = function () {\n      var ws = xfs.createWriteStream(name);\n      var rs = mapStream(stream, header);\n      ws.on('error', function (err) {\n        // always forward errors on destroy\n        rs.destroy(err);\n      });\n      pump(rs, ws, function (err) {\n        if (err) return next(err);\n        ws.on('close', stat);\n      });\n    };\n\n    if (header.type === 'directory') {\n      stack.push([name, header.mtime]);\n      return mkdirfix(name, {\n        fs: xfs,\n        own: own,\n        uid: header.uid,\n        gid: header.gid\n      }, stat);\n    }\n\n    var dir = path.dirname(name);\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err);\n      if (!valid) return next(new Error(dir + ' is not a valid path'));\n      mkdirfix(dir, {\n        fs: xfs,\n        own: own,\n        uid: header.uid,\n        gid: header.gid\n      }, function (err) {\n        if (err) return next(err);\n\n        switch (header.type) {\n          case 'file':\n            return onfile();\n\n          case 'link':\n            return onlink();\n\n          case 'symlink':\n            return onsymlink();\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'));\n        stream.resume();\n        next();\n      });\n    });\n  });\n  if (opts.finish) extract.on('finish', opts.finish);\n  return extract;\n};\n\nfunction validate(fs, name, root, cb) {\n  if (name === root) return cb(null, true);\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT') return cb(err);\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb);\n    cb(null, false);\n  });\n}\n\nfunction mkdirfix(name, opts, cb) {\n  mkdirp(name, {\n    fs: opts.fs\n  }, function (err, made) {\n    if (!err && made && opts.own) {\n      chownr(made, opts.uid, opts.gid, cb);\n    } else {\n      cb(err);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/simoncohen/Flatiron/code/Mod5/bookfund/frontend-bookfund/bookfund/node_modules/tar-fs/index.js"],"names":["chownr","require","tar","pump","mkdirp","fs","path","os","win32","platform","noop","echo","name","normalize","replace","statAll","stat","cwd","ignore","entries","sort","queue","loop","callback","length","next","shift","nextAbs","join","call","err","isDirectory","readdir","files","i","push","strip","map","level","header","split","slice","linkname","type","isAbsolute","exports","pack","opts","xfs","filter","mapStream","statNext","dereference","lstat","strict","umask","processUmask","dmode","fmode","finish","readable","parseInt","writable","onsymlink","filename","readlink","destroy","entry","onnextentry","onstat","finalize","isSocket","mode","mtime","size","uid","gid","isSymbolicLink","isFile","Error","rs","createReadStream","start","end","on","head","list","processGetuid","process","getuid","extract","own","chown","stack","now","Date","utimesParent","cb","top","pop","utimes","chperm","link","chmod","lchmod","lchown","onchown","stream","resume","unlink","symlink","onlink","srcpath","code","hardlinkAsFilesFallback","onfile","ws","createWriteStream","mkdirfix","dir","dirname","validate","valid","root","st","made"],"mappings":"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","sourcesContent":["var chownr = require('chownr')\nvar tar = require('tar-stream')\nvar pump = require('pump')\nvar mkdirp = require('mkdirp-classic')\nvar fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\nvar win32 = os.platform() === 'win32'\n\nvar noop = function () {}\n\nvar echo = function (name) {\n  return name\n}\n\nvar normalize = !win32 ? echo : function (name) {\n  return name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_')\n}\n\nvar statAll = function (fs, stat, cwd, ignore, entries, sort) {\n  var queue = entries || ['.']\n\n  return function loop (callback) {\n    if (!queue.length) return callback()\n    var next = queue.shift()\n    var nextAbs = path.join(cwd, next)\n\n    stat.call(fs, nextAbs, function (err, stat) {\n      if (err) return callback(err)\n\n      if (!stat.isDirectory()) return callback(null, next, stat)\n\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err)\n\n        if (sort) files.sort()\n        for (var i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))\n        }\n\n        callback(null, next, stat)\n      })\n    })\n  }\n}\n\nvar strip = function (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/')\n\n    var linkname = header.linkname\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/')\n    }\n\n    return map(header)\n  }\n}\n\nexports.pack = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)\n  var strict = opts.strict !== false\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var pack = opts.pack || tar.pack()\n  var finish = opts.finish || noop\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var onsymlink = function (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err)\n      header.linkname = normalize(linkname)\n      pack.entry(header, onnextentry)\n    })\n  }\n\n  var onstat = function (err, filename, stat) {\n    if (err) return pack.destroy(err)\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize()\n      return finish(pack)\n    }\n\n    if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n    var header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    }\n\n    if (stat.isDirectory()) {\n      header.size = 0\n      header.type = 'directory'\n      header = map(header) || header\n      return pack.entry(header, onnextentry)\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0\n      header.type = 'symlink'\n      header = map(header) || header\n      return onsymlink(filename, header)\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))\n      return onnextentry()\n    }\n\n    var entry = pack.entry(header, onnextentry)\n    if (!entry) return\n\n    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename), { start: 0, end: header.size > 0 ? header.size - 1 : header.size }), header)\n\n    rs.on('error', function (err) { // always forward errors on destroy\n      entry.destroy(err)\n    })\n\n    pump(rs, entry)\n  }\n\n  var onnextentry = function (err) {\n    if (err) return pack.destroy(err)\n    statNext(onstat)\n  }\n\n  onnextentry()\n\n  return pack\n}\n\nvar head = function (list) {\n  return list.length ? list[list.length - 1] : null\n}\n\nvar processGetuid = function () {\n  return process.getuid ? process.getuid() : -1\n}\n\nvar processUmask = function () {\n  return process.umask ? process.umask() : 0\n}\n\nexports.extract = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var own = opts.chown !== false && !win32 && processGetuid() === 0\n  var extract = opts.extract || tar.extract()\n  var stack = []\n  var now = new Date()\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var strict = opts.strict !== false\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var utimesParent = function (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n    var top\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()\n    if (!top) return cb()\n    xfs.utimes(top[0], now, top[1], cb)\n  }\n\n  var utimes = function (name, header, cb) {\n    if (opts.utimes === false) return cb()\n\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)\n    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err)\n      utimesParent(name, cb)\n    })\n  }\n\n  var chperm = function (name, header, cb) {\n    var link = header.type === 'symlink'\n\n    /* eslint-disable node/no-deprecated-api */\n    var chmod = link ? xfs.lchmod : xfs.chmod\n    var chown = link ? xfs.lchown : xfs.chown\n    /* eslint-enable node/no-deprecated-api */\n\n    if (!chmod) return cb()\n\n    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask\n\n    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown)\n    else onchown(null)\n\n    function onchown (err) {\n      if (err) return cb(err)\n      if (!chmod) return cb()\n      chmod.call(xfs, name, mode, cb)\n    }\n  }\n\n  extract.on('entry', function (header, stream, next) {\n    header = map(header) || header\n    header.name = normalize(header.name)\n    var name = path.join(cwd, path.join('/', header.name))\n\n    if (ignore(name, header)) {\n      stream.resume()\n      return next()\n    }\n\n    var stat = function (err) {\n      if (err) return next(err)\n      utimes(name, header, function (err) {\n        if (err) return next(err)\n        if (win32) return next()\n        chperm(name, header, next)\n      })\n    }\n\n    var onsymlink = function () {\n      if (win32) return next() // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        xfs.symlink(header.linkname, name, stat)\n      })\n    }\n\n    var onlink = function () {\n      if (win32) return next() // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        var srcpath = path.join(cwd, path.join('/', header.linkname))\n\n        xfs.link(srcpath, name, function (err) {\n          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n            stream = xfs.createReadStream(srcpath)\n            return onfile()\n          }\n\n          stat(err)\n        })\n      })\n    }\n\n    var onfile = function () {\n      var ws = xfs.createWriteStream(name)\n      var rs = mapStream(stream, header)\n\n      ws.on('error', function (err) { // always forward errors on destroy\n        rs.destroy(err)\n      })\n\n      pump(rs, ws, function (err) {\n        if (err) return next(err)\n        ws.on('close', stat)\n      })\n    }\n\n    if (header.type === 'directory') {\n      stack.push([name, header.mtime])\n      return mkdirfix(name, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, stat)\n    }\n\n    var dir = path.dirname(name)\n\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err)\n      if (!valid) return next(new Error(dir + ' is not a valid path'))\n\n      mkdirfix(dir, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, function (err) {\n        if (err) return next(err)\n\n        switch (header.type) {\n          case 'file': return onfile()\n          case 'link': return onlink()\n          case 'symlink': return onsymlink()\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))\n\n        stream.resume()\n        next()\n      })\n    })\n  })\n\n  if (opts.finish) extract.on('finish', opts.finish)\n\n  return extract\n}\n\nfunction validate (fs, name, root, cb) {\n  if (name === root) return cb(null, true)\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT') return cb(err)\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)\n    cb(null, false)\n  })\n}\n\nfunction mkdirfix (name, opts, cb) {\n  mkdirp(name, { fs: opts.fs }, function (err, made) {\n    if (!err && made && opts.own) {\n      chownr(made, opts.uid, opts.gid, cb)\n    } else {\n      cb(err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}