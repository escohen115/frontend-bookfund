{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.helper = exports.debugError = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst Errors_js_1 = require(\"./Errors.js\");\n\nconst Debug_js_1 = require(\"./Debug.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst environment_js_1 = require(\"../environment.js\");\n\nexports.debugError = Debug_js_1.debug('puppeteer:error');\n\nfunction getExceptionMessage(exceptionDetails) {\n  if (exceptionDetails.exception) return exceptionDetails.exception.description || exceptionDetails.exception.value;\n  let message = exceptionDetails.text;\n\n  if (exceptionDetails.stackTrace) {\n    for (const callframe of exceptionDetails.stackTrace.callFrames) {\n      const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;\n      const functionName = callframe.functionName || '<anonymous>';\n      message += `\\n    at ${functionName} (${location})`;\n    }\n  }\n\n  return message;\n}\n\nfunction valueFromRemoteObject(remoteObject) {\n  assert_js_1.assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n\n  if (remoteObject.unserializableValue) {\n    if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined') return BigInt(remoteObject.unserializableValue.replace('n', ''));\n\n    switch (remoteObject.unserializableValue) {\n      case '-0':\n        return -0;\n\n      case 'NaN':\n        return NaN;\n\n      case 'Infinity':\n        return Infinity;\n\n      case '-Infinity':\n        return -Infinity;\n\n      default:\n        throw new Error('Unsupported unserializable value: ' + remoteObject.unserializableValue);\n    }\n  }\n\n  return remoteObject.value;\n}\n\nasync function releaseObject(client, remoteObject) {\n  if (!remoteObject.objectId) return;\n  await client.send('Runtime.releaseObject', {\n    objectId: remoteObject.objectId\n  }).catch(error => {\n    // Exceptions might happen in case of a page been navigated or closed.\n    // Swallow these since they are harmless and we don't leak anything in this case.\n    exports.debugError(error);\n  });\n}\n\nfunction addEventListener(emitter, eventName, handler) {\n  emitter.on(eventName, handler);\n  return {\n    emitter,\n    eventName,\n    handler\n  };\n}\n\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners) listener.emitter.removeListener(listener.eventName, listener.handler);\n\n  listeners.length = 0;\n}\n\nfunction isString(obj) {\n  return typeof obj === 'string' || obj instanceof String;\n}\n\nfunction isNumber(obj) {\n  return typeof obj === 'number' || obj instanceof Number;\n}\n\nasync function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {\n  let eventTimeout, resolveCallback, rejectCallback;\n  const promise = new Promise((resolve, reject) => {\n    resolveCallback = resolve;\n    rejectCallback = reject;\n  });\n  const listener = addEventListener(emitter, eventName, async event => {\n    if (!(await predicate(event))) return;\n    resolveCallback(event);\n  });\n\n  if (timeout) {\n    eventTimeout = setTimeout(() => {\n      rejectCallback(new Errors_js_1.TimeoutError('Timeout exceeded while waiting for event'));\n    }, timeout);\n  }\n\n  function cleanup() {\n    removeEventListeners([listener]);\n    clearTimeout(eventTimeout);\n  }\n\n  const result = await Promise.race([promise, abortPromise]).then(r => {\n    cleanup();\n    return r;\n  }, error => {\n    cleanup();\n    throw error;\n  });\n  if (result instanceof Error) throw result;\n  return result;\n}\n\nfunction evaluationString(fun, ...args) {\n  if (isString(fun)) {\n    assert_js_1.assert(args.length === 0, 'Cannot evaluate a string with arguments');\n    return fun;\n  }\n\n  function serializeArgument(arg) {\n    if (Object.is(arg, undefined)) return 'undefined';\n    return JSON.stringify(arg);\n  }\n\n  return `(${fun})(${args.map(serializeArgument).join(',')})`;\n}\n\nfunction pageBindingInitString(type, name) {\n  function addPageBinding(type, bindingName) {\n    /* Cast window to any here as we're about to add properties to it\n     * via win[bindingName] which TypeScript doesn't like.\n     */\n    const win = window;\n    const binding = win[bindingName];\n\n    win[bindingName] = (...args) => {\n      const me = window[bindingName];\n      let callbacks = me.callbacks;\n\n      if (!callbacks) {\n        callbacks = new Map();\n        me.callbacks = callbacks;\n      }\n\n      const seq = (me.lastSeq || 0) + 1;\n      me.lastSeq = seq;\n      const promise = new Promise((resolve, reject) => callbacks.set(seq, {\n        resolve,\n        reject\n      }));\n      binding(JSON.stringify({\n        type,\n        name: bindingName,\n        seq,\n        args\n      }));\n      return promise;\n    };\n  }\n\n  return evaluationString(addPageBinding, type, name);\n}\n\nfunction pageBindingDeliverResultString(name, seq, result) {\n  function deliverResult(name, seq, result) {\n    window[name].callbacks.get(seq).resolve(result);\n    window[name].callbacks.delete(seq);\n  }\n\n  return evaluationString(deliverResult, name, seq, result);\n}\n\nfunction pageBindingDeliverErrorString(name, seq, message, stack) {\n  function deliverError(name, seq, message, stack) {\n    const error = new Error(message);\n    error.stack = stack;\n    window[name].callbacks.get(seq).reject(error);\n    window[name].callbacks.delete(seq);\n  }\n\n  return evaluationString(deliverError, name, seq, message, stack);\n}\n\nfunction pageBindingDeliverErrorValueString(name, seq, value) {\n  function deliverErrorValue(name, seq, value) {\n    window[name].callbacks.get(seq).reject(value);\n    window[name].callbacks.delete(seq);\n  }\n\n  return evaluationString(deliverErrorValue, name, seq, value);\n}\n\nfunction makePredicateString(predicate, predicateQueryHandler) {\n  function checkWaitForOptions(node, waitForVisible, waitForHidden) {\n    if (!node) return waitForHidden;\n    if (!waitForVisible && !waitForHidden) return node;\n    const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;\n    const style = window.getComputedStyle(element);\n    const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();\n    const success = waitForVisible === isVisible || waitForHidden === !isVisible;\n    return success ? node : null;\n\n    function hasVisibleBoundingBox() {\n      const rect = element.getBoundingClientRect();\n      return !!(rect.top || rect.bottom || rect.width || rect.height);\n    }\n  }\n\n  const predicateQueryHandlerDef = predicateQueryHandler ? `const predicateQueryHandler = ${predicateQueryHandler};` : '';\n  return `\n    (() => {\n      ${predicateQueryHandlerDef}\n      const checkWaitForOptions = ${checkWaitForOptions};\n      return (${predicate})(...args)\n    })() `;\n}\n\nasync function waitWithTimeout(promise, taskName, timeout) {\n  let reject;\n  const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);\n  const timeoutPromise = new Promise((resolve, x) => reject = x);\n  let timeoutTimer = null;\n  if (timeout) timeoutTimer = setTimeout(() => reject(timeoutError), timeout);\n\n  try {\n    return await Promise.race([promise, timeoutPromise]);\n  } finally {\n    if (timeoutTimer) clearTimeout(timeoutTimer);\n  }\n}\n\nasync function readProtocolStream(client, handle, path) {\n  if (!environment_js_1.isNode && path) {\n    throw new Error('Cannot write to a path outside of Node.js environment.');\n  }\n\n  const fs = environment_js_1.isNode ? await importFSModule() : null;\n  let eof = false;\n  let fileHandle;\n\n  if (path && fs) {\n    fileHandle = await fs.promises.open(path, 'w');\n  }\n\n  const bufs = [];\n\n  while (!eof) {\n    const response = await client.send('IO.read', {\n      handle\n    });\n    eof = response.eof;\n    const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);\n    bufs.push(buf);\n\n    if (path && fs) {\n      await fs.promises.writeFile(fileHandle, buf);\n    }\n  }\n\n  if (path) await fileHandle.close();\n  await client.send('IO.close', {\n    handle\n  });\n  let resultBuffer = null;\n\n  try {\n    resultBuffer = Buffer.concat(bufs);\n  } finally {\n    return resultBuffer;\n  }\n}\n/**\n * Loads the Node fs promises API. Needed because on Node 10.17 and below,\n * fs.promises is experimental, and therefore not marked as enumerable. That\n * means when TypeScript compiles an `import('fs')`, its helper doesn't spot the\n * promises declaration and therefore on Node <10.17 you get an error as\n * fs.promises is undefined in compiled TypeScript land.\n *\n * See https://github.com/puppeteer/puppeteer/issues/6548 for more details.\n *\n * Once Node 10 is no longer supported (April 2021) we can remove this and use\n * `(await import('fs')).promises`.\n */\n\n\nasync function importFSModule() {\n  if (!environment_js_1.isNode) {\n    throw new Error('Cannot load the fs module API outside of Node.');\n  }\n\n  const fs = await Promise.resolve().then(() => __importStar(require('fs')));\n\n  if (fs.promises) {\n    return fs;\n  }\n\n  return fs.default;\n}\n\nexports.helper = {\n  evaluationString,\n  pageBindingInitString,\n  pageBindingDeliverResultString,\n  pageBindingDeliverErrorString,\n  pageBindingDeliverErrorValueString,\n  makePredicateString,\n  readProtocolStream,\n  waitWithTimeout,\n  waitForEvent,\n  isString,\n  isNumber,\n  importFSModule,\n  addEventListener,\n  removeEventListeners,\n  valueFromRemoteObject,\n  getExceptionMessage,\n  releaseObject\n};","map":{"version":3,"sources":["../../../../src/common/helper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.helper = exports.debugError = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst Errors_js_1 = require(\"./Errors.js\");\nconst Debug_js_1 = require(\"./Debug.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst environment_js_1 = require(\"../environment.js\");\nexports.debugError = Debug_js_1.debug('puppeteer:error');\nfunction getExceptionMessage(exceptionDetails) {\n    if (exceptionDetails.exception)\n        return (exceptionDetails.exception.description || exceptionDetails.exception.value);\n    let message = exceptionDetails.text;\n    if (exceptionDetails.stackTrace) {\n        for (const callframe of exceptionDetails.stackTrace.callFrames) {\n            const location = callframe.url +\n                ':' +\n                callframe.lineNumber +\n                ':' +\n                callframe.columnNumber;\n            const functionName = callframe.functionName || '<anonymous>';\n            message += `\\n    at ${functionName} (${location})`;\n        }\n    }\n    return message;\n}\nfunction valueFromRemoteObject(remoteObject) {\n    assert_js_1.assert(!remoteObject.objectId, 'Cannot extract value when objectId is given');\n    if (remoteObject.unserializableValue) {\n        if (remoteObject.type === 'bigint' && typeof BigInt !== 'undefined')\n            return BigInt(remoteObject.unserializableValue.replace('n', ''));\n        switch (remoteObject.unserializableValue) {\n            case '-0':\n                return -0;\n            case 'NaN':\n                return NaN;\n            case 'Infinity':\n                return Infinity;\n            case '-Infinity':\n                return -Infinity;\n            default:\n                throw new Error('Unsupported unserializable value: ' +\n                    remoteObject.unserializableValue);\n        }\n    }\n    return remoteObject.value;\n}\nasync function releaseObject(client, remoteObject) {\n    if (!remoteObject.objectId)\n        return;\n    await client\n        .send('Runtime.releaseObject', { objectId: remoteObject.objectId })\n        .catch((error) => {\n        // Exceptions might happen in case of a page been navigated or closed.\n        // Swallow these since they are harmless and we don't leak anything in this case.\n        exports.debugError(error);\n    });\n}\nfunction addEventListener(emitter, eventName, handler) {\n    emitter.on(eventName, handler);\n    return { emitter, eventName, handler };\n}\nfunction removeEventListeners(listeners) {\n    for (const listener of listeners)\n        listener.emitter.removeListener(listener.eventName, listener.handler);\n    listeners.length = 0;\n}\nfunction isString(obj) {\n    return typeof obj === 'string' || obj instanceof String;\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number' || obj instanceof Number;\n}\nasync function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {\n    let eventTimeout, resolveCallback, rejectCallback;\n    const promise = new Promise((resolve, reject) => {\n        resolveCallback = resolve;\n        rejectCallback = reject;\n    });\n    const listener = addEventListener(emitter, eventName, async (event) => {\n        if (!(await predicate(event)))\n            return;\n        resolveCallback(event);\n    });\n    if (timeout) {\n        eventTimeout = setTimeout(() => {\n            rejectCallback(new Errors_js_1.TimeoutError('Timeout exceeded while waiting for event'));\n        }, timeout);\n    }\n    function cleanup() {\n        removeEventListeners([listener]);\n        clearTimeout(eventTimeout);\n    }\n    const result = await Promise.race([promise, abortPromise]).then((r) => {\n        cleanup();\n        return r;\n    }, (error) => {\n        cleanup();\n        throw error;\n    });\n    if (result instanceof Error)\n        throw result;\n    return result;\n}\nfunction evaluationString(fun, ...args) {\n    if (isString(fun)) {\n        assert_js_1.assert(args.length === 0, 'Cannot evaluate a string with arguments');\n        return fun;\n    }\n    function serializeArgument(arg) {\n        if (Object.is(arg, undefined))\n            return 'undefined';\n        return JSON.stringify(arg);\n    }\n    return `(${fun})(${args.map(serializeArgument).join(',')})`;\n}\nfunction pageBindingInitString(type, name) {\n    function addPageBinding(type, bindingName) {\n        /* Cast window to any here as we're about to add properties to it\n         * via win[bindingName] which TypeScript doesn't like.\n         */\n        const win = window;\n        const binding = win[bindingName];\n        win[bindingName] = (...args) => {\n            const me = window[bindingName];\n            let callbacks = me.callbacks;\n            if (!callbacks) {\n                callbacks = new Map();\n                me.callbacks = callbacks;\n            }\n            const seq = (me.lastSeq || 0) + 1;\n            me.lastSeq = seq;\n            const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));\n            binding(JSON.stringify({ type, name: bindingName, seq, args }));\n            return promise;\n        };\n    }\n    return evaluationString(addPageBinding, type, name);\n}\nfunction pageBindingDeliverResultString(name, seq, result) {\n    function deliverResult(name, seq, result) {\n        window[name].callbacks.get(seq).resolve(result);\n        window[name].callbacks.delete(seq);\n    }\n    return evaluationString(deliverResult, name, seq, result);\n}\nfunction pageBindingDeliverErrorString(name, seq, message, stack) {\n    function deliverError(name, seq, message, stack) {\n        const error = new Error(message);\n        error.stack = stack;\n        window[name].callbacks.get(seq).reject(error);\n        window[name].callbacks.delete(seq);\n    }\n    return evaluationString(deliverError, name, seq, message, stack);\n}\nfunction pageBindingDeliverErrorValueString(name, seq, value) {\n    function deliverErrorValue(name, seq, value) {\n        window[name].callbacks.get(seq).reject(value);\n        window[name].callbacks.delete(seq);\n    }\n    return evaluationString(deliverErrorValue, name, seq, value);\n}\nfunction makePredicateString(predicate, predicateQueryHandler) {\n    function checkWaitForOptions(node, waitForVisible, waitForHidden) {\n        if (!node)\n            return waitForHidden;\n        if (!waitForVisible && !waitForHidden)\n            return node;\n        const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;\n        const style = window.getComputedStyle(element);\n        const isVisible = style && style.visibility !== 'hidden' && hasVisibleBoundingBox();\n        const success = waitForVisible === isVisible || waitForHidden === !isVisible;\n        return success ? node : null;\n        function hasVisibleBoundingBox() {\n            const rect = element.getBoundingClientRect();\n            return !!(rect.top || rect.bottom || rect.width || rect.height);\n        }\n    }\n    const predicateQueryHandlerDef = predicateQueryHandler\n        ? `const predicateQueryHandler = ${predicateQueryHandler};`\n        : '';\n    return `\n    (() => {\n      ${predicateQueryHandlerDef}\n      const checkWaitForOptions = ${checkWaitForOptions};\n      return (${predicate})(...args)\n    })() `;\n}\nasync function waitWithTimeout(promise, taskName, timeout) {\n    let reject;\n    const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);\n    const timeoutPromise = new Promise((resolve, x) => (reject = x));\n    let timeoutTimer = null;\n    if (timeout)\n        timeoutTimer = setTimeout(() => reject(timeoutError), timeout);\n    try {\n        return await Promise.race([promise, timeoutPromise]);\n    }\n    finally {\n        if (timeoutTimer)\n            clearTimeout(timeoutTimer);\n    }\n}\nasync function readProtocolStream(client, handle, path) {\n    if (!environment_js_1.isNode && path) {\n        throw new Error('Cannot write to a path outside of Node.js environment.');\n    }\n    const fs = environment_js_1.isNode ? await importFSModule() : null;\n    let eof = false;\n    let fileHandle;\n    if (path && fs) {\n        fileHandle = await fs.promises.open(path, 'w');\n    }\n    const bufs = [];\n    while (!eof) {\n        const response = await client.send('IO.read', { handle });\n        eof = response.eof;\n        const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);\n        bufs.push(buf);\n        if (path && fs) {\n            await fs.promises.writeFile(fileHandle, buf);\n        }\n    }\n    if (path)\n        await fileHandle.close();\n    await client.send('IO.close', { handle });\n    let resultBuffer = null;\n    try {\n        resultBuffer = Buffer.concat(bufs);\n    }\n    finally {\n        return resultBuffer;\n    }\n}\n/**\n * Loads the Node fs promises API. Needed because on Node 10.17 and below,\n * fs.promises is experimental, and therefore not marked as enumerable. That\n * means when TypeScript compiles an `import('fs')`, its helper doesn't spot the\n * promises declaration and therefore on Node <10.17 you get an error as\n * fs.promises is undefined in compiled TypeScript land.\n *\n * See https://github.com/puppeteer/puppeteer/issues/6548 for more details.\n *\n * Once Node 10 is no longer supported (April 2021) we can remove this and use\n * `(await import('fs')).promises`.\n */\nasync function importFSModule() {\n    if (!environment_js_1.isNode) {\n        throw new Error('Cannot load the fs module API outside of Node.');\n    }\n    const fs = await Promise.resolve().then(() => __importStar(require('fs')));\n    if (fs.promises) {\n        return fs;\n    }\n    return fs.default;\n}\nexports.helper = {\n    evaluationString,\n    pageBindingInitString,\n    pageBindingDeliverResultString,\n    pageBindingDeliverErrorString,\n    pageBindingDeliverErrorValueString,\n    makePredicateString,\n    readProtocolStream,\n    waitWithTimeout,\n    waitForEvent,\n    isString,\n    isNumber,\n    importFSModule,\n    addEventListener,\n    removeEventListeners,\n    valueFromRemoteObject,\n    getExceptionMessage,\n    releaseObject,\n};\n//# sourceMappingURL=helper.js.map"]},"metadata":{},"sourceType":"script"}