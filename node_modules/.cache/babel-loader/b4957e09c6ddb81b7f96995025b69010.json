{"ast":null,"code":"var _jsxFileName = \"/Users/simoncohen/Flatiron/code/Mod5/bookfund/frontend-bookfund/bookfund/src/components/pages/UserPage/UserPage.js\";\nimport React, { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nimport Timer from './Timer';\nimport BackEndBookCard from '../BookIndex/BackEndBookCard';\nimport { Card } from 'semantic-ui-react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function UserPage({\n  user,\n  savedBooks,\n  timeLeft,\n  setTimeLeft,\n  reviewLeft,\n  setReviewLeft\n}) {\n  let waitingsMapped = [];\n  let waitingsFulFilledMapped = [];\n  let mostRecent = {};\n  let foundBook = null;\n  let foundReview = null;\n  let receivedMapped = null;\n  let waitlistMapped = null;\n  console.log('hello');\n\n  if (user) {\n    // let waitingsUnfulfilled = user.waitings.filter(waiting=>waiting.fulfilled!==true)//get all unfulfilled waitings for a user\n    // for(let i=0;i<waitingsUnfulfilled.length;i++){\n    //     waitingsMapped.push(savedBooks.find(saved_book => saved_book.id === waitingsUnfulfilled[i].book_id))//create an array of those books by comparing to saved books\n    // } \n    // if (waitingsMapped.length > 0){\n    //     waitlistMapped = waitingsMapped.map(waiting=>{ //create JSX of books\n    //         return (<BackEndBookCard book={waiting}/>)\n    //     })\n    // }\n    // let waitingsFulfilled = user.waitings.filter(waiting=>waiting.fulfilled===true) //get all fulfilled waitings for a user\n    // for(let i=0;i<waitingsFulfilled.length;i++){\n    //     waitingsFulFilledMapped.push(savedBooks.find(saved_book => saved_book.id === waitingsFulfilled[i].book_id)) //create an array of those books by comparing to saved books\n    // } \n    // if (savedBooks.length > 0){\n    //     receivedMapped = waitingsFulFilledMapped.map(waiting=>{ //create JSX of books\n    //         return (<BackEndBookCard book={waiting}/>)\n    //     })\n    // }\n    // if (waitingsFulfilled.length > 0){\n    //     mostRecent = (waitingsFulfilled.sort(function (a, b){ // find most recent waiting\n    //         return b.id - a.id\n    //     })[0])\n    //         foundBook = savedBooks.find(book=>book.id===mostRecent.book_id) // find most recently received book based on most recent waiting\n    //         if (foundBook){\n    //             foundReview = foundBook.reviews.find(review=>review.user.id===user.id) // check if they left a review on it\n    //             if (foundReview){\n    //                 setReviewLeft(true)\n    //             }\n    //             else{\n    //                 setReviewLeft(false)\n    //             }\n    //         }\n    //         else{ // if no book is on waiting list\n    //             setReviewLeft(true)\n    //         }\n    // }\n    // return(\n    //     <div> \n    //     {waitingsFulfilled.length > 0 ?\n    //         <Timer \n    //             mostRecent={mostRecent}\n    //             timeLeft={timeLeft} \n    //             setTimeLeft={setTimeLeft}\n    //         />\n    //     : \"Looks like you're eligible for your next book!\"}\n    //         <img src={user.profile_pic ? user.profile_pic : null}></img>\n    //         <p>name:{user.name ? user.name : null}</p>\n    //         <p>email:{user.email ? user.email : null}</p>\n    //         <p>username:{user.username ? user.username : null }</p>\n    //         <p>bio:{user.bio ? user.bio : null}</p>\n    //         {reviewLeft === false ? <p>please leave a review for: <BackEndBookCard book={foundBook}/> </p>: null}\n    //         <p>waitlist:</p>\n    //         {waitingsMapped.length>0 ? \n    //             <Card.Group itemsPerRow={8}>\n    //                 {waitlistMapped}  \n    //             </Card.Group>\n    //         :null}\n    //         <p>received:</p>\n    //         {waitingsFulFilledMapped.length > 0 ? \n    //             <Card.Group itemsPerRow={8}>\n    //                 {receivedMapped}  \n    //             </Card.Group>\n    //         :null}\n    //         <p>sponsored list</p>\n    //     </div>\n    // )\n    return /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"hello\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 13\n    }, this);\n  } else {\n    return null;\n  }\n}\n_c = UserPage;\n\nvar _c;\n\n$RefreshReg$(_c, \"UserPage\");","map":{"version":3,"sources":["/Users/simoncohen/Flatiron/code/Mod5/bookfund/frontend-bookfund/bookfund/src/components/pages/UserPage/UserPage.js"],"names":["React","useState","useEffect","Link","Timer","BackEndBookCard","Card","UserPage","user","savedBooks","timeLeft","setTimeLeft","reviewLeft","setReviewLeft","waitingsMapped","waitingsFulFilledMapped","mostRecent","foundBook","foundReview","receivedMapped","waitlistMapped","console","log"],"mappings":";AACA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AACA,SAASC,IAAT,QAAqB,kBAArB;AACA,OAAOC,KAAP,MAAkB,SAAlB;AACA,OAAOC,eAAP,MAA4B,8BAA5B;AACA,SAASC,IAAT,QAAqB,mBAArB;;AAEA,eAAe,SAASC,QAAT,CAAkB;AAACC,EAAAA,IAAD;AAAOC,EAAAA,UAAP;AAAmBC,EAAAA,QAAnB;AAA6BC,EAAAA,WAA7B;AAA0CC,EAAAA,UAA1C;AAAsDC,EAAAA;AAAtD,CAAlB,EAAuF;AAElG,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,uBAAuB,GAAG,EAA9B;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,WAAW,GAAG,IAAlB;AACA,MAAIC,cAAc,GAAG,IAArB;AACA,MAAIC,cAAc,GAAG,IAArB;AAEAC,EAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ;;AAEA,MAAId,IAAJ,EAAS;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,wBACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ;AAGH,GA9ED,MA+EI;AACA,WAAO,IAAP;AACH;AACJ;KA9FuBD,Q","sourcesContent":["\nimport React, { useState, useEffect } from \"react\"\nimport { Link } from \"react-router-dom\";\nimport Timer from './Timer'\nimport BackEndBookCard from '../BookIndex/BackEndBookCard'\nimport { Card } from 'semantic-ui-react'\n\nexport default function UserPage({user, savedBooks, timeLeft, setTimeLeft, reviewLeft, setReviewLeft}){\n\n    let waitingsMapped = []\n    let waitingsFulFilledMapped = []\n    let mostRecent = {}\n    let foundBook = null\n    let foundReview = null\n    let receivedMapped = null\n    let waitlistMapped = null\n    \n    console.log('hello')\n    \n    if (user){ \n\n        // let waitingsUnfulfilled = user.waitings.filter(waiting=>waiting.fulfilled!==true)//get all unfulfilled waitings for a user\n        // for(let i=0;i<waitingsUnfulfilled.length;i++){\n        //     waitingsMapped.push(savedBooks.find(saved_book => saved_book.id === waitingsUnfulfilled[i].book_id))//create an array of those books by comparing to saved books\n        // } \n        // if (waitingsMapped.length > 0){\n        //     waitlistMapped = waitingsMapped.map(waiting=>{ //create JSX of books\n        //         return (<BackEndBookCard book={waiting}/>)\n        //     })\n        // }\n        // let waitingsFulfilled = user.waitings.filter(waiting=>waiting.fulfilled===true) //get all fulfilled waitings for a user\n        \n\n        // for(let i=0;i<waitingsFulfilled.length;i++){\n        //     waitingsFulFilledMapped.push(savedBooks.find(saved_book => saved_book.id === waitingsFulfilled[i].book_id)) //create an array of those books by comparing to saved books\n        // } \n\n        // if (savedBooks.length > 0){\n        //     receivedMapped = waitingsFulFilledMapped.map(waiting=>{ //create JSX of books\n        //         return (<BackEndBookCard book={waiting}/>)\n        //     })\n        // }\n\n        // if (waitingsFulfilled.length > 0){\n        //     mostRecent = (waitingsFulfilled.sort(function (a, b){ // find most recent waiting\n        //         return b.id - a.id\n        //     })[0])\n        //         foundBook = savedBooks.find(book=>book.id===mostRecent.book_id) // find most recently received book based on most recent waiting\n        //         if (foundBook){\n        //             foundReview = foundBook.reviews.find(review=>review.user.id===user.id) // check if they left a review on it\n        //             if (foundReview){\n        //                 setReviewLeft(true)\n        //             }\n        //             else{\n        //                 setReviewLeft(false)\n        //             }\n        //         }\n        //         else{ // if no book is on waiting list\n        //             setReviewLeft(true)\n        //         }\n        // }\n\n        // return(\n        //     <div> \n        //     {waitingsFulfilled.length > 0 ?\n        //         <Timer \n        //             mostRecent={mostRecent}\n        //             timeLeft={timeLeft} \n        //             setTimeLeft={setTimeLeft}\n        //         />\n        //     : \"Looks like you're eligible for your next book!\"}\n        //         <img src={user.profile_pic ? user.profile_pic : null}></img>\n        //         <p>name:{user.name ? user.name : null}</p>\n        //         <p>email:{user.email ? user.email : null}</p>\n        //         <p>username:{user.username ? user.username : null }</p>\n        //         <p>bio:{user.bio ? user.bio : null}</p>\n        //         {reviewLeft === false ? <p>please leave a review for: <BackEndBookCard book={foundBook}/> </p>: null}\n        //         <p>waitlist:</p>\n        //         {waitingsMapped.length>0 ? \n        //             <Card.Group itemsPerRow={8}>\n        //                 {waitlistMapped}  \n        //             </Card.Group>\n        //         :null}\n\n        //         <p>received:</p>\n        //         {waitingsFulFilledMapped.length > 0 ? \n        //             <Card.Group itemsPerRow={8}>\n        //                 {receivedMapped}  \n        //             </Card.Group>\n        //         :null}\n        //         <p>sponsored list</p>\n\n        //     </div>\n        // )\n        return (\n            <p>hello</p>\n        )\n    }\n    else{\n        return null\n    }\n}\n\n\n"]},"metadata":{},"sourceType":"module"}