{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaitTask = exports.DOMWorld = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst LifecycleWatcher_js_1 = require(\"./LifecycleWatcher.js\");\n\nconst Errors_js_1 = require(\"./Errors.js\");\n\nconst QueryHandler_js_1 = require(\"./QueryHandler.js\");\n\nconst environment_js_1 = require(\"../environment.js\");\n/**\n * @internal\n */\n\n\nclass DOMWorld {\n  constructor(frameManager, frame, timeoutSettings) {\n    this._documentPromise = null;\n    this._contextPromise = null;\n    this._contextResolveCallback = null;\n    this._detached = false;\n    /**\n     * @internal\n     */\n\n    this._waitTasks = new Set();\n    /**\n     * @internal\n     * Contains mapping from functions that should be bound to Puppeteer functions.\n     */\n\n    this._boundFunctions = new Map(); // Set of bindings that have been registered in the current context.\n\n    this._ctxBindings = new Set(); // If multiple waitFor are set up asynchronously, we need to wait for the\n    // first one to set up the binding in the page before running the others.\n\n    this._settingUpBinding = null;\n    this._frameManager = frameManager;\n    this._frame = frame;\n    this._timeoutSettings = timeoutSettings;\n\n    this._setContext(null);\n\n    frameManager._client.on('Runtime.bindingCalled', event => this._onBindingCalled(event));\n  }\n\n  frame() {\n    return this._frame;\n  }\n\n  async _setContext(context) {\n    if (context) {\n      this._contextResolveCallback.call(null, context);\n\n      this._contextResolveCallback = null;\n\n      for (const waitTask of this._waitTasks) waitTask.rerun();\n    } else {\n      this._documentPromise = null;\n      this._contextPromise = new Promise(fulfill => {\n        this._contextResolveCallback = fulfill;\n      });\n    }\n  }\n\n  _hasContext() {\n    return !this._contextResolveCallback;\n  }\n\n  _detach() {\n    this._detached = true;\n\n    for (const waitTask of this._waitTasks) waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n  }\n\n  executionContext() {\n    if (this._detached) throw new Error(`Execution context is not available in detached frame \"${this._frame.url()}\" (are you trying to evaluate?)`);\n    return this._contextPromise;\n  }\n\n  async evaluateHandle(pageFunction, ...args) {\n    const context = await this.executionContext();\n    return context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate(pageFunction, ...args) {\n    const context = await this.executionContext();\n    return context.evaluate(pageFunction, ...args);\n  }\n\n  async $(selector) {\n    const document = await this._document();\n    const value = await document.$(selector);\n    return value;\n  }\n\n  async _document() {\n    if (this._documentPromise) return this._documentPromise;\n    this._documentPromise = this.executionContext().then(async context => {\n      const document = await context.evaluateHandle('document');\n      return document.asElement();\n    });\n    return this._documentPromise;\n  }\n\n  async $x(expression) {\n    const document = await this._document();\n    const value = await document.$x(expression);\n    return value;\n  }\n\n  async $eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    return document.$eval(selector, pageFunction, ...args);\n  }\n\n  async $$eval(selector, pageFunction, ...args) {\n    const document = await this._document();\n    const value = await document.$$eval(selector, pageFunction, ...args);\n    return value;\n  }\n\n  async $$(selector) {\n    const document = await this._document();\n    const value = await document.$$(selector);\n    return value;\n  }\n\n  async content() {\n    return await this.evaluate(() => {\n      let retVal = '';\n      if (document.doctype) retVal = new XMLSerializer().serializeToString(document.doctype);\n      if (document.documentElement) retVal += document.documentElement.outerHTML;\n      return retVal;\n    });\n  }\n\n  async setContent(html, options = {}) {\n    const {\n      waitUntil = ['load'],\n      timeout = this._timeoutSettings.navigationTimeout()\n    } = options; // We rely upon the fact that document.open() will reset frame lifecycle with \"init\"\n    // lifecycle event. @see https://crrev.com/608658\n\n    await this.evaluate(html => {\n      document.open();\n      document.write(html);\n      document.close();\n    }, html);\n    const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);\n    const error = await Promise.race([watcher.timeoutOrTerminationPromise(), watcher.lifecyclePromise()]);\n    watcher.dispose();\n    if (error) throw error;\n  }\n  /**\n   * Adds a script tag into the current context.\n   *\n   * @remarks\n   *\n   * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n   * in a browser environment you cannot pass a filepath and should use either\n   * `url` or `content`.\n   */\n\n\n  async addScriptTag(options) {\n    const {\n      url = null,\n      path = null,\n      content = null,\n      type = ''\n    } = options;\n\n    if (url !== null) {\n      try {\n        const context = await this.executionContext();\n        return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();\n      } catch (error) {\n        throw new Error(`Loading script from ${url} failed`);\n      }\n    }\n\n    if (path !== null) {\n      if (!environment_js_1.isNode) {\n        throw new Error('Cannot pass a filepath to addScriptTag in the browser environment.');\n      }\n\n      const fs = await helper_js_1.helper.importFSModule();\n      let contents = await fs.promises.readFile(path, 'utf8');\n      contents += '//# sourceURL=' + path.replace(/\\n/g, '');\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();\n    }\n\n    if (content !== null) {\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addScriptContent, content, type)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    async function addScriptUrl(url, type) {\n      const script = document.createElement('script');\n      script.src = url;\n      if (type) script.type = type;\n      const promise = new Promise((res, rej) => {\n        script.onload = res;\n        script.onerror = rej;\n      });\n      document.head.appendChild(script);\n      await promise;\n      return script;\n    }\n\n    function addScriptContent(content, type = 'text/javascript') {\n      const script = document.createElement('script');\n      script.type = type;\n      script.text = content;\n      let error = null;\n\n      script.onerror = e => error = e;\n\n      document.head.appendChild(script);\n      if (error) throw error;\n      return script;\n    }\n  }\n  /**\n   * Adds a style tag into the current context.\n   *\n   * @remarks\n   *\n   * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n   * in a browser environment you cannot pass a filepath and should use either\n   * `url` or `content`.\n   *\n   */\n\n\n  async addStyleTag(options) {\n    const {\n      url = null,\n      path = null,\n      content = null\n    } = options;\n\n    if (url !== null) {\n      try {\n        const context = await this.executionContext();\n        return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n      } catch (error) {\n        throw new Error(`Loading style from ${url} failed`);\n      }\n    }\n\n    if (path !== null) {\n      if (!environment_js_1.isNode) {\n        throw new Error('Cannot pass a filepath to addStyleTag in the browser environment.');\n      }\n\n      const fs = await helper_js_1.helper.importFSModule();\n      let contents = await fs.promises.readFile(path, 'utf8');\n      contents += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addStyleContent, contents)).asElement();\n    }\n\n    if (content !== null) {\n      const context = await this.executionContext();\n      return (await context.evaluateHandle(addStyleContent, content)).asElement();\n    }\n\n    throw new Error('Provide an object with a `url`, `path` or `content` property');\n\n    async function addStyleUrl(url) {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = url;\n      const promise = new Promise((res, rej) => {\n        link.onload = res;\n        link.onerror = rej;\n      });\n      document.head.appendChild(link);\n      await promise;\n      return link;\n    }\n\n    async function addStyleContent(content) {\n      const style = document.createElement('style');\n      style.type = 'text/css';\n      style.appendChild(document.createTextNode(content));\n      const promise = new Promise((res, rej) => {\n        style.onload = res;\n        style.onerror = rej;\n      });\n      document.head.appendChild(style);\n      await promise;\n      return style;\n    }\n  }\n\n  async click(selector, options) {\n    const handle = await this.$(selector);\n    assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n    await handle.click(options);\n    await handle.dispose();\n  }\n\n  async focus(selector) {\n    const handle = await this.$(selector);\n    assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n    await handle.focus();\n    await handle.dispose();\n  }\n\n  async hover(selector) {\n    const handle = await this.$(selector);\n    assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n    await handle.hover();\n    await handle.dispose();\n  }\n\n  async select(selector, ...values) {\n    const handle = await this.$(selector);\n    assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n    const result = await handle.select(...values);\n    await handle.dispose();\n    return result;\n  }\n\n  async tap(selector) {\n    const handle = await this.$(selector);\n    await handle.tap();\n    await handle.dispose();\n  }\n\n  async type(selector, text, options) {\n    const handle = await this.$(selector);\n    assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n    await handle.type(text, options);\n    await handle.dispose();\n  }\n\n  async waitForSelector(selector, options) {\n    const {\n      updatedSelector,\n      queryHandler\n    } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n    return queryHandler.waitFor(this, updatedSelector, options);\n  }\n  /**\n   * @internal\n   */\n\n\n  async addBindingToContext(context, name) {\n    // Previous operation added the binding so we are done.\n    if (this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) {\n      return;\n    } // Wait for other operation to finish\n\n\n    if (this._settingUpBinding) {\n      await this._settingUpBinding;\n      return this.addBindingToContext(context, name);\n    }\n\n    const bind = async name => {\n      const expression = helper_js_1.helper.pageBindingInitString('internal', name);\n\n      try {\n        // TODO: In theory, it would be enough to call this just once\n        await context._client.send('Runtime.addBinding', {\n          name,\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore The protocol definition is not up to date.\n          executionContextName: context._contextName\n        });\n        await context.evaluate(expression);\n      } catch (error) {\n        // We could have tried to evaluate in a context which was already\n        // destroyed. This happens, for example, if the page is navigated while\n        // we are trying to add the binding\n        const ctxDestroyed = error.message.includes('Execution context was destroyed');\n        const ctxNotFound = error.message.includes('Cannot find context with specified id');\n\n        if (ctxDestroyed || ctxNotFound) {\n          return;\n        } else {\n          helper_js_1.debugError(error);\n          return;\n        }\n      }\n\n      this._ctxBindings.add(DOMWorld.bindingIdentifier(name, context._contextId));\n    };\n\n    this._settingUpBinding = bind(name);\n    await this._settingUpBinding;\n    this._settingUpBinding = null;\n  }\n\n  async _onBindingCalled(event) {\n    let payload;\n    if (!this._hasContext()) return;\n    const context = await this.executionContext();\n\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n\n    const {\n      type,\n      name,\n      seq,\n      args\n    } = payload;\n    if (type !== 'internal' || !this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) return;\n    if (context._contextId !== event.executionContextId) return;\n\n    try {\n      const result = await this._boundFunctions.get(name)(...args);\n      await context.evaluate(deliverResult, name, seq, result);\n    } catch (error) {\n      // The WaitTask may already have been resolved by timing out, or the\n      // exection context may have been destroyed.\n      // In both caes, the promises above are rejected with a protocol error.\n      // We can safely ignores these, as the WaitTask is re-installed in\n      // the next execution context if needed.\n      if (error.message.includes('Protocol error')) return;\n      helper_js_1.debugError(error);\n    }\n\n    function deliverResult(name, seq, result) {\n      globalThis[name].callbacks.get(seq).resolve(result);\n      globalThis[name].callbacks.delete(seq);\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  async waitForSelectorInPage(queryOne, selector, options, binding) {\n    const {\n      visible: waitForVisible = false,\n      hidden: waitForHidden = false,\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n    const title = `selector \\`${selector}\\`${waitForHidden ? ' to be hidden' : ''}`;\n\n    async function predicate(selector, waitForVisible, waitForHidden) {\n      const node = predicateQueryHandler ? await predicateQueryHandler(document, selector) : document.querySelector(selector);\n      return checkWaitForOptions(node, waitForVisible, waitForHidden);\n    }\n\n    const waitTaskOptions = {\n      domWorld: this,\n      predicateBody: helper_js_1.helper.makePredicateString(predicate, queryOne),\n      title,\n      polling,\n      timeout,\n      args: [selector, waitForVisible, waitForHidden],\n      binding\n    };\n    const waitTask = new WaitTask(waitTaskOptions);\n    const jsHandle = await waitTask.promise;\n    const elementHandle = jsHandle.asElement();\n\n    if (!elementHandle) {\n      await jsHandle.dispose();\n      return null;\n    }\n\n    return elementHandle;\n  }\n\n  async waitForXPath(xpath, options) {\n    const {\n      visible: waitForVisible = false,\n      hidden: waitForHidden = false,\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n    const title = `XPath \\`${xpath}\\`${waitForHidden ? ' to be hidden' : ''}`;\n\n    function predicate(xpath, waitForVisible, waitForHidden) {\n      const node = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n      return checkWaitForOptions(node, waitForVisible, waitForHidden);\n    }\n\n    const waitTaskOptions = {\n      domWorld: this,\n      predicateBody: helper_js_1.helper.makePredicateString(predicate),\n      title,\n      polling,\n      timeout,\n      args: [xpath, waitForVisible, waitForHidden]\n    };\n    const waitTask = new WaitTask(waitTaskOptions);\n    const jsHandle = await waitTask.promise;\n    const elementHandle = jsHandle.asElement();\n\n    if (!elementHandle) {\n      await jsHandle.dispose();\n      return null;\n    }\n\n    return elementHandle;\n  }\n\n  waitForFunction(pageFunction, options = {}, ...args) {\n    const {\n      polling = 'raf',\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    const waitTaskOptions = {\n      domWorld: this,\n      predicateBody: pageFunction,\n      title: 'function',\n      polling,\n      timeout,\n      args\n    };\n    const waitTask = new WaitTask(waitTaskOptions);\n    return waitTask.promise;\n  }\n\n  async title() {\n    return this.evaluate(() => document.title);\n  }\n\n}\n\nexports.DOMWorld = DOMWorld;\n\nDOMWorld.bindingIdentifier = (name, contextId) => `${name}_${contextId}`;\n/**\n * @internal\n */\n\n\nclass WaitTask {\n  constructor(options) {\n    this._runCount = 0;\n    this._terminated = false;\n    if (helper_js_1.helper.isString(options.polling)) assert_js_1.assert(options.polling === 'raf' || options.polling === 'mutation', 'Unknown polling option: ' + options.polling);else if (helper_js_1.helper.isNumber(options.polling)) assert_js_1.assert(options.polling > 0, 'Cannot poll with non-positive interval: ' + options.polling);else throw new Error('Unknown polling options: ' + options.polling);\n\n    function getPredicateBody(predicateBody) {\n      if (helper_js_1.helper.isString(predicateBody)) return `return (${predicateBody});`;\n      return `return (${predicateBody})(...args);`;\n    }\n\n    this._domWorld = options.domWorld;\n    this._polling = options.polling;\n    this._timeout = options.timeout;\n    this._predicateBody = getPredicateBody(options.predicateBody);\n    this._args = options.args;\n    this._binding = options.binding;\n    this._runCount = 0;\n\n    this._domWorld._waitTasks.add(this);\n\n    if (this._binding) {\n      this._domWorld._boundFunctions.set(this._binding.name, this._binding.pptrFunction);\n    }\n\n    this.promise = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    }); // Since page navigation requires us to re-install the pageScript, we should track\n    // timeout on our end.\n\n    if (options.timeout) {\n      const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${options.title} failed: timeout ${options.timeout}ms exceeded`);\n      this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), options.timeout);\n    }\n\n    this.rerun();\n  }\n\n  terminate(error) {\n    this._terminated = true;\n\n    this._reject(error);\n\n    this._cleanup();\n  }\n\n  async rerun() {\n    const runCount = ++this._runCount;\n    let success = null;\n    let error = null;\n    const context = await this._domWorld.executionContext();\n    if (this._terminated || runCount !== this._runCount) return;\n\n    if (this._binding) {\n      await this._domWorld.addBindingToContext(context, this._binding.name);\n    }\n\n    if (this._terminated || runCount !== this._runCount) return;\n\n    try {\n      success = await context.evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);\n    } catch (error_) {\n      error = error_;\n    }\n\n    if (this._terminated || runCount !== this._runCount) {\n      if (success) await success.dispose();\n      return;\n    } // Ignore timeouts in pageScript - we track timeouts ourselves.\n    // If the frame's execution context has already changed, `frame.evaluate` will\n    // throw an error - ignore this predicate run altogether.\n\n\n    if (!error && (await this._domWorld.evaluate(s => !s, success).catch(() => true))) {\n      await success.dispose();\n      return;\n    }\n\n    if (error) {\n      if (error.message.includes('TypeError: binding is not a function')) {\n        return this.rerun();\n      } // When frame is detached the task should have been terminated by the DOMWorld.\n      // This can fail if we were adding this task while the frame was detached,\n      // so we terminate here instead.\n\n\n      if (error.message.includes('Execution context is not available in detached frame')) {\n        this.terminate(new Error('waitForFunction failed: frame got detached.'));\n        return;\n      } // When the page is navigated, the promise is rejected.\n      // We will try again in the new execution context.\n\n\n      if (error.message.includes('Execution context was destroyed')) return; // We could have tried to evaluate in a context which was already\n      // destroyed.\n\n      if (error.message.includes('Cannot find context with specified id')) return;\n\n      this._reject(error);\n    } else {\n      this._resolve(success);\n    }\n\n    this._cleanup();\n  }\n\n  _cleanup() {\n    clearTimeout(this._timeoutTimer);\n\n    this._domWorld._waitTasks.delete(this);\n  }\n\n}\n\nexports.WaitTask = WaitTask;\n\nasync function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {\n  const predicate = new Function('...args', predicateBody);\n  let timedOut = false;\n  if (timeout) setTimeout(() => timedOut = true, timeout);\n  if (polling === 'raf') return await pollRaf();\n  if (polling === 'mutation') return await pollMutation();\n  if (typeof polling === 'number') return await pollInterval(polling);\n  /**\n   * @returns {!Promise<*>}\n   */\n\n  async function pollMutation() {\n    const success = await predicate(...args);\n    if (success) return Promise.resolve(success);\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    const observer = new MutationObserver(async () => {\n      if (timedOut) {\n        observer.disconnect();\n        fulfill();\n      }\n\n      const success = await predicate(...args);\n\n      if (success) {\n        observer.disconnect();\n        fulfill(success);\n      }\n    });\n    observer.observe(document, {\n      childList: true,\n      subtree: true,\n      attributes: true\n    });\n    return result;\n  }\n\n  async function pollRaf() {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    await onRaf();\n    return result;\n\n    async function onRaf() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n\n      const success = await predicate(...args);\n      if (success) fulfill(success);else requestAnimationFrame(onRaf);\n    }\n  }\n\n  async function pollInterval(pollInterval) {\n    let fulfill;\n    const result = new Promise(x => fulfill = x);\n    await onTimeout();\n    return result;\n\n    async function onTimeout() {\n      if (timedOut) {\n        fulfill();\n        return;\n      }\n\n      const success = await predicate(...args);\n      if (success) fulfill(success);else setTimeout(onTimeout, pollInterval);\n    }\n  }\n}","map":{"version":3,"sources":["../../../../src/common/DOMWorld.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WaitTask = exports.DOMWorld = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst LifecycleWatcher_js_1 = require(\"./LifecycleWatcher.js\");\nconst Errors_js_1 = require(\"./Errors.js\");\nconst QueryHandler_js_1 = require(\"./QueryHandler.js\");\nconst environment_js_1 = require(\"../environment.js\");\n/**\n * @internal\n */\nclass DOMWorld {\n    constructor(frameManager, frame, timeoutSettings) {\n        this._documentPromise = null;\n        this._contextPromise = null;\n        this._contextResolveCallback = null;\n        this._detached = false;\n        /**\n         * @internal\n         */\n        this._waitTasks = new Set();\n        /**\n         * @internal\n         * Contains mapping from functions that should be bound to Puppeteer functions.\n         */\n        this._boundFunctions = new Map();\n        // Set of bindings that have been registered in the current context.\n        this._ctxBindings = new Set();\n        // If multiple waitFor are set up asynchronously, we need to wait for the\n        // first one to set up the binding in the page before running the others.\n        this._settingUpBinding = null;\n        this._frameManager = frameManager;\n        this._frame = frame;\n        this._timeoutSettings = timeoutSettings;\n        this._setContext(null);\n        frameManager._client.on('Runtime.bindingCalled', (event) => this._onBindingCalled(event));\n    }\n    frame() {\n        return this._frame;\n    }\n    async _setContext(context) {\n        if (context) {\n            this._contextResolveCallback.call(null, context);\n            this._contextResolveCallback = null;\n            for (const waitTask of this._waitTasks)\n                waitTask.rerun();\n        }\n        else {\n            this._documentPromise = null;\n            this._contextPromise = new Promise((fulfill) => {\n                this._contextResolveCallback = fulfill;\n            });\n        }\n    }\n    _hasContext() {\n        return !this._contextResolveCallback;\n    }\n    _detach() {\n        this._detached = true;\n        for (const waitTask of this._waitTasks)\n            waitTask.terminate(new Error('waitForFunction failed: frame got detached.'));\n    }\n    executionContext() {\n        if (this._detached)\n            throw new Error(`Execution context is not available in detached frame \"${this._frame.url()}\" (are you trying to evaluate?)`);\n        return this._contextPromise;\n    }\n    async evaluateHandle(pageFunction, ...args) {\n        const context = await this.executionContext();\n        return context.evaluateHandle(pageFunction, ...args);\n    }\n    async evaluate(pageFunction, ...args) {\n        const context = await this.executionContext();\n        return context.evaluate(pageFunction, ...args);\n    }\n    async $(selector) {\n        const document = await this._document();\n        const value = await document.$(selector);\n        return value;\n    }\n    async _document() {\n        if (this._documentPromise)\n            return this._documentPromise;\n        this._documentPromise = this.executionContext().then(async (context) => {\n            const document = await context.evaluateHandle('document');\n            return document.asElement();\n        });\n        return this._documentPromise;\n    }\n    async $x(expression) {\n        const document = await this._document();\n        const value = await document.$x(expression);\n        return value;\n    }\n    async $eval(selector, pageFunction, ...args) {\n        const document = await this._document();\n        return document.$eval(selector, pageFunction, ...args);\n    }\n    async $$eval(selector, pageFunction, ...args) {\n        const document = await this._document();\n        const value = await document.$$eval(selector, pageFunction, ...args);\n        return value;\n    }\n    async $$(selector) {\n        const document = await this._document();\n        const value = await document.$$(selector);\n        return value;\n    }\n    async content() {\n        return await this.evaluate(() => {\n            let retVal = '';\n            if (document.doctype)\n                retVal = new XMLSerializer().serializeToString(document.doctype);\n            if (document.documentElement)\n                retVal += document.documentElement.outerHTML;\n            return retVal;\n        });\n    }\n    async setContent(html, options = {}) {\n        const { waitUntil = ['load'], timeout = this._timeoutSettings.navigationTimeout(), } = options;\n        // We rely upon the fact that document.open() will reset frame lifecycle with \"init\"\n        // lifecycle event. @see https://crrev.com/608658\n        await this.evaluate((html) => {\n            document.open();\n            document.write(html);\n            document.close();\n        }, html);\n        const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);\n        const error = await Promise.race([\n            watcher.timeoutOrTerminationPromise(),\n            watcher.lifecyclePromise(),\n        ]);\n        watcher.dispose();\n        if (error)\n            throw error;\n    }\n    /**\n     * Adds a script tag into the current context.\n     *\n     * @remarks\n     *\n     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n     * in a browser environment you cannot pass a filepath and should use either\n     * `url` or `content`.\n     */\n    async addScriptTag(options) {\n        const { url = null, path = null, content = null, type = '' } = options;\n        if (url !== null) {\n            try {\n                const context = await this.executionContext();\n                return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();\n            }\n            catch (error) {\n                throw new Error(`Loading script from ${url} failed`);\n            }\n        }\n        if (path !== null) {\n            if (!environment_js_1.isNode) {\n                throw new Error('Cannot pass a filepath to addScriptTag in the browser environment.');\n            }\n            const fs = await helper_js_1.helper.importFSModule();\n            let contents = await fs.promises.readFile(path, 'utf8');\n            contents += '//# sourceURL=' + path.replace(/\\n/g, '');\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();\n        }\n        if (content !== null) {\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addScriptContent, content, type)).asElement();\n        }\n        throw new Error('Provide an object with a `url`, `path` or `content` property');\n        async function addScriptUrl(url, type) {\n            const script = document.createElement('script');\n            script.src = url;\n            if (type)\n                script.type = type;\n            const promise = new Promise((res, rej) => {\n                script.onload = res;\n                script.onerror = rej;\n            });\n            document.head.appendChild(script);\n            await promise;\n            return script;\n        }\n        function addScriptContent(content, type = 'text/javascript') {\n            const script = document.createElement('script');\n            script.type = type;\n            script.text = content;\n            let error = null;\n            script.onerror = (e) => (error = e);\n            document.head.appendChild(script);\n            if (error)\n                throw error;\n            return script;\n        }\n    }\n    /**\n     * Adds a style tag into the current context.\n     *\n     * @remarks\n     *\n     * You can pass a URL, filepath or string of contents. Note that when running Puppeteer\n     * in a browser environment you cannot pass a filepath and should use either\n     * `url` or `content`.\n     *\n     */\n    async addStyleTag(options) {\n        const { url = null, path = null, content = null } = options;\n        if (url !== null) {\n            try {\n                const context = await this.executionContext();\n                return (await context.evaluateHandle(addStyleUrl, url)).asElement();\n            }\n            catch (error) {\n                throw new Error(`Loading style from ${url} failed`);\n            }\n        }\n        if (path !== null) {\n            if (!environment_js_1.isNode) {\n                throw new Error('Cannot pass a filepath to addStyleTag in the browser environment.');\n            }\n            const fs = await helper_js_1.helper.importFSModule();\n            let contents = await fs.promises.readFile(path, 'utf8');\n            contents += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addStyleContent, contents)).asElement();\n        }\n        if (content !== null) {\n            const context = await this.executionContext();\n            return (await context.evaluateHandle(addStyleContent, content)).asElement();\n        }\n        throw new Error('Provide an object with a `url`, `path` or `content` property');\n        async function addStyleUrl(url) {\n            const link = document.createElement('link');\n            link.rel = 'stylesheet';\n            link.href = url;\n            const promise = new Promise((res, rej) => {\n                link.onload = res;\n                link.onerror = rej;\n            });\n            document.head.appendChild(link);\n            await promise;\n            return link;\n        }\n        async function addStyleContent(content) {\n            const style = document.createElement('style');\n            style.type = 'text/css';\n            style.appendChild(document.createTextNode(content));\n            const promise = new Promise((res, rej) => {\n                style.onload = res;\n                style.onerror = rej;\n            });\n            document.head.appendChild(style);\n            await promise;\n            return style;\n        }\n    }\n    async click(selector, options) {\n        const handle = await this.$(selector);\n        assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n        await handle.click(options);\n        await handle.dispose();\n    }\n    async focus(selector) {\n        const handle = await this.$(selector);\n        assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n        await handle.focus();\n        await handle.dispose();\n    }\n    async hover(selector) {\n        const handle = await this.$(selector);\n        assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n        await handle.hover();\n        await handle.dispose();\n    }\n    async select(selector, ...values) {\n        const handle = await this.$(selector);\n        assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n        const result = await handle.select(...values);\n        await handle.dispose();\n        return result;\n    }\n    async tap(selector) {\n        const handle = await this.$(selector);\n        await handle.tap();\n        await handle.dispose();\n    }\n    async type(selector, text, options) {\n        const handle = await this.$(selector);\n        assert_js_1.assert(handle, 'No node found for selector: ' + selector);\n        await handle.type(text, options);\n        await handle.dispose();\n    }\n    async waitForSelector(selector, options) {\n        const { updatedSelector, queryHandler } = QueryHandler_js_1.getQueryHandlerAndSelector(selector);\n        return queryHandler.waitFor(this, updatedSelector, options);\n    }\n    /**\n     * @internal\n     */\n    async addBindingToContext(context, name) {\n        // Previous operation added the binding so we are done.\n        if (this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId))) {\n            return;\n        }\n        // Wait for other operation to finish\n        if (this._settingUpBinding) {\n            await this._settingUpBinding;\n            return this.addBindingToContext(context, name);\n        }\n        const bind = async (name) => {\n            const expression = helper_js_1.helper.pageBindingInitString('internal', name);\n            try {\n                // TODO: In theory, it would be enough to call this just once\n                await context._client.send('Runtime.addBinding', {\n                    name,\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore The protocol definition is not up to date.\n                    executionContextName: context._contextName,\n                });\n                await context.evaluate(expression);\n            }\n            catch (error) {\n                // We could have tried to evaluate in a context which was already\n                // destroyed. This happens, for example, if the page is navigated while\n                // we are trying to add the binding\n                const ctxDestroyed = error.message.includes('Execution context was destroyed');\n                const ctxNotFound = error.message.includes('Cannot find context with specified id');\n                if (ctxDestroyed || ctxNotFound) {\n                    return;\n                }\n                else {\n                    helper_js_1.debugError(error);\n                    return;\n                }\n            }\n            this._ctxBindings.add(DOMWorld.bindingIdentifier(name, context._contextId));\n        };\n        this._settingUpBinding = bind(name);\n        await this._settingUpBinding;\n        this._settingUpBinding = null;\n    }\n    async _onBindingCalled(event) {\n        let payload;\n        if (!this._hasContext())\n            return;\n        const context = await this.executionContext();\n        try {\n            payload = JSON.parse(event.payload);\n        }\n        catch {\n            // The binding was either called by something in the page or it was\n            // called before our wrapper was initialized.\n            return;\n        }\n        const { type, name, seq, args } = payload;\n        if (type !== 'internal' ||\n            !this._ctxBindings.has(DOMWorld.bindingIdentifier(name, context._contextId)))\n            return;\n        if (context._contextId !== event.executionContextId)\n            return;\n        try {\n            const result = await this._boundFunctions.get(name)(...args);\n            await context.evaluate(deliverResult, name, seq, result);\n        }\n        catch (error) {\n            // The WaitTask may already have been resolved by timing out, or the\n            // exection context may have been destroyed.\n            // In both caes, the promises above are rejected with a protocol error.\n            // We can safely ignores these, as the WaitTask is re-installed in\n            // the next execution context if needed.\n            if (error.message.includes('Protocol error'))\n                return;\n            helper_js_1.debugError(error);\n        }\n        function deliverResult(name, seq, result) {\n            globalThis[name].callbacks.get(seq).resolve(result);\n            globalThis[name].callbacks.delete(seq);\n        }\n    }\n    /**\n     * @internal\n     */\n    async waitForSelectorInPage(queryOne, selector, options, binding) {\n        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;\n        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n        const title = `selector \\`${selector}\\`${waitForHidden ? ' to be hidden' : ''}`;\n        async function predicate(selector, waitForVisible, waitForHidden) {\n            const node = predicateQueryHandler\n                ? (await predicateQueryHandler(document, selector))\n                : document.querySelector(selector);\n            return checkWaitForOptions(node, waitForVisible, waitForHidden);\n        }\n        const waitTaskOptions = {\n            domWorld: this,\n            predicateBody: helper_js_1.helper.makePredicateString(predicate, queryOne),\n            title,\n            polling,\n            timeout,\n            args: [selector, waitForVisible, waitForHidden],\n            binding,\n        };\n        const waitTask = new WaitTask(waitTaskOptions);\n        const jsHandle = await waitTask.promise;\n        const elementHandle = jsHandle.asElement();\n        if (!elementHandle) {\n            await jsHandle.dispose();\n            return null;\n        }\n        return elementHandle;\n    }\n    async waitForXPath(xpath, options) {\n        const { visible: waitForVisible = false, hidden: waitForHidden = false, timeout = this._timeoutSettings.timeout(), } = options;\n        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';\n        const title = `XPath \\`${xpath}\\`${waitForHidden ? ' to be hidden' : ''}`;\n        function predicate(xpath, waitForVisible, waitForHidden) {\n            const node = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;\n            return checkWaitForOptions(node, waitForVisible, waitForHidden);\n        }\n        const waitTaskOptions = {\n            domWorld: this,\n            predicateBody: helper_js_1.helper.makePredicateString(predicate),\n            title,\n            polling,\n            timeout,\n            args: [xpath, waitForVisible, waitForHidden],\n        };\n        const waitTask = new WaitTask(waitTaskOptions);\n        const jsHandle = await waitTask.promise;\n        const elementHandle = jsHandle.asElement();\n        if (!elementHandle) {\n            await jsHandle.dispose();\n            return null;\n        }\n        return elementHandle;\n    }\n    waitForFunction(pageFunction, options = {}, ...args) {\n        const { polling = 'raf', timeout = this._timeoutSettings.timeout(), } = options;\n        const waitTaskOptions = {\n            domWorld: this,\n            predicateBody: pageFunction,\n            title: 'function',\n            polling,\n            timeout,\n            args,\n        };\n        const waitTask = new WaitTask(waitTaskOptions);\n        return waitTask.promise;\n    }\n    async title() {\n        return this.evaluate(() => document.title);\n    }\n}\nexports.DOMWorld = DOMWorld;\nDOMWorld.bindingIdentifier = (name, contextId) => `${name}_${contextId}`;\n/**\n * @internal\n */\nclass WaitTask {\n    constructor(options) {\n        this._runCount = 0;\n        this._terminated = false;\n        if (helper_js_1.helper.isString(options.polling))\n            assert_js_1.assert(options.polling === 'raf' || options.polling === 'mutation', 'Unknown polling option: ' + options.polling);\n        else if (helper_js_1.helper.isNumber(options.polling))\n            assert_js_1.assert(options.polling > 0, 'Cannot poll with non-positive interval: ' + options.polling);\n        else\n            throw new Error('Unknown polling options: ' + options.polling);\n        function getPredicateBody(predicateBody) {\n            if (helper_js_1.helper.isString(predicateBody))\n                return `return (${predicateBody});`;\n            return `return (${predicateBody})(...args);`;\n        }\n        this._domWorld = options.domWorld;\n        this._polling = options.polling;\n        this._timeout = options.timeout;\n        this._predicateBody = getPredicateBody(options.predicateBody);\n        this._args = options.args;\n        this._binding = options.binding;\n        this._runCount = 0;\n        this._domWorld._waitTasks.add(this);\n        if (this._binding) {\n            this._domWorld._boundFunctions.set(this._binding.name, this._binding.pptrFunction);\n        }\n        this.promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        // Since page navigation requires us to re-install the pageScript, we should track\n        // timeout on our end.\n        if (options.timeout) {\n            const timeoutError = new Errors_js_1.TimeoutError(`waiting for ${options.title} failed: timeout ${options.timeout}ms exceeded`);\n            this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), options.timeout);\n        }\n        this.rerun();\n    }\n    terminate(error) {\n        this._terminated = true;\n        this._reject(error);\n        this._cleanup();\n    }\n    async rerun() {\n        const runCount = ++this._runCount;\n        let success = null;\n        let error = null;\n        const context = await this._domWorld.executionContext();\n        if (this._terminated || runCount !== this._runCount)\n            return;\n        if (this._binding) {\n            await this._domWorld.addBindingToContext(context, this._binding.name);\n        }\n        if (this._terminated || runCount !== this._runCount)\n            return;\n        try {\n            success = await context.evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);\n        }\n        catch (error_) {\n            error = error_;\n        }\n        if (this._terminated || runCount !== this._runCount) {\n            if (success)\n                await success.dispose();\n            return;\n        }\n        // Ignore timeouts in pageScript - we track timeouts ourselves.\n        // If the frame's execution context has already changed, `frame.evaluate` will\n        // throw an error - ignore this predicate run altogether.\n        if (!error &&\n            (await this._domWorld.evaluate((s) => !s, success).catch(() => true))) {\n            await success.dispose();\n            return;\n        }\n        if (error) {\n            if (error.message.includes('TypeError: binding is not a function')) {\n                return this.rerun();\n            }\n            // When frame is detached the task should have been terminated by the DOMWorld.\n            // This can fail if we were adding this task while the frame was detached,\n            // so we terminate here instead.\n            if (error.message.includes('Execution context is not available in detached frame')) {\n                this.terminate(new Error('waitForFunction failed: frame got detached.'));\n                return;\n            }\n            // When the page is navigated, the promise is rejected.\n            // We will try again in the new execution context.\n            if (error.message.includes('Execution context was destroyed'))\n                return;\n            // We could have tried to evaluate in a context which was already\n            // destroyed.\n            if (error.message.includes('Cannot find context with specified id'))\n                return;\n            this._reject(error);\n        }\n        else {\n            this._resolve(success);\n        }\n        this._cleanup();\n    }\n    _cleanup() {\n        clearTimeout(this._timeoutTimer);\n        this._domWorld._waitTasks.delete(this);\n    }\n}\nexports.WaitTask = WaitTask;\nasync function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {\n    const predicate = new Function('...args', predicateBody);\n    let timedOut = false;\n    if (timeout)\n        setTimeout(() => (timedOut = true), timeout);\n    if (polling === 'raf')\n        return await pollRaf();\n    if (polling === 'mutation')\n        return await pollMutation();\n    if (typeof polling === 'number')\n        return await pollInterval(polling);\n    /**\n     * @returns {!Promise<*>}\n     */\n    async function pollMutation() {\n        const success = await predicate(...args);\n        if (success)\n            return Promise.resolve(success);\n        let fulfill;\n        const result = new Promise((x) => (fulfill = x));\n        const observer = new MutationObserver(async () => {\n            if (timedOut) {\n                observer.disconnect();\n                fulfill();\n            }\n            const success = await predicate(...args);\n            if (success) {\n                observer.disconnect();\n                fulfill(success);\n            }\n        });\n        observer.observe(document, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n        });\n        return result;\n    }\n    async function pollRaf() {\n        let fulfill;\n        const result = new Promise((x) => (fulfill = x));\n        await onRaf();\n        return result;\n        async function onRaf() {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const success = await predicate(...args);\n            if (success)\n                fulfill(success);\n            else\n                requestAnimationFrame(onRaf);\n        }\n    }\n    async function pollInterval(pollInterval) {\n        let fulfill;\n        const result = new Promise((x) => (fulfill = x));\n        await onTimeout();\n        return result;\n        async function onTimeout() {\n            if (timedOut) {\n                fulfill();\n                return;\n            }\n            const success = await predicate(...args);\n            if (success)\n                fulfill(success);\n            else\n                setTimeout(onTimeout, pollInterval);\n        }\n    }\n}\n//# sourceMappingURL=DOMWorld.js.map"]},"metadata":{},"sourceType":"script"}