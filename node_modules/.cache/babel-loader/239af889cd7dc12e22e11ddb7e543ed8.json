{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTTPResponse = void 0;\n\nconst SecurityDetails_js_1 = require(\"./SecurityDetails.js\");\n/**\n * The HTTPResponse class represents responses which are received by the\n * {@link Page} class.\n *\n * @public\n */\n\n\nclass HTTPResponse {\n  /**\n   * @internal\n   */\n  constructor(client, request, responsePayload) {\n    this._contentPromise = null;\n    this._headers = {};\n    this._client = client;\n    this._request = request;\n    this._bodyLoadedPromise = new Promise(fulfill => {\n      this._bodyLoadedPromiseFulfill = fulfill;\n    });\n    this._remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort\n    };\n    this._status = responsePayload.status;\n    this._statusText = responsePayload.statusText;\n    this._url = request.url();\n    this._fromDiskCache = !!responsePayload.fromDiskCache;\n    this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n\n    for (const key of Object.keys(responsePayload.headers)) this._headers[key.toLowerCase()] = responsePayload.headers[key];\n\n    this._securityDetails = responsePayload.securityDetails ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails) : null;\n  }\n  /**\n   * @internal\n   */\n\n\n  _resolveBody(err) {\n    return this._bodyLoadedPromiseFulfill(err);\n  }\n  /**\n   * @returns The IP address and port number used to connect to the remote\n   * server.\n   */\n\n\n  remoteAddress() {\n    return this._remoteAddress;\n  }\n  /**\n   * @returns The URL of the response.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @returns True if the response was successful (status in the range 200-299).\n   */\n\n\n  ok() {\n    // TODO: document === 0 case?\n    return this._status === 0 || this._status >= 200 && this._status <= 299;\n  }\n  /**\n   * @returns The status code of the response (e.g., 200 for a success).\n   */\n\n\n  status() {\n    return this._status;\n  }\n  /**\n   * @returns  The status text of the response (e.g. usually an \"OK\" for a\n   * success).\n   */\n\n\n  statusText() {\n    return this._statusText;\n  }\n  /**\n   * @returns An object with HTTP headers associated with the response. All\n   * header names are lower-case.\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @returns {@link SecurityDetails} if the response was received over the\n   * secure connection, or `null` otherwise.\n   */\n\n\n  securityDetails() {\n    return this._securityDetails;\n  }\n  /**\n   * @returns Promise which resolves to a buffer with response body.\n   */\n\n\n  buffer() {\n    if (!this._contentPromise) {\n      this._contentPromise = this._bodyLoadedPromise.then(async error => {\n        if (error) throw error;\n        const response = await this._client.send('Network.getResponseBody', {\n          requestId: this._request._requestId\n        });\n        return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n      });\n    }\n\n    return this._contentPromise;\n  }\n  /**\n   * @returns Promise which resolves to a text representation of response body.\n   */\n\n\n  async text() {\n    const content = await this.buffer();\n    return content.toString('utf8');\n  }\n  /**\n   *\n   * @returns Promise which resolves to a JSON representation of response body.\n   *\n   * @remarks\n   *\n   * This method will throw if the response body is not parsable via\n   * `JSON.parse`.\n   */\n\n\n  async json() {\n    const content = await this.text();\n    return JSON.parse(content);\n  }\n  /**\n   * @returns A matching {@link HTTPRequest} object.\n   */\n\n\n  request() {\n    return this._request;\n  }\n  /**\n   * @returns True if the response was served from either the browser's disk\n   * cache or memory cache.\n   */\n\n\n  fromCache() {\n    return this._fromDiskCache || this._request._fromMemoryCache;\n  }\n  /**\n   * @returns True if the response was served by a service worker.\n   */\n\n\n  fromServiceWorker() {\n    return this._fromServiceWorker;\n  }\n  /**\n   * @returns A {@link Frame} that initiated this response, or `null` if\n   * navigating to error pages.\n   */\n\n\n  frame() {\n    return this._request.frame();\n  }\n\n}\n\nexports.HTTPResponse = HTTPResponse;","map":{"version":3,"sources":["../../../../src/common/HTTPResponse.ts"],"names":[],"mappings":";;;;;;;AAkBA,MAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;AAWA;;;;;AAKG;;;AACH,MAAa,YAAb,CAAyB;AAevB;;AAEG;AACH,EAAA,WAAA,CACE,MADF,EAEE,OAFF,EAGE,eAHF,EAG4C;AAlBpC,SAAA,eAAA,GAA0C,IAA1C;AASA,SAAA,QAAA,GAAmC,EAAnC;AAWN,SAAK,OAAL,GAAe,MAAf;AACA,SAAK,QAAL,GAAgB,OAAhB;AAEA,SAAK,kBAAL,GAA0B,IAAI,OAAJ,CAAa,OAAD,IAAY;AAChD,WAAK,yBAAL,GAAiC,OAAjC;AACD,KAFyB,CAA1B;AAIA,SAAK,cAAL,GAAsB;AACpB,MAAA,EAAE,EAAE,eAAe,CAAC,eADA;AAEpB,MAAA,IAAI,EAAE,eAAe,CAAC;AAFF,KAAtB;AAIA,SAAK,OAAL,GAAe,eAAe,CAAC,MAA/B;AACA,SAAK,WAAL,GAAmB,eAAe,CAAC,UAAnC;AACA,SAAK,IAAL,GAAY,OAAO,CAAC,GAAR,EAAZ;AACA,SAAK,cAAL,GAAsB,CAAC,CAAC,eAAe,CAAC,aAAxC;AACA,SAAK,kBAAL,GAA0B,CAAC,CAAC,eAAe,CAAC,iBAA5C;;AACA,SAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,eAAe,CAAC,OAA5B,CAAlB,EACE,KAAK,QAAL,CAAc,GAAG,CAAC,WAAJ,EAAd,IAAmC,eAAe,CAAC,OAAhB,CAAwB,GAAxB,CAAnC;;AACF,SAAK,gBAAL,GAAwB,eAAe,CAAC,eAAhB,GACpB,IAAI,oBAAA,CAAA,eAAJ,CAAoB,eAAe,CAAC,eAApC,CADoB,GAEpB,IAFJ;AAGD;AAED;;AAEG;;;AACH,EAAA,YAAY,CAAC,GAAD,EAAkB;AAC5B,WAAO,KAAK,yBAAL,CAA+B,GAA/B,CAAP;AACD;AAED;;;AAGG;;;AACH,EAAA,aAAa,GAAA;AACX,WAAO,KAAK,cAAZ;AACD;AAED;;AAEG;;;AACH,EAAA,GAAG,GAAA;AACD,WAAO,KAAK,IAAZ;AACD;AAED;;AAEG;;;AACH,EAAA,EAAE,GAAA;AACA;AACA,WAAO,KAAK,OAAL,KAAiB,CAAjB,IAAuB,KAAK,OAAL,IAAgB,GAAhB,IAAuB,KAAK,OAAL,IAAgB,GAArE;AACD;AAED;;AAEG;;;AACH,EAAA,MAAM,GAAA;AACJ,WAAO,KAAK,OAAZ;AACD;AAED;;;AAGG;;;AACH,EAAA,UAAU,GAAA;AACR,WAAO,KAAK,WAAZ;AACD;AAED;;;AAGG;;;AACH,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,QAAZ;AACD;AAED;;;AAGG;;;AACH,EAAA,eAAe,GAAA;AACb,WAAO,KAAK,gBAAZ;AACD;AAED;;AAEG;;;AACH,EAAA,MAAM,GAAA;AACJ,QAAI,CAAC,KAAK,eAAV,EAA2B;AACzB,WAAK,eAAL,GAAuB,KAAK,kBAAL,CAAwB,IAAxB,CAA6B,MAAO,KAAP,IAAgB;AAClE,YAAI,KAAJ,EAAW,MAAM,KAAN;AACX,cAAM,QAAQ,GAAG,MAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,yBAAlB,EAA6C;AAClE,UAAA,SAAS,EAAE,KAAK,QAAL,CAAc;AADyC,SAA7C,CAAvB;AAGA,eAAO,MAAM,CAAC,IAAP,CACL,QAAQ,CAAC,IADJ,EAEL,QAAQ,CAAC,aAAT,GAAyB,QAAzB,GAAoC,MAF/B,CAAP;AAID,OATsB,CAAvB;AAUD;;AACD,WAAO,KAAK,eAAZ;AACD;AAED;;AAEG;;;AACO,QAAJ,IAAI,GAAA;AACR,UAAM,OAAO,GAAG,MAAM,KAAK,MAAL,EAAtB;AACA,WAAO,OAAO,CAAC,QAAR,CAAiB,MAAjB,CAAP;AACD;AAED;;;;;;;;AAQG;;;AACO,QAAJ,IAAI,GAAA;AACR,UAAM,OAAO,GAAG,MAAM,KAAK,IAAL,EAAtB;AACA,WAAO,IAAI,CAAC,KAAL,CAAW,OAAX,CAAP;AACD;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACL,WAAO,KAAK,QAAZ;AACD;AAED;;;AAGG;;;AACH,EAAA,SAAS,GAAA;AACP,WAAO,KAAK,cAAL,IAAuB,KAAK,QAAL,CAAc,gBAA5C;AACD;AAED;;AAEG;;;AACH,EAAA,iBAAiB,GAAA;AACf,WAAO,KAAK,kBAAZ;AACD;AAED;;;AAGG;;;AACH,EAAA,KAAK,GAAA;AACH,WAAO,KAAK,QAAL,CAAc,KAAd,EAAP;AACD;;AAhLsB;;AAAzB,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTTPResponse = void 0;\nconst SecurityDetails_js_1 = require(\"./SecurityDetails.js\");\n/**\n * The HTTPResponse class represents responses which are received by the\n * {@link Page} class.\n *\n * @public\n */\nclass HTTPResponse {\n    /**\n     * @internal\n     */\n    constructor(client, request, responsePayload) {\n        this._contentPromise = null;\n        this._headers = {};\n        this._client = client;\n        this._request = request;\n        this._bodyLoadedPromise = new Promise((fulfill) => {\n            this._bodyLoadedPromiseFulfill = fulfill;\n        });\n        this._remoteAddress = {\n            ip: responsePayload.remoteIPAddress,\n            port: responsePayload.remotePort,\n        };\n        this._status = responsePayload.status;\n        this._statusText = responsePayload.statusText;\n        this._url = request.url();\n        this._fromDiskCache = !!responsePayload.fromDiskCache;\n        this._fromServiceWorker = !!responsePayload.fromServiceWorker;\n        for (const key of Object.keys(responsePayload.headers))\n            this._headers[key.toLowerCase()] = responsePayload.headers[key];\n        this._securityDetails = responsePayload.securityDetails\n            ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails)\n            : null;\n    }\n    /**\n     * @internal\n     */\n    _resolveBody(err) {\n        return this._bodyLoadedPromiseFulfill(err);\n    }\n    /**\n     * @returns The IP address and port number used to connect to the remote\n     * server.\n     */\n    remoteAddress() {\n        return this._remoteAddress;\n    }\n    /**\n     * @returns The URL of the response.\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * @returns True if the response was successful (status in the range 200-299).\n     */\n    ok() {\n        // TODO: document === 0 case?\n        return this._status === 0 || (this._status >= 200 && this._status <= 299);\n    }\n    /**\n     * @returns The status code of the response (e.g., 200 for a success).\n     */\n    status() {\n        return this._status;\n    }\n    /**\n     * @returns  The status text of the response (e.g. usually an \"OK\" for a\n     * success).\n     */\n    statusText() {\n        return this._statusText;\n    }\n    /**\n     * @returns An object with HTTP headers associated with the response. All\n     * header names are lower-case.\n     */\n    headers() {\n        return this._headers;\n    }\n    /**\n     * @returns {@link SecurityDetails} if the response was received over the\n     * secure connection, or `null` otherwise.\n     */\n    securityDetails() {\n        return this._securityDetails;\n    }\n    /**\n     * @returns Promise which resolves to a buffer with response body.\n     */\n    buffer() {\n        if (!this._contentPromise) {\n            this._contentPromise = this._bodyLoadedPromise.then(async (error) => {\n                if (error)\n                    throw error;\n                const response = await this._client.send('Network.getResponseBody', {\n                    requestId: this._request._requestId,\n                });\n                return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n            });\n        }\n        return this._contentPromise;\n    }\n    /**\n     * @returns Promise which resolves to a text representation of response body.\n     */\n    async text() {\n        const content = await this.buffer();\n        return content.toString('utf8');\n    }\n    /**\n     *\n     * @returns Promise which resolves to a JSON representation of response body.\n     *\n     * @remarks\n     *\n     * This method will throw if the response body is not parsable via\n     * `JSON.parse`.\n     */\n    async json() {\n        const content = await this.text();\n        return JSON.parse(content);\n    }\n    /**\n     * @returns A matching {@link HTTPRequest} object.\n     */\n    request() {\n        return this._request;\n    }\n    /**\n     * @returns True if the response was served from either the browser's disk\n     * cache or memory cache.\n     */\n    fromCache() {\n        return this._fromDiskCache || this._request._fromMemoryCache;\n    }\n    /**\n     * @returns True if the response was served by a service worker.\n     */\n    fromServiceWorker() {\n        return this._fromServiceWorker;\n    }\n    /**\n     * @returns A {@link Frame} that initiated this response, or `null` if\n     * navigating to error pages.\n     */\n    frame() {\n        return this._request.frame();\n    }\n}\nexports.HTTPResponse = HTTPResponse;\n//# sourceMappingURL=HTTPResponse.js.map"]},"metadata":{},"sourceType":"script"}