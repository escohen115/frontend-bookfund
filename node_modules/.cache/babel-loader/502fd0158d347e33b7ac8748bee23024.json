{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Accessibility = void 0;\n/**\n * The Accessibility class provides methods for inspecting Chromium's\n * accessibility tree. The accessibility tree is used by assistive technology\n * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or\n * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.\n *\n * @remarks\n *\n * Accessibility is a very platform-specific thing. On different platforms,\n * there are different screen readers that might have wildly different output.\n *\n * Blink - Chrome's rendering engine - has a concept of \"accessibility tree\",\n * which is then translated into different platform-specific APIs. Accessibility\n * namespace gives users access to the Blink Accessibility Tree.\n *\n * Most of the accessibility tree gets filtered out when converting from Blink\n * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.\n * By default, Puppeteer tries to approximate this filtering, exposing only\n * the \"interesting\" nodes of the tree.\n *\n * @public\n */\n\nclass Accessibility {\n  /**\n   * @internal\n   */\n  constructor(client) {\n    this._client = client;\n  }\n  /**\n   * Captures the current state of the accessibility tree.\n   * The returned object represents the root accessible node of the page.\n   *\n   * @remarks\n   *\n   * **NOTE** The Chromium accessibility tree contains nodes that go unused on\n   * most platforms and by most screen readers. Puppeteer will discard them as\n   * well for an easier to process tree, unless `interestingOnly` is set to\n   * `false`.\n   *\n   * @example\n   * An example of dumping the entire accessibility tree:\n   * ```js\n   * const snapshot = await page.accessibility.snapshot();\n   * console.log(snapshot);\n   * ```\n   *\n   * @example\n   * An example of logging the focused node's name:\n   * ```js\n   * const snapshot = await page.accessibility.snapshot();\n   * const node = findFocusedNode(snapshot);\n   * console.log(node && node.name);\n   *\n   * function findFocusedNode(node) {\n   *   if (node.focused)\n   *     return node;\n   *   for (const child of node.children || []) {\n   *     const foundNode = findFocusedNode(child);\n   *     return foundNode;\n   *   }\n   *   return null;\n   * }\n   * ```\n   *\n   * @returns An AXNode object representing the snapshot.\n   *\n   */\n\n\n  async snapshot(options = {}) {\n    const {\n      interestingOnly = true,\n      root = null\n    } = options;\n    const {\n      nodes\n    } = await this._client.send('Accessibility.getFullAXTree');\n    let backendNodeId = null;\n\n    if (root) {\n      const {\n        node\n      } = await this._client.send('DOM.describeNode', {\n        objectId: root._remoteObject.objectId\n      });\n      backendNodeId = node.backendNodeId;\n    }\n\n    const defaultRoot = AXNode.createTree(nodes);\n    let needle = defaultRoot;\n\n    if (backendNodeId) {\n      needle = defaultRoot.find(node => node.payload.backendDOMNodeId === backendNodeId);\n      if (!needle) return null;\n    }\n\n    if (!interestingOnly) return this.serializeTree(needle)[0];\n    const interestingNodes = new Set();\n    this.collectInterestingNodes(interestingNodes, defaultRoot, false);\n    if (!interestingNodes.has(needle)) return null;\n    return this.serializeTree(needle, interestingNodes)[0];\n  }\n\n  serializeTree(node, interestingNodes) {\n    const children = [];\n\n    for (const child of node.children) children.push(...this.serializeTree(child, interestingNodes));\n\n    if (interestingNodes && !interestingNodes.has(node)) return children;\n    const serializedNode = node.serialize();\n    if (children.length) serializedNode.children = children;\n    return [serializedNode];\n  }\n\n  collectInterestingNodes(collection, node, insideControl) {\n    if (node.isInteresting(insideControl)) collection.add(node);\n    if (node.isLeafNode()) return;\n    insideControl = insideControl || node.isControl();\n\n    for (const child of node.children) this.collectInterestingNodes(collection, child, insideControl);\n  }\n\n}\n\nexports.Accessibility = Accessibility;\n\nclass AXNode {\n  constructor(payload) {\n    this.children = [];\n    this._richlyEditable = false;\n    this._editable = false;\n    this._focusable = false;\n    this._hidden = false;\n    this.payload = payload;\n    this._name = this.payload.name ? this.payload.name.value : '';\n    this._role = this.payload.role ? this.payload.role.value : 'Unknown';\n    this._ignored = this.payload.ignored;\n\n    for (const property of this.payload.properties || []) {\n      if (property.name === 'editable') {\n        this._richlyEditable = property.value.value === 'richtext';\n        this._editable = true;\n      }\n\n      if (property.name === 'focusable') this._focusable = property.value.value;\n      if (property.name === 'hidden') this._hidden = property.value.value;\n    }\n  }\n\n  _isPlainTextField() {\n    if (this._richlyEditable) return false;\n    if (this._editable) return true;\n    return this._role === 'textbox' || this._role === 'searchbox';\n  }\n\n  _isTextOnlyObject() {\n    const role = this._role;\n    return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox';\n  }\n\n  _hasFocusableChild() {\n    if (this._cachedHasFocusableChild === undefined) {\n      this._cachedHasFocusableChild = false;\n\n      for (const child of this.children) {\n        if (child._focusable || child._hasFocusableChild()) {\n          this._cachedHasFocusableChild = true;\n          break;\n        }\n      }\n    }\n\n    return this._cachedHasFocusableChild;\n  }\n\n  find(predicate) {\n    if (predicate(this)) return this;\n\n    for (const child of this.children) {\n      const result = child.find(predicate);\n      if (result) return result;\n    }\n\n    return null;\n  }\n\n  isLeafNode() {\n    if (!this.children.length) return true; // These types of objects may have children that we use as internal\n    // implementation details, but we want to expose them as leaves to platform\n    // accessibility APIs because screen readers might be confused if they find\n    // any children.\n\n    if (this._isPlainTextField() || this._isTextOnlyObject()) return true; // Roles whose children are only presentational according to the ARIA and\n    // HTML5 Specs should be hidden from screen readers.\n    // (Note that whilst ARIA buttons can have only presentational children, HTML5\n    // buttons are allowed to have content.)\n\n    switch (this._role) {\n      case 'doc-cover':\n      case 'graphics-symbol':\n      case 'img':\n      case 'Meter':\n      case 'scrollbar':\n      case 'slider':\n      case 'separator':\n      case 'progressbar':\n        return true;\n\n      default:\n        break;\n    } // Here and below: Android heuristics\n\n\n    if (this._hasFocusableChild()) return false;\n    if (this._focusable && this._name) return true;\n    if (this._role === 'heading' && this._name) return true;\n    return false;\n  }\n\n  isControl() {\n    switch (this._role) {\n      case 'button':\n      case 'checkbox':\n      case 'ColorWell':\n      case 'combobox':\n      case 'DisclosureTriangle':\n      case 'listbox':\n      case 'menu':\n      case 'menubar':\n      case 'menuitem':\n      case 'menuitemcheckbox':\n      case 'menuitemradio':\n      case 'radio':\n      case 'scrollbar':\n      case 'searchbox':\n      case 'slider':\n      case 'spinbutton':\n      case 'switch':\n      case 'tab':\n      case 'textbox':\n      case 'tree':\n      case 'treeitem':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  isInteresting(insideControl) {\n    const role = this._role;\n    if (role === 'Ignored' || this._hidden || this._ignored) return false;\n    if (this._focusable || this._richlyEditable) return true; // If it's not focusable but has a control role, then it's interesting.\n\n    if (this.isControl()) return true; // A non focusable child of a control is not interesting\n\n    if (insideControl) return false;\n    return this.isLeafNode() && !!this._name;\n  }\n\n  serialize() {\n    const properties = new Map();\n\n    for (const property of this.payload.properties || []) properties.set(property.name.toLowerCase(), property.value.value);\n\n    if (this.payload.name) properties.set('name', this.payload.name.value);\n    if (this.payload.value) properties.set('value', this.payload.value.value);\n    if (this.payload.description) properties.set('description', this.payload.description.value);\n    const node = {\n      role: this._role\n    };\n    const userStringProperties = ['name', 'value', 'description', 'keyshortcuts', 'roledescription', 'valuetext'];\n\n    const getUserStringPropertyValue = key => properties.get(key);\n\n    for (const userStringProperty of userStringProperties) {\n      if (!properties.has(userStringProperty)) continue;\n      node[userStringProperty] = getUserStringPropertyValue(userStringProperty);\n    }\n\n    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];\n\n    const getBooleanPropertyValue = key => properties.get(key);\n\n    for (const booleanProperty of booleanProperties) {\n      // WebArea's treat focus differently than other nodes. They report whether\n      // their frame  has focus, not whether focus is specifically on the root\n      // node.\n      if (booleanProperty === 'focused' && this._role === 'WebArea') continue;\n      const value = getBooleanPropertyValue(booleanProperty);\n      if (!value) continue;\n      node[booleanProperty] = getBooleanPropertyValue(booleanProperty);\n    }\n\n    const tristateProperties = ['checked', 'pressed'];\n\n    for (const tristateProperty of tristateProperties) {\n      if (!properties.has(tristateProperty)) continue;\n      const value = properties.get(tristateProperty);\n      node[tristateProperty] = value === 'mixed' ? 'mixed' : value === 'true' ? true : false;\n    }\n\n    const numericalProperties = ['level', 'valuemax', 'valuemin'];\n\n    const getNumericalPropertyValue = key => properties.get(key);\n\n    for (const numericalProperty of numericalProperties) {\n      if (!properties.has(numericalProperty)) continue;\n      node[numericalProperty] = getNumericalPropertyValue(numericalProperty);\n    }\n\n    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];\n\n    const getTokenPropertyValue = key => properties.get(key);\n\n    for (const tokenProperty of tokenProperties) {\n      const value = getTokenPropertyValue(tokenProperty);\n      if (!value || value === 'false') continue;\n      node[tokenProperty] = getTokenPropertyValue(tokenProperty);\n    }\n\n    return node;\n  }\n\n  static createTree(payloads) {\n    const nodeById = new Map();\n\n    for (const payload of payloads) nodeById.set(payload.nodeId, new AXNode(payload));\n\n    for (const node of nodeById.values()) {\n      for (const childId of node.payload.childIds || []) node.children.push(nodeById.get(childId));\n    }\n\n    return nodeById.values().next().value;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/common/Accessibility.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Accessibility = void 0;\n/**\n * The Accessibility class provides methods for inspecting Chromium's\n * accessibility tree. The accessibility tree is used by assistive technology\n * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or\n * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.\n *\n * @remarks\n *\n * Accessibility is a very platform-specific thing. On different platforms,\n * there are different screen readers that might have wildly different output.\n *\n * Blink - Chrome's rendering engine - has a concept of \"accessibility tree\",\n * which is then translated into different platform-specific APIs. Accessibility\n * namespace gives users access to the Blink Accessibility Tree.\n *\n * Most of the accessibility tree gets filtered out when converting from Blink\n * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.\n * By default, Puppeteer tries to approximate this filtering, exposing only\n * the \"interesting\" nodes of the tree.\n *\n * @public\n */\nclass Accessibility {\n    /**\n     * @internal\n     */\n    constructor(client) {\n        this._client = client;\n    }\n    /**\n     * Captures the current state of the accessibility tree.\n     * The returned object represents the root accessible node of the page.\n     *\n     * @remarks\n     *\n     * **NOTE** The Chromium accessibility tree contains nodes that go unused on\n     * most platforms and by most screen readers. Puppeteer will discard them as\n     * well for an easier to process tree, unless `interestingOnly` is set to\n     * `false`.\n     *\n     * @example\n     * An example of dumping the entire accessibility tree:\n     * ```js\n     * const snapshot = await page.accessibility.snapshot();\n     * console.log(snapshot);\n     * ```\n     *\n     * @example\n     * An example of logging the focused node's name:\n     * ```js\n     * const snapshot = await page.accessibility.snapshot();\n     * const node = findFocusedNode(snapshot);\n     * console.log(node && node.name);\n     *\n     * function findFocusedNode(node) {\n     *   if (node.focused)\n     *     return node;\n     *   for (const child of node.children || []) {\n     *     const foundNode = findFocusedNode(child);\n     *     return foundNode;\n     *   }\n     *   return null;\n     * }\n     * ```\n     *\n     * @returns An AXNode object representing the snapshot.\n     *\n     */\n    async snapshot(options = {}) {\n        const { interestingOnly = true, root = null } = options;\n        const { nodes } = await this._client.send('Accessibility.getFullAXTree');\n        let backendNodeId = null;\n        if (root) {\n            const { node } = await this._client.send('DOM.describeNode', {\n                objectId: root._remoteObject.objectId,\n            });\n            backendNodeId = node.backendNodeId;\n        }\n        const defaultRoot = AXNode.createTree(nodes);\n        let needle = defaultRoot;\n        if (backendNodeId) {\n            needle = defaultRoot.find((node) => node.payload.backendDOMNodeId === backendNodeId);\n            if (!needle)\n                return null;\n        }\n        if (!interestingOnly)\n            return this.serializeTree(needle)[0];\n        const interestingNodes = new Set();\n        this.collectInterestingNodes(interestingNodes, defaultRoot, false);\n        if (!interestingNodes.has(needle))\n            return null;\n        return this.serializeTree(needle, interestingNodes)[0];\n    }\n    serializeTree(node, interestingNodes) {\n        const children = [];\n        for (const child of node.children)\n            children.push(...this.serializeTree(child, interestingNodes));\n        if (interestingNodes && !interestingNodes.has(node))\n            return children;\n        const serializedNode = node.serialize();\n        if (children.length)\n            serializedNode.children = children;\n        return [serializedNode];\n    }\n    collectInterestingNodes(collection, node, insideControl) {\n        if (node.isInteresting(insideControl))\n            collection.add(node);\n        if (node.isLeafNode())\n            return;\n        insideControl = insideControl || node.isControl();\n        for (const child of node.children)\n            this.collectInterestingNodes(collection, child, insideControl);\n    }\n}\nexports.Accessibility = Accessibility;\nclass AXNode {\n    constructor(payload) {\n        this.children = [];\n        this._richlyEditable = false;\n        this._editable = false;\n        this._focusable = false;\n        this._hidden = false;\n        this.payload = payload;\n        this._name = this.payload.name ? this.payload.name.value : '';\n        this._role = this.payload.role ? this.payload.role.value : 'Unknown';\n        this._ignored = this.payload.ignored;\n        for (const property of this.payload.properties || []) {\n            if (property.name === 'editable') {\n                this._richlyEditable = property.value.value === 'richtext';\n                this._editable = true;\n            }\n            if (property.name === 'focusable')\n                this._focusable = property.value.value;\n            if (property.name === 'hidden')\n                this._hidden = property.value.value;\n        }\n    }\n    _isPlainTextField() {\n        if (this._richlyEditable)\n            return false;\n        if (this._editable)\n            return true;\n        return this._role === 'textbox' || this._role === 'searchbox';\n    }\n    _isTextOnlyObject() {\n        const role = this._role;\n        return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox';\n    }\n    _hasFocusableChild() {\n        if (this._cachedHasFocusableChild === undefined) {\n            this._cachedHasFocusableChild = false;\n            for (const child of this.children) {\n                if (child._focusable || child._hasFocusableChild()) {\n                    this._cachedHasFocusableChild = true;\n                    break;\n                }\n            }\n        }\n        return this._cachedHasFocusableChild;\n    }\n    find(predicate) {\n        if (predicate(this))\n            return this;\n        for (const child of this.children) {\n            const result = child.find(predicate);\n            if (result)\n                return result;\n        }\n        return null;\n    }\n    isLeafNode() {\n        if (!this.children.length)\n            return true;\n        // These types of objects may have children that we use as internal\n        // implementation details, but we want to expose them as leaves to platform\n        // accessibility APIs because screen readers might be confused if they find\n        // any children.\n        if (this._isPlainTextField() || this._isTextOnlyObject())\n            return true;\n        // Roles whose children are only presentational according to the ARIA and\n        // HTML5 Specs should be hidden from screen readers.\n        // (Note that whilst ARIA buttons can have only presentational children, HTML5\n        // buttons are allowed to have content.)\n        switch (this._role) {\n            case 'doc-cover':\n            case 'graphics-symbol':\n            case 'img':\n            case 'Meter':\n            case 'scrollbar':\n            case 'slider':\n            case 'separator':\n            case 'progressbar':\n                return true;\n            default:\n                break;\n        }\n        // Here and below: Android heuristics\n        if (this._hasFocusableChild())\n            return false;\n        if (this._focusable && this._name)\n            return true;\n        if (this._role === 'heading' && this._name)\n            return true;\n        return false;\n    }\n    isControl() {\n        switch (this._role) {\n            case 'button':\n            case 'checkbox':\n            case 'ColorWell':\n            case 'combobox':\n            case 'DisclosureTriangle':\n            case 'listbox':\n            case 'menu':\n            case 'menubar':\n            case 'menuitem':\n            case 'menuitemcheckbox':\n            case 'menuitemradio':\n            case 'radio':\n            case 'scrollbar':\n            case 'searchbox':\n            case 'slider':\n            case 'spinbutton':\n            case 'switch':\n            case 'tab':\n            case 'textbox':\n            case 'tree':\n            case 'treeitem':\n                return true;\n            default:\n                return false;\n        }\n    }\n    isInteresting(insideControl) {\n        const role = this._role;\n        if (role === 'Ignored' || this._hidden || this._ignored)\n            return false;\n        if (this._focusable || this._richlyEditable)\n            return true;\n        // If it's not focusable but has a control role, then it's interesting.\n        if (this.isControl())\n            return true;\n        // A non focusable child of a control is not interesting\n        if (insideControl)\n            return false;\n        return this.isLeafNode() && !!this._name;\n    }\n    serialize() {\n        const properties = new Map();\n        for (const property of this.payload.properties || [])\n            properties.set(property.name.toLowerCase(), property.value.value);\n        if (this.payload.name)\n            properties.set('name', this.payload.name.value);\n        if (this.payload.value)\n            properties.set('value', this.payload.value.value);\n        if (this.payload.description)\n            properties.set('description', this.payload.description.value);\n        const node = {\n            role: this._role,\n        };\n        const userStringProperties = [\n            'name',\n            'value',\n            'description',\n            'keyshortcuts',\n            'roledescription',\n            'valuetext',\n        ];\n        const getUserStringPropertyValue = (key) => properties.get(key);\n        for (const userStringProperty of userStringProperties) {\n            if (!properties.has(userStringProperty))\n                continue;\n            node[userStringProperty] = getUserStringPropertyValue(userStringProperty);\n        }\n        const booleanProperties = [\n            'disabled',\n            'expanded',\n            'focused',\n            'modal',\n            'multiline',\n            'multiselectable',\n            'readonly',\n            'required',\n            'selected',\n        ];\n        const getBooleanPropertyValue = (key) => properties.get(key);\n        for (const booleanProperty of booleanProperties) {\n            // WebArea's treat focus differently than other nodes. They report whether\n            // their frame  has focus, not whether focus is specifically on the root\n            // node.\n            if (booleanProperty === 'focused' && this._role === 'WebArea')\n                continue;\n            const value = getBooleanPropertyValue(booleanProperty);\n            if (!value)\n                continue;\n            node[booleanProperty] = getBooleanPropertyValue(booleanProperty);\n        }\n        const tristateProperties = ['checked', 'pressed'];\n        for (const tristateProperty of tristateProperties) {\n            if (!properties.has(tristateProperty))\n                continue;\n            const value = properties.get(tristateProperty);\n            node[tristateProperty] =\n                value === 'mixed' ? 'mixed' : value === 'true' ? true : false;\n        }\n        const numericalProperties = [\n            'level',\n            'valuemax',\n            'valuemin',\n        ];\n        const getNumericalPropertyValue = (key) => properties.get(key);\n        for (const numericalProperty of numericalProperties) {\n            if (!properties.has(numericalProperty))\n                continue;\n            node[numericalProperty] = getNumericalPropertyValue(numericalProperty);\n        }\n        const tokenProperties = [\n            'autocomplete',\n            'haspopup',\n            'invalid',\n            'orientation',\n        ];\n        const getTokenPropertyValue = (key) => properties.get(key);\n        for (const tokenProperty of tokenProperties) {\n            const value = getTokenPropertyValue(tokenProperty);\n            if (!value || value === 'false')\n                continue;\n            node[tokenProperty] = getTokenPropertyValue(tokenProperty);\n        }\n        return node;\n    }\n    static createTree(payloads) {\n        const nodeById = new Map();\n        for (const payload of payloads)\n            nodeById.set(payload.nodeId, new AXNode(payload));\n        for (const node of nodeById.values()) {\n            for (const childId of node.payload.childIds || [])\n                node.children.push(nodeById.get(childId));\n        }\n        return nodeById.values().next().value;\n    }\n}\n//# sourceMappingURL=Accessibility.js.map"]},"metadata":{},"sourceType":"script"}